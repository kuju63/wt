name: Release to GitHub

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      force-version:
        description: 'Force specific version (e.g., v1.0.0)'
        required: false
        type: string

permissions:
  contents: write
  packages: write
  id-token: write  # Required for GitHub Dependency Submission API

env:
  DOCFX_VERSION: '2.78.4'

jobs:
  check-tests:
    name: Verify Tests Passed
    runs-on: ubuntu-latest
    # Skip this check for workflow_dispatch to allow manual releases
    if: github.event_name != 'workflow_dispatch'
    steps:
      - name: Wait for test workflow
        uses: lewagon/wait-on-check-action@3603e826ee561ea102b58accb5ea55a1a7482343 # v1.4.1
        with:
          ref: ${{ github.sha }}
          check-name: 'Run Tests'
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          wait-interval: 10
          allowed-conclusions: success

  calculate-version:
    name: Calculate Version
    runs-on: ubuntu-latest
    needs: [check-tests]
    # Allow calculate-version to run if check-tests was skipped (workflow_dispatch)
    if: |
      !cancelled() &&
      (needs.check-tests.result == 'success' || needs.check-tests.result == 'skipped')
    outputs:
      version: ${{ steps.ver.outputs.version }}
      previous-version: ${{ steps.prev.outputs.previous-version }}
      should-release: ${{ steps.check.outputs.should-release }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0  # Fetch all history for version calculation

      - name: Calculate next version
        id: version
        if: github.event.inputs.force-version == ''
        uses: paulhatch/semantic-version@a8f8f59fd7f0625188492e945240f12d7ad2dca3 # v5.4.0
        with:
          tag_prefix: "v"
          major_pattern: "(BREAKING CHANGE:|BREAKING:)"
          minor_pattern: "feat:"
          version_format: "v${major}.${minor}.${patch}"
          bump_each_commit: false
          search_commit_body: true
          user_format_type: "csv"

      - name: Use forced version
        id: forced-version
        if: github.event.inputs.force-version != ''
        run: |
          echo "version=${{ github.event.inputs.force-version }}" >> $GITHUB_OUTPUT
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "previous-version=${LAST_TAG}" >> $GITHUB_OUTPUT

      - name: Normalize version
        id: ver
        run: |
          FORCED="${{ steps.forced-version.outputs.version }}"
          SEMVER="${{ steps.version.outputs.version }}"

          if [ -n "$FORCED" ]; then
            V="$FORCED"
            case "$V" in
              v*) ;;
              *) V="v$V" ;;
            esac
            echo "version=$V" >> $GITHUB_OUTPUT
          elif [ -n "$SEMVER" ]; then
            echo "version=$SEMVER" >> $GITHUB_OUTPUT
          else
            echo "version=" >> $GITHUB_OUTPUT
          fi

      - name: Normalize previous tag
        id: prev
        run: |
          PREV_SEMVER="${{ steps.version.outputs.previous_version }}"
          PREV_FORCED="${{ steps.forced-version.outputs.previous-version }}"

          if [ -n "$PREV_FORCED" ]; then
            echo "previous-version=$PREV_FORCED" >> $GITHUB_OUTPUT
          elif [ -n "$PREV_SEMVER" ]; then
            echo "previous-version=v$PREV_SEMVER" >> $GITHUB_OUTPUT
          else
            LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
            echo "previous-version=$LAST_TAG" >> $GITHUB_OUTPUT
          fi

      - name: Check if release is needed
        id: check
        run: |
          VERSION="${{ steps.ver.outputs.version }}"
          PREVIOUS="${{ steps.prev.outputs.previous-version }}"

          if [ "$VERSION" == "$PREVIOUS" ] || [ "$VERSION" == "" ]; then
            echo "should-release=false" >> $GITHUB_OUTPUT
            echo "::notice::No version change detected, skipping release"
          else
            echo "should-release=true" >> $GITHUB_OUTPUT
            echo "::notice::Version change detected: $PREVIOUS â†’ $VERSION"
          fi

  build:
    name: Build Binaries
    needs: calculate-version
    if: needs.calculate-version.outputs.should-release == 'true'
    uses: ./.github/workflows/build.yml
    with:
      version: ${{ needs.calculate-version.outputs.version }}

  create-release:
    name: Create GitHub Release
    needs: [calculate-version, build]
    runs-on: ubuntu-latest
    timeout-minutes: 15  # SLA: 15 minutes for SBOM generation and release
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: '10.0.x'

      - name: Cache NuGet packages
        uses: actions/cache@v5
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      - name: Configure GPG
        run: |
          mkdir -p ~/.gnupg
          chmod 700 ~/.gnupg
          echo "use-agent" >> ~/.gnupg/gpg.conf
          echo "pinentry-mode loopback" >> ~/.gnupg/gpg.conf
          echo "allow-loopback-pinentry" >> ~/.gnupg/gpg-agent.conf
          gpgconf --kill gpg-agent || true
          gpgconf --launch gpg-agent || true

      - name: Download build artifacts
        uses: actions/download-artifact@v7
        with:
          path: artifacts/

      - name: Organize binaries
        run: |
          mkdir -p release-assets
          find artifacts/ -type f \( -name "wt.exe" -o -name "wt" \) -exec cp {} release-assets/ \;

          # Rename binaries to standard format
          cd release-assets
          VERSION="${{ needs.calculate-version.outputs.version }}"

          # Windows
          if [ -f "wt.exe" ]; then
            mv wt.exe "wt-${VERSION}-windows-x64.exe"
          fi

          # Linux x64
          if [ -d "../artifacts/binary-linux-x64" ]; then
            cp ../artifacts/binary-linux-x64/wt "wt-${VERSION}-linux-x64"
          fi

          # Linux ARM
          if [ -d "../artifacts/binary-linux-arm" ]; then
            cp ../artifacts/binary-linux-arm/wt "wt-${VERSION}-linux-arm"
          fi

          # macOS ARM64
          if [ -d "../artifacts/binary-macos-arm64" ]; then
            cp ../artifacts/binary-macos-arm64/wt "wt-${VERSION}-macos-arm64"
          fi

          ls -lh

      - name: Generate checksums
        run: |
          chmod +x .github/scripts/generate-checksums.sh
          .github/scripts/generate-checksums.sh release-assets/

      # Phase 3: US1 - Complete Dependency Disclosure
      - name: Restore dependencies (all platforms)
        run: |
          echo "::group::Restoring dependencies"
          set -e

          # Restore dependencies without locked mode to avoid .NET 10 SDK issues
          echo "Restoring dependencies..."
          dotnet restore wt.cli/wt.cli.csproj || {
            echo "::error::Failed to restore dependencies"
            exit 1
          }

          echo "âœ… All dependencies restored successfully"
          echo "::endgroup::"

      - name: Install Microsoft SBOM Tool
        run: |
          echo "::group::Installing Microsoft SBOM Tool"
          dotnet tool install --global Microsoft.Sbom.DotNetTool --version 4.1.5 || {
            echo "::error::Failed to install Microsoft SBOM Tool"
            exit 1
          }
          echo "âœ… Microsoft SBOM Tool installed: $(sbom-tool version)"
          echo "::endgroup::"

      - name: Generate and validate SBOM (sbom-tool)
        id: sbom
        run: |
          .github/scripts/sbom.sh \
            --drop-path "${{ github.workspace }}/release-assets" \
            --component-path "${{ github.workspace }}" \
            --package-name "${{ github.repository }}" \
            --package-version "${{ needs.calculate-version.outputs.version }}" \
            --package-supplier "Organization: kuju63" \
            --namespace-base "https://github.com/${{ github.repository }}/sbom/${{ needs.calculate-version.outputs.version }}" \
            --manifest-info "SPDX:2.2" \
            --target-path "release-assets/wt-${{ needs.calculate-version.outputs.version }}-sbom.spdx.json" \
            --validation-output "${{ github.workspace }}/sbom-validation.json"

      - name: Log SBOM metadata
        run: |
          echo "::group::SBOM Metadata"
          jq '{version: .spdxVersion, name: .name, packages: (.packages | length), created: .creationInfo.created}' "${{ steps.sbom.outputs.sbom_file }}"
          echo "::endgroup::"

      - name: Verify required packages
        env:
          SBOM_FILE: ${{ steps.sbom.outputs.sbom_file }}
        run: |
          echo "::group::Verifying required packages"
          set -e

          # Required packages for wt CLI
          REQUIRED_PACKAGES=(
            "System.CommandLine"
            "System.IO.Abstractions"
          )

          MISSING_PACKAGES=()

          for pkg in "${REQUIRED_PACKAGES[@]}"; do
            if ! jq -e ".packages[] | select(.name == \"$pkg\")" "$SBOM_FILE" > /dev/null; then
              MISSING_PACKAGES+=("$pkg")
            else
              VERSION=$(jq -r ".packages[] | select(.name == \"$pkg\") | .versionInfo" "$SBOM_FILE")
              echo "âœ… Found: $pkg@$VERSION"
            fi
          done

          if [ ${#MISSING_PACKAGES[@]} -gt 0 ]; then
            echo "::error::Missing required packages in SBOM:"
            for pkg in "${MISSING_PACKAGES[@]}"; do
              echo "::error::  - $pkg"
            done
            exit 1
          fi

          echo "âœ… All required packages present"
          echo "::endgroup::"

      - name: Validate package count threshold
        env:
          SBOM_FILE: ${{ steps.sbom.outputs.sbom_file }}
        run: |
          echo "::group::Validating package count"
          set -e

          PACKAGE_COUNT=$(jq '.packages | length' "$SBOM_FILE")
          MIN_PACKAGES=2  # At minimum, System.CommandLine and System.IO.Abstractions

          if [ "$PACKAGE_COUNT" -lt "$MIN_PACKAGES" ]; then
            echo "::error::Package count ($PACKAGE_COUNT) is below minimum threshold ($MIN_PACKAGES)"
            echo "::error::This indicates incomplete dependency resolution"
            exit 1
          fi

          echo "âœ… Package count validation passed: $PACKAGE_COUNT packages (minimum: $MIN_PACKAGES)"
          echo "::endgroup::"

      # Phase 5: US4 - GitHub Integration
      - name: Submit SBOM to GitHub Dependency Graph
        id: dependency-submission
        run: |
          echo "::group::Submitting SBOM to GitHub Dependency Graph"

          # Note: GitHub Actions does not have a native SPDX dependency submission action yet
          # This is a placeholder for when the feature becomes available
          # For now, we log the intent and skip submission

          echo "â„¹ï¸  SBOM file: ${{ steps.sbom.outputs.sbom_file }}"
          echo "â„¹ï¸  GitHub Dependency Graph submission will be available when:"
          echo "   - GitHub releases native SPDX support for Dependency Submission API"
          echo "   - OR we implement manual SPDX â†’ Dependency Graph format conversion"
          echo ""
          echo "âš ï¸  For now, SBOM is available as a release asset for manual analysis"
          echo "::notice::SBOM available at: https://github.com/${{ github.repository }}/releases/download/${{ needs.calculate-version.outputs.version }}/wt-${{ needs.calculate-version.outputs.version }}-sbom.spdx.json"
          echo "::endgroup::"
        continue-on-error: true  # Don't fail pipeline if submission is not yet implemented

      - name: Verify Dependency Graph submission
        if: always()
        run: |
          echo "::group::Dependency Graph Submission Status"

          # Check if submission step completed
          if [ "${{ steps.dependency-submission.outcome }}" == "success" ]; then
            echo "âœ… Dependency Graph submission noted"
            echo "::notice::SBOM is available as release asset: wt-${{ needs.calculate-version.outputs.version }}-sbom.spdx.json"
          else
            echo "â„¹ï¸  Dependency Graph submission skipped (feature pending)"
            echo "::notice::SBOM is available as release asset for manual analysis"
          fi

          echo "::notice::View releases: https://github.com/${{ github.repository }}/releases"
          echo "::endgroup::"

      # Phase 6: US3 - SPDX Compliance Verification
      - name: Verify SPDX 2.2+ compliance
        env:
          SBOM_FILE: ${{ steps.sbom.outputs.sbom_file }}
        run: |
          echo "::group::Verifying SPDX 2.2+ compliance"
          set -e

          # Verify SPDX version is 2.2 or higher
          SPDX_VERSION=$(jq -r '.spdxVersion' "$SBOM_FILE")
          if [[ ! "$SPDX_VERSION" =~ ^SPDX-2\.[2-9]$ ]] && [[ ! "$SPDX_VERSION" =~ ^SPDX-[3-9]\. ]]; then
            echo "::error::Invalid SPDX version: $SPDX_VERSION (expected SPDX-2.2 or higher)"
            exit 1
          fi
          echo "âœ… SPDX version: $SPDX_VERSION"

          # Verify dataLicense is CC0-1.0
          DATA_LICENSE=$(jq -r '.dataLicense' "$SBOM_FILE")
          if [ "$DATA_LICENSE" != "CC0-1.0" ]; then
            echo "::error::Invalid dataLicense: $DATA_LICENSE (expected CC0-1.0)"
            exit 1
          fi
          echo "âœ… Data license: $DATA_LICENSE"

          # Verify documentNamespace uniqueness (must be unique URI)
          NAMESPACE=$(jq -r '.documentNamespace' "$SBOM_FILE")
          if [ -z "$NAMESPACE" ] || [ "$NAMESPACE" == "null" ]; then
            echo "::error::Missing documentNamespace"
            exit 1
          fi
          echo "âœ… Document namespace: $NAMESPACE"

          # Verify NOASSERTION handling for missing license information
          NOASSERTION_COUNT=$(jq '[.packages[] | select(.licenseConcluded == "NOASSERTION" or .licenseDeclared == "NOASSERTION")] | length' "$SBOM_FILE")
          if [ "$NOASSERTION_COUNT" -gt 0 ]; then
            echo "âš ï¸  Warning: $NOASSERTION_COUNT packages have NOASSERTION license information"
            jq -r '.packages[] | select(.licenseConcluded == "NOASSERTION" or .licenseDeclared == "NOASSERTION") | "  - \(.name)@\(.versionInfo)"' "$SBOM_FILE"
          fi

          echo "âœ… SPDX 2.2+ compliance verified"
          echo "::endgroup::"

      # Phase 8: Performance Metrics
      - name: Log performance metrics
        run: |
          echo "::group::Performance Metrics"

          # Log cache statistics
          echo "ðŸ“Š NuGet Cache Statistics:"
          du -sh ~/.nuget/packages 2>/dev/null || echo "Cache size: N/A"

          # Log SBOM generation time (approximate)
          echo "â±ï¸  SBOM Generation: Completed within workflow timeout"

          # Log file sizes
          echo "ðŸ“¦ Release Asset Sizes:"
          ls -lh release-assets/ | grep -E "\.(exe|spdx\.json|asc)$" || true

          echo "::endgroup::"

      - name: Sign artifacts
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
          SBOM_FILE: ${{ steps.sbom.outputs.sbom_file }}
        run: |
          .github/scripts/sign-artifacts.sh

      - name: Generate release notes
        run: |
          .github/scripts/generate-release-notes.sh \
            "${{ needs.calculate-version.outputs.previous-version }}" \
            "${{ needs.calculate-version.outputs.version }}"

      - name: Create Git tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "${{ needs.calculate-version.outputs.version }}" -m "Release ${{ needs.calculate-version.outputs.version }}"
          git push origin "${{ needs.calculate-version.outputs.version }}"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@a06a81a03ee405af7f2048a818ed3f03bbf83c7b # v2
        with:
          tag_name: ${{ needs.calculate-version.outputs.version }}
          name: ${{ needs.calculate-version.outputs.version }}
          body_path: release-notes.md
          draft: false
          prerelease: false
          files: |
            release-assets/wt-*-windows-*.exe
            release-assets/wt-*-linux-*
            release-assets/wt-*-macos-*
            release-assets/wt-*-sbom.spdx.json
            release-assets/wt-*-sbom.spdx.json.asc
            release-assets/SHA256SUMS
            release-assets/SHA256SUMS.asc
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Release summary
        run: |
          echo "### ðŸš€ Release ${{ needs.calculate-version.outputs.version }} Published" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Previous version**: ${{ needs.calculate-version.outputs.previous-version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **New version**: ${{ needs.calculate-version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Release URL**: https://github.com/${{ github.repository }}/releases/tag/${{ needs.calculate-version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "#### ðŸ“¦ Assets" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          ls -lh release-assets/ >> $GITHUB_STEP_SUMMARY

  build-and-deploy-docs:
    name: Build and Deploy Documentation
    needs: [calculate-version, create-release]
    runs-on: ubuntu-latest
    
    permissions:
      contents: write
      pages: write
      id-token: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
      
      - name: Setup .NET
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: '10.0.x'
      
      - name: Cache NuGet packages
        uses: actions/cache@v5
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
          restore-keys: |
            ${{ runner.os }}-nuget-
      
      - name: Cache DocFX
        uses: actions/cache@v5
        with:
          path: ~/.dotnet/tools
          key: ${{ runner.os }}-docfx-${{ env.DOCFX_VERSION }}
          restore-keys: |
            ${{ runner.os }}-docfx-
      
      - name: Install DocFX
        run: dotnet tool install docfx --version ${{ env.DOCFX_VERSION }} --global
      
      - name: Extract version
        id: version
        run: |
          TAG_NAME="${{ needs.calculate-version.outputs.version }}"
          # Extract major.minor from tag (e.g., v1.2.3 -> v1.2)
          VERSION=$(echo $TAG_NAME | grep -oE 'v?[0-9]+\.[0-9]+')
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Extracted version: $VERSION"
      
      - name: Generate command documentation
        run: dotnet run --project Tools/DocGenerator/DocGenerator -- --output docs/commands
      
      - name: Build documentation
        run: |
          docfx metadata
          docfx build --output _site/${{ steps.version.outputs.version }}
      
      - name: Update version manifest
        run: |
          python3 .github/scripts/update-version-manifest.py _site/versions.json ${{ steps.version.outputs.version }}
          cp _site/versions.json _site/${{ steps.version.outputs.version }}/versions.json
      
      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./_site
          keep_files: true
