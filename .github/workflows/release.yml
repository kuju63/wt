name: Release to GitHub

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      force-version:
        description: 'Force specific version (e.g., v1.0.0)'
        required: false
        type: string

permissions:
  contents: write
  packages: write
  id-token: write  # Required for GitHub Dependency Submission API

jobs:
  check-tests:
    name: Verify Tests Passed
    runs-on: ubuntu-latest
    # Skip this check for workflow_dispatch to allow manual releases
    if: github.event_name != 'workflow_dispatch'
    steps:
      - name: Wait for test workflow
        uses: lewagon/wait-on-check-action@3603e826ee561ea102b58accb5ea55a1a7482343 # v1.4.1
        with:
          ref: ${{ github.sha }}
          check-name: 'Run Tests'
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          wait-interval: 10
          allowed-conclusions: success

  calculate-version:
    name: Calculate Version
    runs-on: ubuntu-latest
    needs: [check-tests]
    # Allow calculate-version to run if check-tests was skipped (workflow_dispatch)
    if: |
      !cancelled() &&
      (needs.check-tests.result == 'success' || needs.check-tests.result == 'skipped')
    outputs:
      version: ${{ steps.version.outputs.version }}
      previous-version: ${{ steps.version.outputs.previous_version }}
      should-release: ${{ steps.check.outputs.should-release }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0  # Fetch all history for version calculation

      - name: Calculate next version
        id: version
        if: github.event.inputs.force-version == ''
        uses: paulhatch/semantic-version@a8f8f59fd7f0625188492e945240f12d7ad2dca3 # v5.4.0
        with:
          tag_prefix: "v"
          major_pattern: "(BREAKING CHANGE:|BREAKING:)"
          minor_pattern: "feat:"
          version_format: "v${major}.${minor}.${patch}"
          bump_each_commit: false
          search_commit_body: true
          user_format_type: "csv"

      - name: Use forced version
        id: forced-version
        if: github.event.inputs.force-version != ''
        run: |
          echo "version=${{ github.event.inputs.force-version }}" >> $GITHUB_OUTPUT
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "previous-version=${LAST_TAG}" >> $GITHUB_OUTPUT

      - name: Check if release is needed
        id: check
        run: |
          VERSION="${{ steps.version.outputs.version || steps.forced-version.outputs.version }}"
          PREVIOUS="${{ steps.version.outputs.previous_version || steps.forced-version.outputs.previous-version }}"

          if [ "$VERSION" == "$PREVIOUS" ] || [ "$VERSION" == "" ]; then
            echo "should-release=false" >> $GITHUB_OUTPUT
            echo "::notice::No version change detected, skipping release"
          else
            echo "should-release=true" >> $GITHUB_OUTPUT
            echo "::notice::Version change detected: $PREVIOUS â†’ $VERSION"
          fi

  build:
    name: Build Binaries
    needs: calculate-version
    if: needs.calculate-version.outputs.should-release == 'true'
    uses: ./.github/workflows/build.yml
    with:
      version: ${{ needs.calculate-version.outputs.version }}

  create-release:
    name: Create GitHub Release
    needs: [calculate-version, build]
    runs-on: ubuntu-latest
    timeout-minutes: 15  # SLA: 15 minutes for SBOM generation and release
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: '10.0.x'

      - name: Cache NuGet packages
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/

      - name: Organize binaries
        run: |
          mkdir -p release-assets
          find artifacts/ -type f \( -name "wt.exe" -o -name "wt" \) -exec cp {} release-assets/ \;

          # Rename binaries to standard format
          cd release-assets
          VERSION="${{ needs.calculate-version.outputs.version }}"

          # Windows
          if [ -f "wt.exe" ]; then
            mv wt.exe "wt-${VERSION}-windows-x64.exe"
          fi

          # Linux x64
          if [ -d "../artifacts/binary-linux-x64" ]; then
            cp ../artifacts/binary-linux-x64/wt "wt-${VERSION}-linux-x64"
          fi

          # Linux ARM
          if [ -d "../artifacts/binary-linux-arm" ]; then
            cp ../artifacts/binary-linux-arm/wt "wt-${VERSION}-linux-arm"
          fi

          # macOS ARM64
          if [ -d "../artifacts/binary-macos-arm64" ]; then
            cp ../artifacts/binary-macos-arm64/wt "wt-${VERSION}-macos-arm64"
          fi

          ls -lh

      - name: Generate checksums
        run: |
          chmod +x .github/scripts/generate-checksums.sh
          .github/scripts/generate-checksums.sh release-assets/

      # Phase 3: US1 - Complete Dependency Disclosure
      - name: Restore dependencies (all platforms)
        run: |
          echo "::group::Restoring dependencies"
          set -e

          # Restore dependencies without locked mode to avoid .NET 10 SDK issues
          echo "Restoring dependencies..."
          dotnet restore wt.cli/wt.cli.csproj || {
            echo "::error::Failed to restore dependencies"
            exit 1
          }

          echo "âœ… All dependencies restored successfully"
          echo "::endgroup::"

      - name: Install Microsoft SBOM Tool
        run: |
          echo "::group::Installing Microsoft SBOM Tool"
          dotnet tool install --global Microsoft.Sbom.DotNetTool --version 2.2.0 || {
            echo "::error::Failed to install Microsoft SBOM Tool"
            exit 1
          }
          echo "âœ… Microsoft SBOM Tool installed: $(sbom-tool version)"
          echo "::endgroup::"

      - name: Generate SBOM with Microsoft SBOM Tool
        run: |
          echo "::group::Generating SBOM (SPDX 2.3)"
          set -e

          VERSION="${{ needs.calculate-version.outputs.version }}"
          SBOM_OUTPUT_DIR="${{ github.workspace }}/_manifest"

          # Create output directory
          mkdir -p "$SBOM_OUTPUT_DIR"

          sbom-tool generate \
            -b "$SBOM_OUTPUT_DIR" \
            -bc "${{ github.workspace }}" \
            -pn "${{ github.repository }}" \
            -pv "$VERSION" \
            -ps "Organization: kuju63" \
            -nsb "https://github.com/${{ github.repository }}/sbom/$VERSION-$(date +%Y%m%d%H%M%S)" \
            -v Information || {
            echo "::error::SBOM generation failed"
            echo "::error::This is a security-critical failure. Release cannot proceed."
            exit 1
          }

          # Copy SBOM to release assets with standard naming
          SBOM_SOURCE="$SBOM_OUTPUT_DIR/_manifest/spdx_2.2/manifest.spdx.json"
          SBOM_TARGET="release-assets/wt-${VERSION}-sbom.spdx.json"

          if [ ! -f "$SBOM_SOURCE" ]; then
            echo "::error::SBOM file not found: $SBOM_SOURCE"
            exit 1
          fi

          cp "$SBOM_SOURCE" "$SBOM_TARGET"
          echo "âœ… SBOM generated: $SBOM_TARGET"
          echo "::endgroup::"

          # Log SBOM metadata
          echo "::group::SBOM Metadata"
          jq '{version: .spdxVersion, name: .name, packages: (.packages | length), created: .creationInfo.created}' "$SBOM_TARGET"
          echo "::endgroup::"

      - name: Verify SBOM completeness
        run: |
          echo "::group::Verifying SBOM"
          set -e

          SBOM_FILE="release-assets/wt-${{ needs.calculate-version.outputs.version }}-sbom.spdx.json"

          # Verify file exists
          if [ ! -f "$SBOM_FILE" ]; then
            echo "::error::SBOM generation failed - file not found: $SBOM_FILE"
            echo "::error::This is a security-critical failure. Release cannot proceed."
            exit 1
          fi

          # Verify SBOM is valid JSON
          if ! jq empty "$SBOM_FILE" 2>/dev/null; then
            echo "::error::SBOM file is not valid JSON: $SBOM_FILE"
            exit 1
          fi

          # Verify SBOM has packages
          PACKAGE_COUNT=$(jq '.packages | length' "$SBOM_FILE")
          if [ "$PACKAGE_COUNT" -lt 1 ]; then
            echo "::error::SBOM contains no packages. This indicates a generation failure."
            exit 1
          fi

          echo "âœ… SBOM validated: $PACKAGE_COUNT packages found"
          echo "::endgroup::"

      # Phase 4: US2 - SBOM Validation
      - name: Validate SPDX format
        run: |
          echo "::group::Validating SPDX 2.3 format"
          set -e

          SBOM_FILE="release-assets/wt-${{ needs.calculate-version.outputs.version }}-sbom.spdx.json"

          # Validate SBOM is valid JSON
          if ! jq empty "$SBOM_FILE" 2>/dev/null; then
            echo "::error::SBOM file is not valid JSON"
            exit 1
          fi
          echo "âœ… Valid JSON format"

          # Validate required SPDX fields
          SPDX_VERSION=$(jq -r '.spdxVersion' "$SBOM_FILE")
          if [ -z "$SPDX_VERSION" ] || [ "$SPDX_VERSION" = "null" ]; then
            echo "::error::Missing required field: spdxVersion"
            exit 1
          fi
          echo "âœ… SPDX Version: $SPDX_VERSION"

          DATA_LICENSE=$(jq -r '.dataLicense' "$SBOM_FILE")
          if [ -z "$DATA_LICENSE" ] || [ "$DATA_LICENSE" = "null" ]; then
            echo "::error::Missing required field: dataLicense"
            exit 1
          fi
          echo "âœ… Data License: $DATA_LICENSE"

          DOC_NAME=$(jq -r '.name' "$SBOM_FILE")
          if [ -z "$DOC_NAME" ] || [ "$DOC_NAME" = "null" ]; then
            echo "::error::Missing required field: name"
            exit 1
          fi
          echo "âœ… Document Name: $DOC_NAME"

          DOC_NAMESPACE=$(jq -r '.documentNamespace' "$SBOM_FILE")
          if [ -z "$DOC_NAMESPACE" ] || [ "$DOC_NAMESPACE" = "null" ]; then
            echo "::error::Missing required field: documentNamespace"
            exit 1
          fi
          echo "âœ… Document Namespace: $DOC_NAMESPACE"

          CREATION_INFO=$(jq -r '.creationInfo.created' "$SBOM_FILE")
          if [ -z "$CREATION_INFO" ] || [ "$CREATION_INFO" = "null" ]; then
            echo "::error::Missing required field: creationInfo.created"
            exit 1
          fi
          echo "âœ… Creation Date: $CREATION_INFO"

          # Validate packages array exists
          if ! jq -e '.packages' "$SBOM_FILE" > /dev/null; then
            echo "::error::Missing required field: packages"
            exit 1
          fi
          PACKAGE_COUNT=$(jq '.packages | length' "$SBOM_FILE")
          echo "âœ… Packages Array: $PACKAGE_COUNT packages"

          echo "âœ… SBOM passes SPDX format validation (offline)"
          echo "::endgroup::"

      - name: Verify required packages
        run: |
          echo "::group::Verifying required packages"
          set -e

          SBOM_FILE="release-assets/wt-${{ needs.calculate-version.outputs.version }}-sbom.spdx.json"

          # Required packages for wt CLI
          REQUIRED_PACKAGES=(
            "System.CommandLine"
            "System.IO.Abstractions"
          )

          MISSING_PACKAGES=()

          for pkg in "${REQUIRED_PACKAGES[@]}"; do
            if ! jq -e ".packages[] | select(.name == \"$pkg\")" "$SBOM_FILE" > /dev/null; then
              MISSING_PACKAGES+=("$pkg")
            else
              VERSION=$(jq -r ".packages[] | select(.name == \"$pkg\") | .versionInfo" "$SBOM_FILE")
              echo "âœ… Found: $pkg@$VERSION"
            fi
          done

          if [ ${#MISSING_PACKAGES[@]} -gt 0 ]; then
            echo "::error::Missing required packages in SBOM:"
            for pkg in "${MISSING_PACKAGES[@]}"; do
              echo "::error::  - $pkg"
            done
            exit 1
          fi

          echo "âœ… All required packages present"
          echo "::endgroup::"

      - name: Validate package count threshold
        run: |
          echo "::group::Validating package count"
          set -e

          SBOM_FILE="release-assets/wt-${{ needs.calculate-version.outputs.version }}-sbom.spdx.json"
          PACKAGE_COUNT=$(jq '.packages | length' "$SBOM_FILE")
          MIN_PACKAGES=2  # At minimum, System.CommandLine and System.IO.Abstractions

          if [ "$PACKAGE_COUNT" -lt "$MIN_PACKAGES" ]; then
            echo "::error::Package count ($PACKAGE_COUNT) is below minimum threshold ($MIN_PACKAGES)"
            echo "::error::This indicates incomplete dependency resolution"
            exit 1
          fi

          echo "âœ… Package count validation passed: $PACKAGE_COUNT packages (minimum: $MIN_PACKAGES)"
          echo "::endgroup::"

      # Phase 5: US4 - GitHub Integration
      - name: Submit SBOM to GitHub Dependency Graph
        id: dependency-submission
        run: |
          echo "::group::Submitting SBOM to GitHub Dependency Graph"

          # Note: GitHub Actions does not have a native SPDX dependency submission action yet
          # This is a placeholder for when the feature becomes available
          # For now, we log the intent and skip submission

          echo "â„¹ï¸  SBOM file: release-assets/wt-${{ needs.calculate-version.outputs.version }}-sbom.spdx.json"
          echo "â„¹ï¸  GitHub Dependency Graph submission will be available when:"
          echo "   - GitHub releases native SPDX support for Dependency Submission API"
          echo "   - OR we implement manual SPDX â†’ Dependency Graph format conversion"
          echo ""
          echo "âš ï¸  For now, SBOM is available as a release asset for manual analysis"
          echo "::notice::SBOM available at: https://github.com/${{ github.repository }}/releases/download/${{ needs.calculate-version.outputs.version }}/wt-${{ needs.calculate-version.outputs.version }}-sbom.spdx.json"
          echo "::endgroup::"
        continue-on-error: true  # Don't fail pipeline if submission is not yet implemented

      - name: Verify Dependency Graph submission
        if: always()
        run: |
          echo "::group::Dependency Graph Submission Status"

          # Check if submission step completed
          if [ "${{ steps.dependency-submission.outcome }}" == "success" ]; then
            echo "âœ… Dependency Graph submission noted"
            echo "::notice::SBOM is available as release asset: wt-${{ needs.calculate-version.outputs.version }}-sbom.spdx.json"
          else
            echo "â„¹ï¸  Dependency Graph submission skipped (feature pending)"
            echo "::notice::SBOM is available as release asset for manual analysis"
          fi

          echo "::notice::View releases: https://github.com/${{ github.repository }}/releases"
          echo "::endgroup::"

      # Phase 6: US3 - SPDX Compliance Verification
      - name: Verify SPDX 2.3+ compliance
        run: |
          echo "::group::Verifying SPDX 2.3+ compliance"
          set -e

          SBOM_FILE="release-assets/wt-${{ needs.calculate-version.outputs.version }}-sbom.spdx.json"

          # Verify SPDX version is 2.3 or higher
          SPDX_VERSION=$(jq -r '.spdxVersion' "$SBOM_FILE")
          if [[ ! "$SPDX_VERSION" =~ ^SPDX-2\.[3-9]$ ]] && [[ ! "$SPDX_VERSION" =~ ^SPDX-[3-9]\. ]]; then
            echo "::error::Invalid SPDX version: $SPDX_VERSION (expected SPDX-2.3 or higher)"
            exit 1
          fi
          echo "âœ… SPDX version: $SPDX_VERSION"

          # Verify dataLicense is CC0-1.0
          DATA_LICENSE=$(jq -r '.dataLicense' "$SBOM_FILE")
          if [ "$DATA_LICENSE" != "CC0-1.0" ]; then
            echo "::error::Invalid dataLicense: $DATA_LICENSE (expected CC0-1.0)"
            exit 1
          fi
          echo "âœ… Data license: $DATA_LICENSE"

          # Verify documentNamespace uniqueness (must be unique URI)
          NAMESPACE=$(jq -r '.documentNamespace' "$SBOM_FILE")
          if [ -z "$NAMESPACE" ] || [ "$NAMESPACE" == "null" ]; then
            echo "::error::Missing documentNamespace"
            exit 1
          fi
          echo "âœ… Document namespace: $NAMESPACE"

          # Verify NOASSERTION handling for missing license information
          NOASSERTION_COUNT=$(jq '[.packages[] | select(.licenseConcluded == "NOASSERTION" or .licenseDeclared == "NOASSERTION")] | length' "$SBOM_FILE")
          if [ "$NOASSERTION_COUNT" -gt 0 ]; then
            echo "âš ï¸  Warning: $NOASSERTION_COUNT packages have NOASSERTION license information"
            jq -r '.packages[] | select(.licenseConcluded == "NOASSERTION" or .licenseDeclared == "NOASSERTION") | "  - \(.name)@\(.versionInfo)"' "$SBOM_FILE"
          fi

          echo "âœ… SPDX 2.3+ compliance verified"
          echo "::endgroup::"

      # Phase 8: Performance Metrics
      - name: Log performance metrics
        run: |
          echo "::group::Performance Metrics"

          # Log cache statistics
          echo "ðŸ“Š NuGet Cache Statistics:"
          du -sh ~/.nuget/packages 2>/dev/null || echo "Cache size: N/A"

          # Log SBOM generation time (approximate)
          echo "â±ï¸  SBOM Generation: Completed within workflow timeout"

          # Log file sizes
          echo "ðŸ“¦ Release Asset Sizes:"
          ls -lh release-assets/ | grep -E "\.(exe|spdx\.json|asc)$" || true

          echo "::endgroup::"

      - name: Sign artifacts
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          cd release-assets
          chmod +x ../.github/scripts/sign-artifacts.sh
          ../.github/scripts/sign-artifacts.sh

      - name: Generate release notes
        run: |
          chmod +x .github/scripts/generate-release-notes.sh
          .github/scripts/generate-release-notes.sh \
            "${{ needs.calculate-version.outputs.previous-version }}" \
            "${{ needs.calculate-version.outputs.version }}"

      - name: Create Git tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "${{ needs.calculate-version.outputs.version }}" -m "Release ${{ needs.calculate-version.outputs.version }}"
          git push origin "${{ needs.calculate-version.outputs.version }}"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@a06a81a03ee405af7f2048a818ed3f03bbf83c7b # v2
        with:
          tag_name: ${{ needs.calculate-version.outputs.version }}
          name: ${{ needs.calculate-version.outputs.version }}
          body_path: release-notes.md
          draft: false
          prerelease: false
          files: |
            release-assets/wt-*-windows-*.exe
            release-assets/wt-*-linux-*
            release-assets/wt-*-macos-*
            release-assets/wt-*-sbom.spdx.json
            release-assets/wt-*-sbom.spdx.json.asc
            release-assets/SHA256SUMS
            release-assets/SHA256SUMS.asc
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Release summary
        run: |
          echo "### ðŸš€ Release ${{ needs.calculate-version.outputs.version }} Published" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Previous version**: ${{ needs.calculate-version.outputs.previous-version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **New version**: ${{ needs.calculate-version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Release URL**: https://github.com/${{ github.repository }}/releases/tag/${{ needs.calculate-version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "#### ðŸ“¦ Assets" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          ls -lh release-assets/ >> $GITHUB_STEP_SUMMARY
