{
  "AGENTS.html": {
    "href": "AGENTS.html",
    "title": "AI エージェント共通ルール | wt",
    "summary": "AI エージェント共通ルール このドキュメントは、プロジェクトで使用する AI エージェントに対する共通ルールを定義します。 1. コミュニケーション言語 日本語を優先とします ユーザーから英語で問いかけられた場合には、英語で回答すること 技術用語は適切に英語を併記することが望ましい 2. 質問のガイドライン ユーザーに対する質問は単一とすること 複数の質問をまとめて行わないこと 一つの質問に対する回答を得てから、次の質問を行うこと 3. 技術的な質問への対応 技術的な質問を行う際は、詳細を明確にすること ユーザーが複数の選択肢から選定できるように情報を提供すること 各選択肢のメリット・デメリットを提示すること 推奨案がある場合は、その理由とともに提示すること 4. 開発スタイル プロジェクトは以下の開発スタイルをベースとします: SDD (Specification-Driven Development): 仕様駆動開発 TDD (Test-Driven Development): テスト駆動開発 開発ワークフロー 以下のワークフローに従って開発を進めます: flowchart TD A[要件・課題の確認] --> B[仕様書作成<br/>Spec Kitを使用] B --> C{仕様レビュー} C -->|修正必要| B C -->|承認| D[テスト設計] D --> E[テストコード作成<br/>Red: テスト失敗を確認] E --> F[実装<br/>Green: テストが通る最小限の実装] F --> G{テスト実行} G -->|失敗| F G -->|成功| H[リファクタリング<br/>コード品質の向上] H --> I{テスト実行} I -->|失敗| H I -->|成功| J{仕様を満たしているか} J -->|不足| D J -->|完了| K[コミット準備] K --> L[変更内容確認] L --> M[コミットメッセージ<br/>Draft提供] M --> N[ユーザーがコミット実行] ワークフローのポイント: 仕様優先: 実装前に必ず仕様書を作成し、レビューを行う Red-Green-Refactor: TDD の基本サイクルを遵守する 小さなステップ: 一度に多くの変更を行わず、小さな単位で進める 継続的な検証: 各ステップでテストを実行し、品質を保証する ユーザー主導: 最終的なコミットはユーザーが判断・実行する 5. SDD の実装 SDD の実装には Spec Kit を使用すること Spec Kit は GitHub が提供する仕様駆動開発のためのツールです 公式リポジトリ: https://github.com/github/spec-kit Spec Kit がインストールされていない場合は、ユーザーにインストールを促すこと Spec Kit のインストール uv tool install specify-cli --from git+https://github.com/github/spec-kit.git 仕様書の管理 仕様書の作成と管理は Spec Kit の規約に従うこと API ドキュメントの生成 APIドキュメントの生成にはdocfxを使用すること（バージョン: 2.78.4） ドキュメントコメントの作成対象はpublic,protected,protected internalとなるclass,interface,enum,struct,delegate,fieldに限定すること ドキュメントコメントのフォーマットはXMLドキュメントコメントを使用すること ドキュメントコメントは英語で記述すること ドキュメントコメントの記述はdotnet-api-docsを参照のこと ドキュメントの自動化システム プロジェクトは GitHub Pages を使用した自動ドキュメント公開システムを実装しています: 1. ドキュメントの種類と管理方法 ユーザー向けドキュメント(手動管理): docs/installation.md - インストールガイド(手動編集) docs/contributing.md - コントリビューションガイド(手動編集) その他の docs/ 内のMarkdownファイル(手動編集) コマンドドキュメント(自動生成): docs/commands/*.md - CLIコマンドのリファレンス docs/command-reference.md - コマンド一覧 重要: これらは Tools/DocGenerator により System.CommandLine から自動生成されるため、直接編集しないこと API リファレンス(自動生成): api/ ディレクトリ - .NET API ドキュメント 重要: DocFX により XML ドキュメントコメントから自動生成されるため、直接編集しないこと 2. ドキュメントのテストとビルド ローカルテスト: # コマンドドキュメント生成 cd Tools/DocGenerator && dotnet run -- ../../docs # DocFX ビルド docfx build docfx.json # ローカルプレビュー open _site/index.html # または xdg-open on Linux CI/CDテスト: DocFX ビルド時に --warningsAsErrors フラグで壊れたリンクを検出 LinkChecker によるリンク検証 ドキュメントのユニットテストは不要 3. バージョン管理 ドキュメントはマイナーバージョンレベルで管理（v0.1、v1.0、v1.1など） パッチバージョンは同じドキュメントを共有（v1.0.0、v1.0.1 → v1.0） 各バージョンの URL は 2 年以上安定して維持 バージョン切り替えは自動的に実装される（version-manifest.json） 4. AI エージェント向けガイダンス ドキュメントについて質問された場合: コンテンツが手動管理か自動生成かを判断 手動管理の場合: Markdown ファイルを直接編集 自動生成の場合: ソースコード(CLI定義または XML コメント)を更新 新しいCLIコマンドを実装する場合: wt.cli の RootCommand にコマンドを追加 ドキュメントは次回デプロイ時に自動生成される プレビューが必要な場合は DocGenerator を手動実行可能 API を追加・変更する場合: public メンバーに XML ドキュメントコメントを追加 dotnet-api-docs のフォーマットに従う コメントは英語で記述 対象: public, protected, protected internal の型/メンバー 6. バージョン管理とコミット コミットはユーザーが行うこと AI エージェントが直接コミットを実行してはならない ただし、コミットメッセージの Draft を提供することは許容される コミット前に変更内容の確認を促すこと 7. コミットメッセージの規約 コミットメッセージは英語で記述すること コミットメッセージは Conventional Commits に準拠すること（scope は原則使用しない） 基本フォーマット: <type>: <subject>（scope が必要な場合のみ <type>(scope): <subject> とする） 主な type: feat: 新機能 fix: バグ修正 docs: ドキュメントのみの変更 style: コードの意味に影響を与えない変更（空白、フォーマット等） refactor: バグ修正や機能追加を伴わないコード変更 test: テストの追加や修正 chore: ビルドプロセスやツールの変更"
  },
  "CHANGELOG.html": {
    "href": "CHANGELOG.html",
    "title": "Changelog | wt",
    "summary": "Changelog All notable changes to this project will be documented in this file. The format is based on Keep a Changelog, and this project adheres to Semantic Versioning. [Unreleased] Added SBOM (Software Bill of Materials) Generation: Complete supply chain transparency for all releases SPDX 2.3 format (ISO/IEC 5962:2021 compliant) Automatic generation with Microsoft SBOM Tool Includes all direct and transitive dependencies Multi-platform dependency resolution (Windows, Linux, macOS) SPDX format validation with @spdx/spdx-validator Required package verification (System.CommandLine, System.IO.Abstractions) Package count threshold validation SPDX 2.3+ compliance verification GitHub Dependency Graph Integration: Automatic submission via Dependency Submission API Enables Dependabot vulnerability alerts Supports Renovate automated dependency updates Provides visibility in repository Insights → Dependency graph SBOM Release Assets: Downloadable SBOM files attached to every GitHub release Filename format: wt-{version}-sbom.spdx.json Signed with GPG for authenticity Available for all releases PR SBOM Testing Workflow: Pre-release validation for pull requests Dry-run SBOM generation on PR creation/update SPDX format validation Required package verification Performance benchmarking (15-minute timeout) PR comment with test results Artifact upload for manual review Documentation: Comprehensive SBOM usage guides ADR 004: SBOM Generation architectural decision record SBOM Usage Guide with user and developer instructions Example SBOM file for reference README section explaining supply chain transparency Performance Optimizations: NuGet package caching for faster builds Performance metrics logging (cache hit/miss, duration tracking) 15-minute workflow timeout (down from 25 minutes) Changed Release Workflow: Enhanced with complete SBOM generation pipeline Replaced Anchore SBOM Action with Microsoft SBOM Tool Changed SBOM format from CycloneDX to SPDX 2.3 Changed filename from wt-*-sbom.json to wt-*-sbom.spdx.json Added multi-platform dependency restore Added comprehensive validation steps Added GitHub Dependency Graph submission Security Supply Chain Security: Full transparency of software components Automatic vulnerability tracking via Dependabot License compliance verification Complete audit trail for all dependencies Notes This release implements the complete SBOM generation feature as specified in: Specification: specs/004-complete-sbom-generation/spec.md Research: specs/004-complete-sbom-generation/research.md Implementation Plan: specs/004-complete-sbom-generation/plan.md ADR: docs/adr/004-sbom-generation.md For more information, see the SBOM Usage Guide."
  },
  "CODE_OF_CONDUCT.html": {
    "href": "CODE_OF_CONDUCT.html",
    "title": "Contributor Covenant 3.0 Code of Conduct | wt",
    "summary": "Contributor Covenant 3.0 Code of Conduct Our Pledge We pledge to make our community welcoming, safe, and equitable for all. We are committed to fostering an environment that respects and promotes the dignity, rights, and contributions of all individuals, regardless of characteristics including race, ethnicity, caste, color, age, physical characteristics, neurodiversity, disability, sex or gender, gender identity or expression, sexual orientation, language, philosophy or religion, national or social origin, socio-economic position, level of education, or other status. The same privileges of participation are extended to everyone who participates in good faith and in accordance with this Covenant. Encouraged Behaviors While acknowledging differences in social norms, we all strive to meet our community's expectations for positive behavior. We also understand that our words and actions may be interpreted differently than we intend based on culture, background, or native language. With these considerations in mind, we agree to behave mindfully toward each other and act in ways that center our shared values, including: Respecting the purpose of our community, our activities, and our ways of gathering. Engaging kindly and honestly with others. Respecting different viewpoints and experiences. Taking responsibility for our actions and contributions. Gracefully giving and accepting constructive feedback. Committing to repairing harm when it occurs. Behaving in other ways that promote and sustain the well-being of our community. Restricted Behaviors We agree to restrict the following behaviors in our community. Instances, threats, and promotion of these behaviors are violations of this Code of Conduct. Harassment. Violating explicitly expressed boundaries or engaging in unnecessary personal attention after any clear request to stop. Character attacks. Making insulting, demeaning, or pejorative comments directed at a community member or group of people. Stereotyping or discrimination. Characterizing anyone’s personality or behavior on the basis of immutable identities or traits. Sexualization. Behaving in a way that would generally be considered inappropriately intimate in the context or purpose of the community. Violating confidentiality. Sharing or acting on someone's personal or private information without their permission. Endangerment. Causing, encouraging, or threatening violence or other harm toward any person or group. Behaving in other ways that threaten the well-being of our community. Other Restrictions Misleading identity. Impersonating someone else for any reason, or pretending to be someone else to evade enforcement actions. Failing to credit sources. Not properly crediting the sources of content you contribute. Promotional materials. Sharing marketing or other commercial content in a way that is outside the norms of the community. Irresponsible communication. Failing to responsibly present content which includes, links or describes any other restricted behaviors. Reporting an Issue Tensions can occur between community members even when they are trying their best to collaborate. Not every conflict represents a code of conduct violation, and this Code of Conduct reinforces encouraged behaviors and norms that can help avoid conflicts and minimize harm. When an incident does occur, it is important to report it promptly. To report a possible violation, send to mail to Community Moderators Community Moderators take reports of violations seriously and will make every effort to respond in a timely manner. They will investigate all reports of code of conduct violations, reviewing messages, logs, and recordings, or interviewing witnesses and other participants. Community Moderators will keep investigation and enforcement actions as transparent as possible while prioritizing safety and confidentiality. In order to honor these values, enforcement actions are carried out in private with the involved parties, but communicating to the whole community may be part of a mutually agreed upon resolution. Addressing and Repairing Harm If an investigation by the Community Moderators finds that this Code of Conduct has been violated, the following enforcement ladder may be used to determine how best to repair harm, based on the incident's impact on the individuals involved and the community as a whole. Depending on the severity of a violation, lower rungs on the ladder may be skipped. Warning Event: A violation involving a single incident or series of incidents. Consequence: A private, written warning from the Community Moderators. Repair: Examples of repair include a private written apology, acknowledgement of responsibility, and seeking clarification on expectations. Temporarily Limited Activities Event: A repeated incidence of a violation that previously resulted in a warning, or the first incidence of a more serious violation. Consequence: A private, written warning with a time-limited cooldown period designed to underscore the seriousness of the situation and give the community members involved time to process the incident. The cooldown period may be limited to particular communication channels or interactions with particular community members. Repair: Examples of repair may include making an apology, using the cooldown period to reflect on actions and impact, and being thoughtful about re-entering community spaces after the period is over. Temporary Suspension Event: A pattern of repeated violation which the Community Moderators have tried to address with warnings, or a single serious violation. Consequence: A private written warning with conditions for return from suspension. In general, temporary suspensions give the person being suspended time to reflect upon their behavior and possible corrective actions. Repair: Examples of repair include respecting the spirit of the suspension, meeting the specified conditions for return, and being thoughtful about how to reintegrate with the community when the suspension is lifted. Permanent Ban Event: A pattern of repeated code of conduct violations that other steps on the ladder have failed to resolve, or a violation so serious that the Community Moderators determine there is no way to keep the community safe with this person as a member. Consequence: Access to all community spaces, tools, and communication channels is removed. In general, permanent bans should be rarely used, should have strong reasoning behind them, and should only be resorted to if working through other remedies has failed to change the behavior. Repair: There is no possible repair in cases of this severity. This enforcement ladder is intended as a guideline. It does not limit the ability of Community Managers to use their discretion and judgment, in keeping with the best interests of our community. Scope This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public or other spaces. Examples of representing our community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Attribution This Code of Conduct is adapted from the Contributor Covenant, version 3.0, permanently available at https://www.contributor-covenant.org/version/3/0/. Contributor Covenant is stewarded by the Organization for Ethical Source and licensed under CC BY-SA 4.0. To view a copy of this license, visit https://creativecommons.org/licenses/by-sa/4.0/ For answers to common questions about Contributor Covenant, see the FAQ at https://www.contributor-covenant.org/faq. Translations are provided at https://www.contributor-covenant.org/translations. Additional enforcement and community guideline resources can be found at https://www.contributor-covenant.org/resources. The enforcement ladder was inspired by the work of Mozilla’s code of conduct team."
  },
  "CODE_OF_CONDUCT_ja.html": {
    "href": "CODE_OF_CONDUCT_ja.html",
    "title": "コントリビューター行動規範 | wt",
    "summary": "コントリビューター行動規範 私たちの約束 メンバー、コントリビューター、およびリーダーとして、年齢、体の大きさ、目に見えるまたは目に見えない障害、民族性、性的特徴、性同一性とジェンダー表現、経験のレベル、教育、社会経済的地位、国籍、人格、人種、カースト、肌の色、宗教、または性的同一性と性的指向に関係なく、コミュニティへの参加をハラスメントのない体験にすることを誓います。 私たちは、オープンで親しみやすく、多様で包括的で健全なコミュニティに貢献する方法で行動し、交流することを誓います。 私たちの標準 前向きな環境を作り上げることに貢献する行動の例: 他人への共感と優しさを示す 異なる意見、視点、経験を尊重する 建設的なフィードバックを与え、礼儀正しく受け入れる 私たちの過ちの影響を受けた人々に責任を受け入れ、謝罪し、そしてその経験から学ぶ 個人としてだけでなく、コミュニティ全体にとっても最善であることに焦点を当てる 許容できない行動の例は次のとおりです: 性的な言葉や画像の使用、および性的な注意またはその他あらゆる種類の問題行為 トローリング、侮辱的または中傷的なコメント、個人的または政治的攻撃 公的またはプライベートの嫌がらせ 明示的な許可なしに、住所や電子メールアドレスなど、他者の個人情報を公開する 職業上不適切と合理的に考えられるその他の行為 執行責任 コミュニティリーダーは、許容される行動の基準を明確にし、実施する責任があり、不適切、脅迫的、攻撃的、または有害と見なされる行動に応じて、適切で公正な是正措置を講じます。 コミュニティリーダーは、コメント、コミット、コード、wikiの編集、問題、およびこの行動規範に沿っていないその他の貢献を削除、編集、または拒否する権利と責任を持ち、適切な場合はモデレーションの決定の理由を伝えます。 適用範囲 この行動規範は、すべてのコミュニティスペース内で適用され、個人がパブリックスペースでコミュニティを公式に代表している場合にも適用されます。私たちのコミュニティを代表する例には、公式の電子メールアドレスの使用、公式のソーシャルメディアアカウントを介した投稿、オンラインまたはオフラインのイベントでの指定代理人としての行動などがあります。 執行 虐待的、嫌がらせ、またはその他の許容できない行動の事例は、執行を担当するコミュニティリーダーに対してメールで報告される場合があります。すべての苦情は迅速かつ公正にレビューおよび調査されます。 すべてのコミュニティリーダーは、問題の報告者のプライバシーとセキュリティを尊重する義務があります。 執行ガイドライン コミュニティリーダーは、この行動規範に違反していると見なした行動への帰結を判断する際に、これらのコミュニティガイドラインに従います: 1. 更生 コミュニティへの影響: コミュニティで専門家にふさわしくない、または歓迎されないと思われる不適切な言葉の使用やその他の不適切な行動をすること。 帰結: コミュニティリーダーからの非公開の書面による警告。違反の理由を明確にし、行動が不適切だった理由を説明します。公の謝罪が要求される場合があります。 2. 警告 コミュニティへの影響: 単一の出来事または一連の動作による違反。 帰結: 持続的な行動の結果を伴う警告。指定された期間、行動規範の実施者との一方的な対話を含め、関係者との対話はありません。これには、コミュニティスペースやソーシャルメディアなどの外部チャネルでの相互作用の回避が含まれます。これらの条件に違反すると、一時的または永続的に禁止される場合があります。 3. 一時的な禁止 コミュニティへの影響: 持続的で不適切な行動を含む、コミュニティ標準の重大な違反。 帰結: 指定された期間のコミュニティとのあらゆる種類の相互関係または公的なコミュニケーションの一時的な禁止。この期間中、行動規範を実施する人々との一方的な対話を含め、関係する人々との公的または私的な対話は許可されません。これらの条件に違反すると、永久的に禁止される場合があります。 4. 永久的な禁止 コミュニティへの影響: 連続的な不適切な行動、個人への嫌がらせ、または個人の集団に対する攻撃または名誉毀損を含む、コミュニティの標準への違反のパターンを示す。 帰結: コミュニティ内でのあらゆる種類の公的な相互関係の永久的な禁止。 帰属 この行動規範は、https://www.contributor-covenant.org/version/2/1/code_of_conduct.htmlで利用可能なContributor Covenant バージョン 2.1を基に作成されています。 コミュニティへの影響ガイドラインはMozilla's code of conduct enforcement ladderに適合しています。 この行動規範に関する一般的な質問への回答については、https://www.contributor-covenant.org/faqのFAQを参照してください。翻訳はhttps://www.contributor-covenant.org/translationsで入手できます。"
  },
  "README.html": {
    "href": "README.html",
    "title": "wt - Git Worktree Manager | wt",
    "summary": "wt - Git Worktree Manager A modern CLI tool to simplify Git worktree management. Create worktrees with a single command and optionally launch your favorite editor. Features ✨ Simple worktree creation: wt create feature-branch \uD83D\uDCCB List all worktrees: wt list - Display all worktrees with their branches \uD83C\uDFAF Smart defaults: Automatically creates worktrees in ../wt-<branch> directory \uD83D\uDE80 Editor integration: Auto-launch VS Code, Vim, Emacs, or IntelliJ IDEA \uD83D\uDEE0️ Custom paths: Specify where to create worktrees \uD83D\uDCCA Table format: Human-readable table output with Unicode box-drawing characters \uD83D\uDCCB Multiple output formats: Human-readable or JSON for automation ✅ Cross-platform: Works on macOS, Linux, and Windows Installation Prerequisites .NET 10.0 SDK or later Git 2.5 or later Build from source git clone https://github.com/kuju63/wt.git cd wt dotnet build dotnet run --project wt.cli -- create --help Install globally (optional) dotnet pack dotnet tool install --global --add-source ./nupkg wt Quick Start Basic Usage Create a new worktree with a new branch: wt create feature-login This will: Create a new branch named feature-login from your current branch Create a worktree at ../wt-feature-login Check out the new branch in the worktree Specify Base Branch Create a branch from a specific base branch: wt create feature-login --base main Custom Path Create a worktree at a custom location: wt create feature-login --path ~/projects/myapp-feature-login Auto-Launch Editor Create a worktree and automatically open it in your editor: wt create feature-login --editor vscode Supported editors: vscode - Visual Studio Code vim - Vim emacs - Emacs nano - Nano idea - IntelliJ IDEA JSON Output For automation and scripting: wt create feature-login --output json Verbose Mode Show detailed diagnostic information: wt create feature-login --verbose Command Reference wt list List all worktrees with their branch information. Display all Git worktrees in the repository with their paths, checked-out branches, and status in a table format. Missing worktrees (registered but not existing on disk) are highlighted with warnings. Output: ┌─────────────────────────────────┬──────────────────┬─────────┐ │ Path │ Branch │ Status │ ├─────────────────────────────────┼──────────────────┼─────────┤ │ /Users/dev/project/wt │ main │ active │ │ /Users/dev/project/wt-feature │ feature-branch │ active │ └─────────────────────────────────┴──────────────────┴─────────┘ Exit Codes: 0 - Success 1 - Git not found 2 - Not a Git repository 10 - Git command failed 99 - Unexpected error wt create <branch> [options] Create a new worktree with a new branch. Arguments: <branch> - Name of the branch to create (required) Options: -b, --base <base> - Base branch to branch from (default: current branch) -p, --path <path> - Path where the worktree will be created (default: ../wt-<branch>) -e, --editor <type> - Editor to launch after creating worktree (choices: vscode, vim, emacs, nano, idea) --output <format> - Output format: human or json (default: human) -v, --verbose - Show detailed diagnostic information -h, --help - Show help and usage information Examples Example 1: Simple Feature Branch wt create feature-auth Output: ✓ Created branch: feature-auth ✓ Created worktree: /Users/username/projects/wt-feature-auth ✓ Checked out: feature-auth Example 2: Bug Fix with Custom Path wt create bugfix-123 --base main --path ~/bugfixes/fix-123 Example 3: With Editor Launch wt create feature-ui --editor vscode This will create the worktree and automatically open VS Code in the new worktree directory. Example 4: Automation with JSON wt create feature-api --output json | jq '.worktree.path' Output: { \"success\": true, \"worktree\": { \"path\": \"/Users/username/projects/wt-feature-api\", \"branch\": \"feature-api\", \"baseBranch\": \"main\", \"createdAt\": \"2026-01-03T12:34:56Z\" } } Troubleshooting Error: Not a git repository Solution: Run wt from within a Git repository directory. cd /path/to/your/git/repo wt create my-branch Error: Branch already exists Solution: Use a different branch name or delete the existing branch first. git branch -d existing-branch wt create existing-branch Error: Path already exists Solution: Specify a different path or remove the existing directory. wt create my-branch --path ~/different/path Error: Editor not found Solution: Ensure the editor is installed and available in your PATH. # For VS Code on macOS code --version # For Vim vim --version Supply Chain Transparency SBOM (Software Bill of Materials) Every release of wt includes a complete Software Bill of Materials (SBOM) that provides transparency about all dependencies used in the software: \uD83D\uDCC4 Format: SPDX 2.3 (ISO/IEC 5962:2021 compliant) \uD83D\uDD0D Transparency: Complete list of all direct and transitive dependencies \uD83D\uDEE1️ Security: Automatic vulnerability tracking via GitHub Dependabot ⚖️ Compliance: License information for all components \uD83D\uDCE6 Availability: Attached to every GitHub release Download SBOM # Download SBOM from latest release VERSION=$(curl -s https://api.github.com/repos/kuju63/wt/releases/latest | grep '\"tag_name\":' | sed -E 's/.*\"([^\"]+)\".*/\\1/') curl -L https://github.com/kuju63/wt/releases/download/${VERSION}/wt-${VERSION}-sbom.spdx.json \\ -o wt-sbom.spdx.json # Or download a specific version curl -L https://github.com/kuju63/wt/releases/download/v1.0.0/wt-v1.0.0-sbom.spdx.json \\ -o wt-sbom.spdx.json Verify SBOM # Install SPDX validator npm install -g @spdx/spdx-validator # Validate SBOM format spdx-validator wt-sbom.spdx.json View Dependencies # List all dependencies with versions jq -r '.packages[] | \"\\(.name)@\\(.versionInfo)\"' wt-sbom.spdx.json # Check license information jq -r '.packages[] | \"\\(.name): \\(.licenseDeclared)\"' wt-sbom.spdx.json Learn more: See the SBOM Usage Guide for detailed information. Development Project Structure wt/ ├── wt.cli/ # CLI application │ ├── Commands/ # Command implementations │ ├── Models/ # Data models │ ├── Services/ # Business logic │ └── Utils/ # Helper utilities ├── wt.tests/ # Unit and integration tests └── specs/ # Feature specifications Running Tests dotnet test Test Coverage dotnet test --collect:\"XPlat Code Coverage\" Contributing Contributions are welcome! Please follow the development guidelines. License MIT License Acknowledgments Built with: System.CommandLine - Modern command-line parsing xUnit - Testing framework FluentAssertions - Fluent assertion library"
  },
  "api/Kuju63.WorkTree.CommandLine.Commands.ListCommand.html": {
    "href": "api/Kuju63.WorkTree.CommandLine.Commands.ListCommand.html",
    "title": "Class ListCommand | wt",
    "summary": "Class ListCommand Namespace Kuju63.WorkTree.CommandLine.Commands Assembly wt.dll Command for listing all Git worktrees with their branch information. public class ListCommand : Command Inheritance object Symbol Command ListCommand Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ListCommand(IWorktreeService, IOutputFormatter) Initializes a new instance of the ListCommand class. public ListCommand(IWorktreeService worktreeService, IOutputFormatter formatter) Parameters worktreeService IWorktreeService The worktree service for retrieving worktree information. formatter IOutputFormatter The output formatter for displaying worktree information."
  },
  "api/Kuju63.WorkTree.CommandLine.Commands.Worktree.CreateCommand.html": {
    "href": "api/Kuju63.WorkTree.CommandLine.Commands.Worktree.CreateCommand.html",
    "title": "Class CreateCommand | wt",
    "summary": "Class CreateCommand Namespace Kuju63.WorkTree.CommandLine.Commands.Worktree Assembly wt.dll Represents a command to create a new Git worktree with a new branch. public class CreateCommand : Command Inheritance object Symbol Command CreateCommand Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors CreateCommand(IWorktreeService) public CreateCommand(IWorktreeService worktreeService) Parameters worktreeService IWorktreeService"
  },
  "api/Kuju63.WorkTree.CommandLine.Commands.Worktree.html": {
    "href": "api/Kuju63.WorkTree.CommandLine.Commands.Worktree.html",
    "title": "Namespace Kuju63.WorkTree.CommandLine.Commands.Worktree | wt",
    "summary": "Namespace Kuju63.WorkTree.CommandLine.Commands.Worktree Classes CreateCommand Represents a command to create a new Git worktree with a new branch."
  },
  "api/Kuju63.WorkTree.CommandLine.Commands.html": {
    "href": "api/Kuju63.WorkTree.CommandLine.Commands.html",
    "title": "Namespace Kuju63.WorkTree.CommandLine.Commands | wt",
    "summary": "Namespace Kuju63.WorkTree.CommandLine.Commands Classes ListCommand Command for listing all Git worktrees with their branch information."
  },
  "api/Kuju63.WorkTree.CommandLine.Formatters.IOutputFormatter.html": {
    "href": "api/Kuju63.WorkTree.CommandLine.Formatters.IOutputFormatter.html",
    "title": "Interface IOutputFormatter | wt",
    "summary": "Interface IOutputFormatter Namespace Kuju63.WorkTree.CommandLine.Formatters Assembly wt.dll Defines methods for formatting worktree output in different formats. public interface IOutputFormatter Methods Format(IEnumerable<WorktreeInfo>) Formats a collection of worktree information into a string. string Format(IEnumerable<WorktreeInfo> worktrees) Parameters worktrees IEnumerable<WorktreeInfo> The collection of worktree information to format. Returns string A formatted string representation of the worktrees."
  },
  "api/Kuju63.WorkTree.CommandLine.Formatters.TableColumn.html": {
    "href": "api/Kuju63.WorkTree.CommandLine.Formatters.TableColumn.html",
    "title": "Class TableColumn | wt",
    "summary": "Class TableColumn Namespace Kuju63.WorkTree.CommandLine.Formatters Assembly wt.dll Represents a column definition in a table. public record TableColumn : IEquatable<TableColumn> Inheritance object TableColumn Implements IEquatable<TableColumn> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors TableColumn(string, Func<WorktreeInfo, string>) Represents a column definition in a table. public TableColumn(string Header, Func<WorktreeInfo, string> ValueSelector) Parameters Header string The column header text. ValueSelector Func<WorktreeInfo, string> A function to extract the column value from a WorktreeInfo. Properties Header The column header text. public string Header { get; init; } Property Value string ValueSelector A function to extract the column value from a WorktreeInfo. public Func<WorktreeInfo, string> ValueSelector { get; init; } Property Value Func<WorktreeInfo, string>"
  },
  "api/Kuju63.WorkTree.CommandLine.Formatters.TableFormatter.html": {
    "href": "api/Kuju63.WorkTree.CommandLine.Formatters.TableFormatter.html",
    "title": "Class TableFormatter | wt",
    "summary": "Class TableFormatter Namespace Kuju63.WorkTree.CommandLine.Formatters Assembly wt.dll Formats worktree information as a table with Unicode box-drawing characters. public class TableFormatter : IOutputFormatter Inheritance object TableFormatter Implements IOutputFormatter Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors TableFormatter() Initializes a new instance of the TableFormatter class with default columns. public TableFormatter() TableFormatter(params TableColumn[]) Initializes a new instance of the TableFormatter class with custom columns. public TableFormatter(params TableColumn[] columns) Parameters columns TableColumn[] The columns to display in the table. Methods Format(IEnumerable<WorktreeInfo>) Formats a collection of worktree information into a table string. public string Format(IEnumerable<WorktreeInfo> worktrees) Parameters worktrees IEnumerable<WorktreeInfo> The collection of worktree information to format. Returns string A formatted table string with headers, separators, and rows."
  },
  "api/Kuju63.WorkTree.CommandLine.Formatters.html": {
    "href": "api/Kuju63.WorkTree.CommandLine.Formatters.html",
    "title": "Namespace Kuju63.WorkTree.CommandLine.Formatters | wt",
    "summary": "Namespace Kuju63.WorkTree.CommandLine.Formatters Classes TableColumn Represents a column definition in a table. TableFormatter Formats worktree information as a table with Unicode box-drawing characters. Interfaces IOutputFormatter Defines methods for formatting worktree output in different formats."
  },
  "api/Kuju63.WorkTree.CommandLine.Models.BranchInfo.html": {
    "href": "api/Kuju63.WorkTree.CommandLine.Models.BranchInfo.html",
    "title": "Class BranchInfo | wt",
    "summary": "Class BranchInfo Namespace Kuju63.WorkTree.CommandLine.Models Assembly wt.dll Represents information about a Git branch. public record BranchInfo : IEquatable<BranchInfo> Inheritance object BranchInfo Implements IEquatable<BranchInfo> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors BranchInfo(string, string?, bool, bool) Represents information about a Git branch. public BranchInfo(string Name, string? BaseBranch, bool Exists, bool IsRemote) Parameters Name string The name of the branch. BaseBranch string The base branch from which this branch was created, if any. Exists bool Indicates whether the branch exists in the repository. IsRemote bool Indicates whether the branch is a remote tracking branch. Properties BaseBranch The base branch from which this branch was created, if any. public string? BaseBranch { get; init; } Property Value string Exists Indicates whether the branch exists in the repository. public bool Exists { get; init; } Property Value bool IsRemote Indicates whether the branch is a remote tracking branch. public bool IsRemote { get; init; } Property Value bool Name The name of the branch. public string Name { get; init; } Property Value string Methods IsValidName(string) Validates whether the specified branch name is valid according to Git naming conventions. public static bool IsValidName(string name) Parameters name string The branch name to validate. Returns bool true if the branch name is valid; otherwise, false."
  },
  "api/Kuju63.WorkTree.CommandLine.Models.CommandResult-1.html": {
    "href": "api/Kuju63.WorkTree.CommandLine.Models.CommandResult-1.html",
    "title": "Class CommandResult<T> | wt",
    "summary": "Class CommandResult<T> Namespace Kuju63.WorkTree.CommandLine.Models Assembly wt.dll Represents the result of a command operation using the Result pattern. public class CommandResult<T> Type Parameters T The type of data returned on success. Inheritance object CommandResult<T> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Data public T? Data { get; init; } Property Value T ErrorCode public string? ErrorCode { get; init; } Property Value string ErrorMessage public string? ErrorMessage { get; init; } Property Value string IsSuccess public bool IsSuccess { get; init; } Property Value bool Solution public string? Solution { get; init; } Property Value string Warnings public List<string> Warnings { get; init; } Property Value List<string> Methods Failure(string, string) Creates a failure result with the specified error information. This overload does not accept an explicit solution string. public static CommandResult<T> Failure(string errorCode, string errorMessage) Parameters errorCode string The error code identifying the type of error. errorMessage string A descriptive error message. Returns CommandResult<T> A failed CommandResult<T> containing error details. Failure(string, string, string?) Creates a failure result with the specified error information. public static CommandResult<T> Failure(string errorCode, string errorMessage, string? solution) Parameters errorCode string The error code identifying the type of error. errorMessage string A descriptive error message. solution string An optional solution or suggestion to resolve the error. Returns CommandResult<T> A failed CommandResult<T> containing error details. Success(T) Creates a successful result with the specified data. This overload does not accept explicit warnings. public static CommandResult<T> Success(T data) Parameters data T The data to include in the result. Returns CommandResult<T> A successful CommandResult<T> containing the data. Success(T, List<string>?) Creates a successful result with the specified data. public static CommandResult<T> Success(T data, List<string>? warnings) Parameters data T The data to include in the result. warnings List<string> Optional list of warning messages. Returns CommandResult<T> A successful CommandResult<T> containing the data. SuccessWithWarnings(T, List<string>) Creates a successful result with warning messages. public static CommandResult<T> SuccessWithWarnings(T data, List<string> warnings) Parameters data T The data to include in the result. warnings List<string> A list of warning messages. Returns CommandResult<T> A successful CommandResult<T> containing the data and warnings."
  },
  "api/Kuju63.WorkTree.CommandLine.Models.CreateWorktreeOptions.html": {
    "href": "api/Kuju63.WorkTree.CommandLine.Models.CreateWorktreeOptions.html",
    "title": "Class CreateWorktreeOptions | wt",
    "summary": "Class CreateWorktreeOptions Namespace Kuju63.WorkTree.CommandLine.Models Assembly wt.dll Represents the options for creating a new worktree. public class CreateWorktreeOptions Inheritance object CreateWorktreeOptions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties BaseBranch public string? BaseBranch { get; init; } Property Value string BranchName public required string BranchName { get; init; } Property Value string CheckoutExisting public bool CheckoutExisting { get; init; } Property Value bool EditorType public EditorType? EditorType { get; init; } Property Value EditorType? OutputFormat public OutputFormat OutputFormat { get; init; } Property Value OutputFormat Verbose public bool Verbose { get; init; } Property Value bool WorktreePath public string? WorktreePath { get; init; } Property Value string Methods Validate() Validates the worktree creation options. public ValidationResult Validate() Returns ValidationResult A ValidationResult indicating whether the options are valid."
  },
  "api/Kuju63.WorkTree.CommandLine.Models.EditorConfig.html": {
    "href": "api/Kuju63.WorkTree.CommandLine.Models.EditorConfig.html",
    "title": "Class EditorConfig | wt",
    "summary": "Class EditorConfig Namespace Kuju63.WorkTree.CommandLine.Models Assembly wt.dll Represents the configuration for a code editor. public class EditorConfig Inheritance object EditorConfig Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Arguments Gets or sets the command-line arguments template for the editor. public string Arguments { get; set; } Property Value string Command Gets or sets the command used to launch the editor. public string Command { get; set; } Property Value string EditorType Gets or sets the type of the editor. public EditorType EditorType { get; set; } Property Value EditorType IsAvailable Gets or sets a value indicating whether the editor is available on the system. public bool IsAvailable { get; set; } Property Value bool"
  },
  "api/Kuju63.WorkTree.CommandLine.Models.EditorType.html": {
    "href": "api/Kuju63.WorkTree.CommandLine.Models.EditorType.html",
    "title": "Enum EditorType | wt",
    "summary": "Enum EditorType Namespace Kuju63.WorkTree.CommandLine.Models Assembly wt.dll Specifies the type of code editor. public enum EditorType Fields Emacs = 2 Emacs text editor. IntelliJIDEA = 4 IntelliJ IDEA integrated development environment. Nano = 3 Nano text editor. VSCode = 0 Visual Studio Code editor. Vim = 1 Vim text editor."
  },
  "api/Kuju63.WorkTree.CommandLine.Models.ErrorCodes.html": {
    "href": "api/Kuju63.WorkTree.CommandLine.Models.ErrorCodes.html",
    "title": "Class ErrorCodes | wt",
    "summary": "Class ErrorCodes Namespace Kuju63.WorkTree.CommandLine.Models Assembly wt.dll Defines error codes used throughout the application. public static class ErrorCodes Inheritance object ErrorCodes Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BranchAlreadyExists public const string BranchAlreadyExists = \"BR002\" Field Value string BranchAlreadyInUse public const string BranchAlreadyInUse = \"BR003\" Field Value string DiskSpaceLow public const string DiskSpaceLow = \"FS003\" Field Value string EditorNotFound public const string EditorNotFound = \"ED001\" Field Value string GitCommandFailed public const string GitCommandFailed = \"GIT003\" Field Value string GitNotFound public const string GitNotFound = \"GIT001\" Field Value string InvalidBranchName public const string InvalidBranchName = \"BR001\" Field Value string InvalidPath public const string InvalidPath = \"FS001\" Field Value string NotGitRepository public const string NotGitRepository = \"GIT002\" Field Value string PathNotWritable public const string PathNotWritable = \"FS002\" Field Value string WorktreeAlreadyExists public const string WorktreeAlreadyExists = \"WT001\" Field Value string WorktreeCreationFailed public const string WorktreeCreationFailed = \"WT002\" Field Value string Methods GetSolution(string) Gets a solution message for the specified error code. public static string GetSolution(string errorCode) Parameters errorCode string The error code to get the solution for. Returns string A string containing the recommended solution for the error."
  },
  "api/Kuju63.WorkTree.CommandLine.Models.OutputFormat.html": {
    "href": "api/Kuju63.WorkTree.CommandLine.Models.OutputFormat.html",
    "title": "Enum OutputFormat | wt",
    "summary": "Enum OutputFormat Namespace Kuju63.WorkTree.CommandLine.Models Assembly wt.dll Specifies the output format for command results. public enum OutputFormat Fields Human = 0 Human-readable text format. Json = 1 JSON format for machine parsing."
  },
  "api/Kuju63.WorkTree.CommandLine.Models.WorktreeInfo.html": {
    "href": "api/Kuju63.WorkTree.CommandLine.Models.WorktreeInfo.html",
    "title": "Class WorktreeInfo | wt",
    "summary": "Class WorktreeInfo Namespace Kuju63.WorkTree.CommandLine.Models Assembly wt.dll Represents information about a Git worktree. public record WorktreeInfo : IEquatable<WorktreeInfo> Inheritance object WorktreeInfo Implements IEquatable<WorktreeInfo> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors WorktreeInfo(string, string, bool, string, DateTime, bool) Represents information about a Git worktree. public WorktreeInfo(string Path, string Branch, bool IsDetached, string CommitHash, DateTime CreatedAt, bool Exists) Parameters Path string The file system path of the worktree. Branch string The branch name associated with this worktree. IsDetached bool Indicates whether the worktree is in a detached HEAD state. CommitHash string The full commit hash of the current HEAD. CreatedAt DateTime The date and time when the worktree was created. Exists bool Indicates whether the worktree exists on the filesystem. Properties Branch The branch name associated with this worktree. public string Branch { get; init; } Property Value string CommitHash The full commit hash of the current HEAD. public string CommitHash { get; init; } Property Value string CreatedAt The date and time when the worktree was created. public DateTime CreatedAt { get; init; } Property Value DateTime Exists Indicates whether the worktree exists on the filesystem. public bool Exists { get; init; } Property Value bool IsDetached Indicates whether the worktree is in a detached HEAD state. public bool IsDetached { get; init; } Property Value bool Path The file system path of the worktree. public string Path { get; init; } Property Value string Methods GetDisplayBranch() Gets a display-friendly branch string. public string GetDisplayBranch() Returns string For normal branches: the branch name. For detached HEAD: \"abc1234 (detached)\" format. GetDisplayStatus() Gets a display-friendly status string. public string GetDisplayStatus() Returns string \"active\" if the worktree exists on disk. \"missing\" if the worktree does not exist on disk."
  },
  "api/Kuju63.WorkTree.CommandLine.Models.html": {
    "href": "api/Kuju63.WorkTree.CommandLine.Models.html",
    "title": "Namespace Kuju63.WorkTree.CommandLine.Models | wt",
    "summary": "Namespace Kuju63.WorkTree.CommandLine.Models Classes BranchInfo Represents information about a Git branch. CommandResult<T> Represents the result of a command operation using the Result pattern. CreateWorktreeOptions Represents the options for creating a new worktree. EditorConfig Represents the configuration for a code editor. ErrorCodes Defines error codes used throughout the application. WorktreeInfo Represents information about a Git worktree. Enums EditorType Specifies the type of code editor. OutputFormat Specifies the output format for command results."
  },
  "api/Kuju63.WorkTree.CommandLine.Services.Editor.EditorPresets.html": {
    "href": "api/Kuju63.WorkTree.CommandLine.Services.Editor.EditorPresets.html",
    "title": "Class EditorPresets | wt",
    "summary": "Class EditorPresets Namespace Kuju63.WorkTree.CommandLine.Services.Editor Assembly wt.dll Provides preset configurations for known code editors. public static class EditorPresets Inheritance object EditorPresets Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields KnownEditors Gets a dictionary of known editor configurations mapped by editor type. public static readonly Dictionary<EditorType, EditorConfig> KnownEditors Field Value Dictionary<EditorType, EditorConfig>"
  },
  "api/Kuju63.WorkTree.CommandLine.Services.Editor.EditorService.html": {
    "href": "api/Kuju63.WorkTree.CommandLine.Services.Editor.EditorService.html",
    "title": "Class EditorService | wt",
    "summary": "Class EditorService Namespace Kuju63.WorkTree.CommandLine.Services.Editor Assembly wt.dll Provides functionality for launching and managing code editors. public class EditorService : IEditorService Inheritance object EditorService Implements IEditorService Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors EditorService(IProcessRunner) public EditorService(IProcessRunner processRunner) Parameters processRunner IProcessRunner Methods LaunchEditorAsync(string, EditorType) Launches the specified editor with the given path. This overload does not accept a cancellation token. public Task<CommandResult<string>> LaunchEditorAsync(string path, EditorType editorType) Parameters path string The path to open in the editor. editorType EditorType The type of editor to launch. Returns Task<CommandResult<string>> A CommandResult<string> containing the result of the launch operation. LaunchEditorAsync(string, EditorType, CancellationToken) Initializes a new instance of EditorService. public Task<CommandResult<string>> LaunchEditorAsync(string path, EditorType editorType, CancellationToken cancellationToken) Parameters path string editorType EditorType cancellationToken CancellationToken Returns Task<CommandResult<string>> ResolveEditorCommand(EditorType) Resolves the editor command configuration for the specified editor type. public EditorConfig ResolveEditorCommand(EditorType editorType) Parameters editorType EditorType The type of editor to resolve. Returns EditorConfig The EditorConfig for the specified editor type."
  },
  "api/Kuju63.WorkTree.CommandLine.Services.Editor.IEditorService.html": {
    "href": "api/Kuju63.WorkTree.CommandLine.Services.Editor.IEditorService.html",
    "title": "Interface IEditorService | wt",
    "summary": "Interface IEditorService Namespace Kuju63.WorkTree.CommandLine.Services.Editor Assembly wt.dll Defines methods for launching and managing code editors. public interface IEditorService Methods LaunchEditorAsync(string, EditorType) Launches the specified editor with the given path asynchronously. Task<CommandResult<string>> LaunchEditorAsync(string path, EditorType editorType) Parameters path string The path to open in the editor. editorType EditorType The type of editor to launch. Returns Task<CommandResult<string>> A CommandResult<T> containing the result of the launch operation. LaunchEditorAsync(string, EditorType, CancellationToken) Launches the specified editor with the given path asynchronously. Task<CommandResult<string>> LaunchEditorAsync(string path, EditorType editorType, CancellationToken cancellationToken) Parameters path string The path to open in the editor. editorType EditorType The type of editor to launch. cancellationToken CancellationToken A cancellation token to cancel the operation. Returns Task<CommandResult<string>> A CommandResult<T> containing the result of the launch operation. ResolveEditorCommand(EditorType) Resolves the editor command configuration for the specified editor type. EditorConfig ResolveEditorCommand(EditorType editorType) Parameters editorType EditorType The type of editor to resolve. Returns EditorConfig The EditorConfig for the specified editor type."
  },
  "api/Kuju63.WorkTree.CommandLine.Services.Editor.html": {
    "href": "api/Kuju63.WorkTree.CommandLine.Services.Editor.html",
    "title": "Namespace Kuju63.WorkTree.CommandLine.Services.Editor | wt",
    "summary": "Namespace Kuju63.WorkTree.CommandLine.Services.Editor Classes EditorPresets Provides preset configurations for known code editors. EditorService Provides functionality for launching and managing code editors. Interfaces IEditorService Defines methods for launching and managing code editors."
  },
  "api/Kuju63.WorkTree.CommandLine.Services.Git.GitService.html": {
    "href": "api/Kuju63.WorkTree.CommandLine.Services.Git.GitService.html",
    "title": "Class GitService | wt",
    "summary": "Class GitService Namespace Kuju63.WorkTree.CommandLine.Services.Git Assembly wt.dll Provides functionality for interacting with Git repositories. public class GitService : IGitService Inheritance object GitService Implements IGitService Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors GitService(IProcessRunner) public GitService(IProcessRunner processRunner) Parameters processRunner IProcessRunner Methods AddWorktreeAsync(string, string) Adds a new worktree at the specified path asynchronously. This overload does not accept a cancellation token. public Task<CommandResult<bool>> AddWorktreeAsync(string path, string branchName) Parameters path string The path where the worktree should be created. branchName string The branch to checkout in the new worktree. Returns Task<CommandResult<bool>> A CommandResult<bool> containing true if the worktree was added successfully; otherwise, false. AddWorktreeAsync(string, string, CancellationToken) Adds a new worktree at the specified path asynchronously. public Task<CommandResult<bool>> AddWorktreeAsync(string path, string branchName, CancellationToken cancellationToken) Parameters path string The path where the worktree should be created. branchName string The branch to checkout in the new worktree. cancellationToken CancellationToken A cancellation token to cancel the operation. Returns Task<CommandResult<bool>> A CommandResult<bool> containing true if the worktree was added successfully; otherwise, false. BranchExistsAsync(string) Checks whether a branch exists (local or remote) asynchronously. This overload does not accept a cancellation token. public Task<CommandResult<bool>> BranchExistsAsync(string branchName) Parameters branchName string The name of the branch to check. Returns Task<CommandResult<bool>> A CommandResult<bool> containing true if the branch exists; otherwise, false. BranchExistsAsync(string, CancellationToken) Checks whether a branch exists (local or remote) asynchronously. public Task<CommandResult<bool>> BranchExistsAsync(string branchName, CancellationToken cancellationToken) Parameters branchName string The name of the branch to check. cancellationToken CancellationToken A cancellation token to cancel the operation. Returns Task<CommandResult<bool>> A CommandResult<bool> containing true if the branch exists; otherwise, false. CreateBranchAsync(string, string) Creates a new branch from a base branch asynchronously. This overload does not accept a cancellation token. public Task<CommandResult<BranchInfo>> CreateBranchAsync(string branchName, string baseBranch) Parameters branchName string The name of the branch to create. baseBranch string The base branch to branch from. Returns Task<CommandResult<BranchInfo>> A CommandResult<T> containing information about the created branch. CreateBranchAsync(string, string, CancellationToken) Creates a new branch from a base branch asynchronously. public Task<CommandResult<BranchInfo>> CreateBranchAsync(string branchName, string baseBranch, CancellationToken cancellationToken) Parameters branchName string The name of the branch to create. baseBranch string The base branch to branch from. cancellationToken CancellationToken A cancellation token to cancel the operation. Returns Task<CommandResult<BranchInfo>> A CommandResult<T> containing information about the created branch. GetCurrentBranchAsync() Gets the name of the current branch asynchronously. This overload does not accept a cancellation token. public Task<CommandResult<string>> GetCurrentBranchAsync() Returns Task<CommandResult<string>> A CommandResult<string> containing the current branch name. GetCurrentBranchAsync(CancellationToken) Gets the name of the current branch asynchronously. public Task<CommandResult<string>> GetCurrentBranchAsync(CancellationToken cancellationToken) Parameters cancellationToken CancellationToken A cancellation token to cancel the operation. Returns Task<CommandResult<string>> A CommandResult<string> containing the current branch name. IsGitRepositoryAsync() Checks whether the current directory is a Git repository asynchronously. This overload does not accept a cancellation token. public Task<CommandResult<bool>> IsGitRepositoryAsync() Returns Task<CommandResult<bool>> A CommandResult<bool> containing true if in a Git repository; otherwise, false. IsGitRepositoryAsync(CancellationToken) Checks whether the current directory is a Git repository asynchronously. public Task<CommandResult<bool>> IsGitRepositoryAsync(CancellationToken cancellationToken) Parameters cancellationToken CancellationToken A cancellation token to cancel the operation. Returns Task<CommandResult<bool>> A CommandResult<bool> containing true if in a Git repository; otherwise, false. ListWorktreesAsync() Lists all worktrees in the repository asynchronously. This overload does not accept a cancellation token. public Task<CommandResult<List<WorktreeInfo>>> ListWorktreesAsync() Returns Task<CommandResult<List<WorktreeInfo>>> A CommandResult<T> containing a list of worktree information. ListWorktreesAsync(CancellationToken) Lists all worktrees in the repository asynchronously. public Task<CommandResult<List<WorktreeInfo>>> ListWorktreesAsync(CancellationToken cancellationToken) Parameters cancellationToken CancellationToken A cancellation token to cancel the operation. Returns Task<CommandResult<List<WorktreeInfo>>> A CommandResult<T> containing a list of worktree information."
  },
  "api/Kuju63.WorkTree.CommandLine.Services.Git.IGitService.html": {
    "href": "api/Kuju63.WorkTree.CommandLine.Services.Git.IGitService.html",
    "title": "Interface IGitService | wt",
    "summary": "Interface IGitService Namespace Kuju63.WorkTree.CommandLine.Services.Git Assembly wt.dll Defines methods for interacting with Git repositories. public interface IGitService Methods AddWorktreeAsync(string, string) Adds a new worktree at the specified path asynchronously. Task<CommandResult<bool>> AddWorktreeAsync(string path, string branchName) Parameters path string The path where the worktree should be created. branchName string The branch to checkout in the new worktree. Returns Task<CommandResult<bool>> A CommandResult<T> containing true if the worktree was added successfully; otherwise, false. AddWorktreeAsync(string, string, CancellationToken) Adds a new worktree at the specified path asynchronously. Task<CommandResult<bool>> AddWorktreeAsync(string path, string branchName, CancellationToken cancellationToken) Parameters path string The path where the worktree should be created. branchName string The branch to checkout in the new worktree. cancellationToken CancellationToken A cancellation token to cancel the operation. Returns Task<CommandResult<bool>> A CommandResult<bool> containing true if the worktree was added successfully; otherwise, false. BranchExistsAsync(string) Checks whether a branch exists (local or remote) asynchronously. Task<CommandResult<bool>> BranchExistsAsync(string branchName) Parameters branchName string The name of the branch to check. Returns Task<CommandResult<bool>> A CommandResult<T> containing true if the branch exists; otherwise, false. BranchExistsAsync(string, CancellationToken) Checks whether a branch exists (local or remote) asynchronously. Task<CommandResult<bool>> BranchExistsAsync(string branchName, CancellationToken cancellationToken) Parameters branchName string The name of the branch to check. cancellationToken CancellationToken A cancellation token to cancel the operation. Returns Task<CommandResult<bool>> A CommandResult<bool> containing true if the branch exists; otherwise, false. CreateBranchAsync(string, string) Creates a new branch from a base branch asynchronously. Task<CommandResult<BranchInfo>> CreateBranchAsync(string branchName, string baseBranch) Parameters branchName string The name of the branch to create. baseBranch string The base branch to branch from. Returns Task<CommandResult<BranchInfo>> A CommandResult<T> containing information about the created branch. CreateBranchAsync(string, string, CancellationToken) Creates a new branch from a base branch asynchronously. Task<CommandResult<BranchInfo>> CreateBranchAsync(string branchName, string baseBranch, CancellationToken cancellationToken) Parameters branchName string The name of the branch to create. baseBranch string The base branch to branch from. cancellationToken CancellationToken A cancellation token to cancel the operation. Returns Task<CommandResult<BranchInfo>> A CommandResult<T> containing information about the created branch. GetCurrentBranchAsync() Gets the name of the current branch asynchronously. Task<CommandResult<string>> GetCurrentBranchAsync() Returns Task<CommandResult<string>> A CommandResult<T> containing the current branch name. GetCurrentBranchAsync(CancellationToken) Gets the name of the current branch asynchronously. Task<CommandResult<string>> GetCurrentBranchAsync(CancellationToken cancellationToken) Parameters cancellationToken CancellationToken A cancellation token to cancel the operation. Returns Task<CommandResult<string>> A CommandResult<string> containing the current branch name. IsGitRepositoryAsync() Checks whether the current directory is a Git repository asynchronously. Task<CommandResult<bool>> IsGitRepositoryAsync() Returns Task<CommandResult<bool>> A CommandResult<T> containing true if in a Git repository; otherwise, false. IsGitRepositoryAsync(CancellationToken) Checks whether the current directory is a Git repository asynchronously. Task<CommandResult<bool>> IsGitRepositoryAsync(CancellationToken cancellationToken) Parameters cancellationToken CancellationToken A cancellation token to cancel the operation. Returns Task<CommandResult<bool>> A CommandResult<bool> containing true if in a Git repository; otherwise, false. ListWorktreesAsync() Lists all worktrees in the repository asynchronously. Task<CommandResult<List<WorktreeInfo>>> ListWorktreesAsync() Returns Task<CommandResult<List<WorktreeInfo>>> A CommandResult<T> containing a list of worktree information. ListWorktreesAsync(CancellationToken) Lists all worktrees in the repository asynchronously. Task<CommandResult<List<WorktreeInfo>>> ListWorktreesAsync(CancellationToken cancellationToken) Parameters cancellationToken CancellationToken A cancellation token to cancel the operation. Returns Task<CommandResult<List<WorktreeInfo>>> A CommandResult<T> containing a list of worktree information."
  },
  "api/Kuju63.WorkTree.CommandLine.Services.Git.html": {
    "href": "api/Kuju63.WorkTree.CommandLine.Services.Git.html",
    "title": "Namespace Kuju63.WorkTree.CommandLine.Services.Git | wt",
    "summary": "Namespace Kuju63.WorkTree.CommandLine.Services.Git Classes GitService Provides functionality for interacting with Git repositories. Interfaces IGitService Defines methods for interacting with Git repositories."
  },
  "api/Kuju63.WorkTree.CommandLine.Services.Worktree.IWorktreeService.html": {
    "href": "api/Kuju63.WorkTree.CommandLine.Services.Worktree.IWorktreeService.html",
    "title": "Interface IWorktreeService | wt",
    "summary": "Interface IWorktreeService Namespace Kuju63.WorkTree.CommandLine.Services.Worktree Assembly wt.dll Defines methods for creating and managing Git worktrees. public interface IWorktreeService Methods CreateWorktreeAsync(CreateWorktreeOptions) Creates a new worktree with the specified options asynchronously. Task<CommandResult<WorktreeInfo>> CreateWorktreeAsync(CreateWorktreeOptions options) Parameters options CreateWorktreeOptions The options for creating the worktree. Returns Task<CommandResult<WorktreeInfo>> A CommandResult<T> containing the created worktree information. CreateWorktreeAsync(CreateWorktreeOptions, CancellationToken) Creates a new worktree with the specified options asynchronously. Task<CommandResult<WorktreeInfo>> CreateWorktreeAsync(CreateWorktreeOptions options, CancellationToken cancellationToken) Parameters options CreateWorktreeOptions The options for creating the worktree. cancellationToken CancellationToken A cancellation token to cancel the operation. Returns Task<CommandResult<WorktreeInfo>> A CommandResult<T> containing the created worktree information. ListWorktreesAsync() Lists all worktrees in the repository asynchronously. Task<CommandResult<List<WorktreeInfo>>> ListWorktreesAsync() Returns Task<CommandResult<List<WorktreeInfo>>> A CommandResult<T> containing a list of worktree information, sorted by creation date (newest first). ListWorktreesAsync(CancellationToken) Lists all worktrees in the repository asynchronously. Task<CommandResult<List<WorktreeInfo>>> ListWorktreesAsync(CancellationToken cancellationToken) Parameters cancellationToken CancellationToken A cancellation token to cancel the operation. Returns Task<CommandResult<List<WorktreeInfo>>> A CommandResult<T> containing a list of worktree information, sorted by creation date (newest first)."
  },
  "api/Kuju63.WorkTree.CommandLine.Services.Worktree.WorktreeService.html": {
    "href": "api/Kuju63.WorkTree.CommandLine.Services.Worktree.WorktreeService.html",
    "title": "Class WorktreeService | wt",
    "summary": "Class WorktreeService Namespace Kuju63.WorkTree.CommandLine.Services.Worktree Assembly wt.dll Provides functionality for creating and managing Git worktrees. public class WorktreeService : IWorktreeService Inheritance object WorktreeService Implements IWorktreeService Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors WorktreeService(IGitService, IPathHelper) Initializes a new instance of WorktreeService without an IEditorService. public WorktreeService(IGitService gitService, IPathHelper pathHelper) Parameters gitService IGitService The IGitService instance. pathHelper IPathHelper The IPathHelper instance. WorktreeService(IGitService, IPathHelper, IEditorService?) public WorktreeService(IGitService gitService, IPathHelper pathHelper, IEditorService? editorService) Parameters gitService IGitService pathHelper IPathHelper editorService IEditorService Methods CreateWorktreeAsync(CreateWorktreeOptions) Creates a new worktree with the specified options. This overload does not accept a cancellation token. public Task<CommandResult<WorktreeInfo>> CreateWorktreeAsync(CreateWorktreeOptions options) Parameters options CreateWorktreeOptions The options for creating the worktree. Returns Task<CommandResult<WorktreeInfo>> A CommandResult<T> representing the result. CreateWorktreeAsync(CreateWorktreeOptions, CancellationToken) Creates a new worktree with the specified options asynchronously. public Task<CommandResult<WorktreeInfo>> CreateWorktreeAsync(CreateWorktreeOptions options, CancellationToken cancellationToken) Parameters options CreateWorktreeOptions The options for creating the worktree. cancellationToken CancellationToken A cancellation token to cancel the operation. Returns Task<CommandResult<WorktreeInfo>> A CommandResult<T> representing the result. ListWorktreesAsync() Lists all worktrees in the repository. This overload does not accept a cancellation token. public Task<CommandResult<List<WorktreeInfo>>> ListWorktreesAsync() Returns Task<CommandResult<List<WorktreeInfo>>> A CommandResult<T> containing a list of worktree information, sorted by creation date (newest first). ListWorktreesAsync(CancellationToken) Lists all worktrees in the repository asynchronously. public Task<CommandResult<List<WorktreeInfo>>> ListWorktreesAsync(CancellationToken cancellationToken) Parameters cancellationToken CancellationToken A cancellation token to cancel the operation. Returns Task<CommandResult<List<WorktreeInfo>>> A CommandResult<T> containing a list of worktree information, sorted by creation date (newest first)."
  },
  "api/Kuju63.WorkTree.CommandLine.Services.Worktree.html": {
    "href": "api/Kuju63.WorkTree.CommandLine.Services.Worktree.html",
    "title": "Namespace Kuju63.WorkTree.CommandLine.Services.Worktree | wt",
    "summary": "Namespace Kuju63.WorkTree.CommandLine.Services.Worktree Classes WorktreeService Provides functionality for creating and managing Git worktrees. Interfaces IWorktreeService Defines methods for creating and managing Git worktrees."
  },
  "api/Kuju63.WorkTree.CommandLine.Utils.IPathHelper.html": {
    "href": "api/Kuju63.WorkTree.CommandLine.Utils.IPathHelper.html",
    "title": "Interface IPathHelper | wt",
    "summary": "Interface IPathHelper Namespace Kuju63.WorkTree.CommandLine.Utils Assembly wt.dll public interface IPathHelper Methods EnsureParentDirectoryExists(string) Ensure parent directory exists void EnsureParentDirectoryExists(string filePath) Parameters filePath string HasWritePermission(string) Check if directory has write permission bool HasWritePermission(string directory) Parameters directory string Returns bool NormalizePath(string) Normalize a path (unify separators) string NormalizePath(string path) Parameters path string Returns string ResolvePath(string, string) Resolve a path (convert relative to absolute) string ResolvePath(string path, string basePath) Parameters path string basePath string Returns string ValidatePath(string) Validate a path PathValidationResult ValidatePath(string path) Parameters path string Returns PathValidationResult"
  },
  "api/Kuju63.WorkTree.CommandLine.Utils.IProcessRunner.html": {
    "href": "api/Kuju63.WorkTree.CommandLine.Utils.IProcessRunner.html",
    "title": "Interface IProcessRunner | wt",
    "summary": "Interface IProcessRunner Namespace Kuju63.WorkTree.CommandLine.Utils Assembly wt.dll public interface IProcessRunner Methods RunAsync(string, string) Run a process asynchronously. This overload does not accept a working directory or cancellation token. Task<ProcessResult> RunAsync(string fileName, string arguments) Parameters fileName string The executable or command name to run. arguments string The command line arguments. Returns Task<ProcessResult> A ProcessResult containing the process exit code and output. RunAsync(string, string, string?) Run a process asynchronously with a specified working directory. This overload does not accept a cancellation token. Task<ProcessResult> RunAsync(string fileName, string arguments, string? workingDirectory) Parameters fileName string The executable or command name to run. arguments string The command line arguments. workingDirectory string The working directory for the process. Returns Task<ProcessResult> A ProcessResult containing the process exit code and output. RunAsync(string, string, string?, CancellationToken) Run a process asynchronously with a specified working directory and cancellation token. Task<ProcessResult> RunAsync(string fileName, string arguments, string? workingDirectory, CancellationToken cancellationToken) Parameters fileName string The executable or command name to run. arguments string The command line arguments. workingDirectory string The working directory for the process. cancellationToken CancellationToken A cancellation token to cancel the operation. Returns Task<ProcessResult> A ProcessResult containing the process exit code and output."
  },
  "api/Kuju63.WorkTree.CommandLine.Utils.PathHelper.html": {
    "href": "api/Kuju63.WorkTree.CommandLine.Utils.PathHelper.html",
    "title": "Class PathHelper | wt",
    "summary": "Class PathHelper Namespace Kuju63.WorkTree.CommandLine.Utils Assembly wt.dll Provides helper methods for path operations and validation. public class PathHelper : IPathHelper Inheritance object PathHelper Implements IPathHelper Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PathHelper(IFileSystem) public PathHelper(IFileSystem fileSystem) Parameters fileSystem IFileSystem Methods EnsureParentDirectoryExists(string) Ensures the parent directory of the specified file path exists, creating it if necessary. public void EnsureParentDirectoryExists(string filePath) Parameters filePath string The file path whose parent directory should be ensured. HasWritePermission(string) Determines whether the current user has write permission to the specified directory. public bool HasWritePermission(string directory) Parameters directory string The directory to check for write permission. Returns bool true if the directory has write permission; otherwise, false. NormalizePath(string) Normalizes a path by unifying directory separators. public string NormalizePath(string path) Parameters path string The path to normalize. Returns string The normalized path with forward slashes as directory separators. ResolvePath(string, string) Resolves a path by converting relative paths to absolute paths. public string ResolvePath(string path, string basePath) Parameters path string The path to resolve. basePath string The base path to use for relative path resolution. Returns string The fully resolved absolute path. ValidatePath(string) Validates a path for correctness and availability. public PathValidationResult ValidatePath(string path) Parameters path string The path to validate. Returns PathValidationResult A PathValidationResult indicating whether the path is valid."
  },
  "api/Kuju63.WorkTree.CommandLine.Utils.PathValidationResult.html": {
    "href": "api/Kuju63.WorkTree.CommandLine.Utils.PathValidationResult.html",
    "title": "Class PathValidationResult | wt",
    "summary": "Class PathValidationResult Namespace Kuju63.WorkTree.CommandLine.Utils Assembly wt.dll Represents the result of a path validation operation. public record PathValidationResult : IEquatable<PathValidationResult> Inheritance object PathValidationResult Implements IEquatable<PathValidationResult> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PathValidationResult(bool, string?) Represents the result of a path validation operation. public PathValidationResult(bool IsValid, string? ErrorMessage = null) Parameters IsValid bool ErrorMessage string Properties ErrorMessage public string? ErrorMessage { get; init; } Property Value string IsValid public bool IsValid { get; init; } Property Value bool"
  },
  "api/Kuju63.WorkTree.CommandLine.Utils.ProcessResult.html": {
    "href": "api/Kuju63.WorkTree.CommandLine.Utils.ProcessResult.html",
    "title": "Class ProcessResult | wt",
    "summary": "Class ProcessResult Namespace Kuju63.WorkTree.CommandLine.Utils Assembly wt.dll Represents the result of a process execution. public record ProcessResult : IEquatable<ProcessResult> Inheritance object ProcessResult Implements IEquatable<ProcessResult> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ProcessResult(int, string, string) Represents the result of a process execution. public ProcessResult(int ExitCode, string StandardOutput, string StandardError) Parameters ExitCode int StandardOutput string StandardError string Properties ExitCode public int ExitCode { get; init; } Property Value int StandardError public string StandardError { get; init; } Property Value string StandardOutput public string StandardOutput { get; init; } Property Value string"
  },
  "api/Kuju63.WorkTree.CommandLine.Utils.ProcessRunner.html": {
    "href": "api/Kuju63.WorkTree.CommandLine.Utils.ProcessRunner.html",
    "title": "Class ProcessRunner | wt",
    "summary": "Class ProcessRunner Namespace Kuju63.WorkTree.CommandLine.Utils Assembly wt.dll Provides functionality for running external processes. public class ProcessRunner : IProcessRunner Inheritance object ProcessRunner Implements IProcessRunner Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods RunAsync(string, string) Runs an external process asynchronously with the specified command and arguments. public Task<ProcessResult> RunAsync(string command, string arguments) Parameters command string The command or executable to run. arguments string The arguments to pass to the command. Returns Task<ProcessResult> A ProcessResult containing the exit code and output from the process. RunAsync(string, string, string?) Runs an external process asynchronously with a specified working directory. This overload does not accept a cancellation token. public Task<ProcessResult> RunAsync(string command, string arguments, string? workingDirectory) Parameters command string The command or executable to run. arguments string The arguments to pass to the command. workingDirectory string The working directory for the process. If null, uses the current directory. Returns Task<ProcessResult> A ProcessResult containing the exit code and output. RunAsync(string, string, string?, CancellationToken) Run a process asynchronously with a specified working directory and cancellation token. public Task<ProcessResult> RunAsync(string command, string arguments, string? workingDirectory, CancellationToken cancellationToken) Parameters command string arguments string The command line arguments. workingDirectory string The working directory for the process. cancellationToken CancellationToken A cancellation token to cancel the operation. Returns Task<ProcessResult> A ProcessResult containing the process exit code and output."
  },
  "api/Kuju63.WorkTree.CommandLine.Utils.ValidationResult.html": {
    "href": "api/Kuju63.WorkTree.CommandLine.Utils.ValidationResult.html",
    "title": "Class ValidationResult | wt",
    "summary": "Class ValidationResult Namespace Kuju63.WorkTree.CommandLine.Utils Assembly wt.dll Represents the result of a validation operation. public record ValidationResult : IEquatable<ValidationResult> Inheritance object ValidationResult Implements IEquatable<ValidationResult> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ValidationResult(bool, string?) Represents the result of a validation operation. public ValidationResult(bool IsValid, string? ErrorMessage = null) Parameters IsValid bool ErrorMessage string Properties ErrorMessage public string? ErrorMessage { get; init; } Property Value string IsValid public bool IsValid { get; init; } Property Value bool"
  },
  "api/Kuju63.WorkTree.CommandLine.Utils.Validators.html": {
    "href": "api/Kuju63.WorkTree.CommandLine.Utils.Validators.html",
    "title": "Class Validators | wt",
    "summary": "Class Validators Namespace Kuju63.WorkTree.CommandLine.Utils Assembly wt.dll Provides validation helper methods for various input types. public static class Validators Inheritance object Validators Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods SanitizeBranchName(string) Sanitizes a branch name by trimming leading and trailing whitespace. public static string SanitizeBranchName(string branchName) Parameters branchName string The branch name to sanitize. Returns string The sanitized branch name with leading and trailing whitespace removed. ValidateBranchName(string) Validates a branch name according to Git naming conventions. public static ValidationResult ValidateBranchName(string branchName) Parameters branchName string The branch name to validate. Returns ValidationResult A ValidationResult indicating whether the branch name is valid."
  },
  "api/Kuju63.WorkTree.CommandLine.Utils.html": {
    "href": "api/Kuju63.WorkTree.CommandLine.Utils.html",
    "title": "Namespace Kuju63.WorkTree.CommandLine.Utils | wt",
    "summary": "Namespace Kuju63.WorkTree.CommandLine.Utils Classes PathHelper Provides helper methods for path operations and validation. PathValidationResult Represents the result of a path validation operation. ProcessResult Represents the result of a process execution. ProcessRunner Provides functionality for running external processes. ValidationResult Represents the result of a validation operation. Validators Provides validation helper methods for various input types. Interfaces IPathHelper IProcessRunner"
  },
  "docs/adr/0001-record-clean-secure-requirements.html": {
    "href": "docs/adr/0001-record-clean-secure-requirements.html",
    "title": "ADR 0001: Add Clean & Secure Code requirements to Constitution | wt",
    "summary": "ADR 0001: Add Clean & Secure Code requirements to Constitution Status: Accepted Date: 2026-01-03 Context レビューおよび自動解析ツール（例: SonarC#, Lizard, markdownlint）で検出されるセキュリティ/品質指摘に対して、一貫した運用ルールが必要となった。特に空の catch ブロックや汎用例外の無条件捕捉、外部入力の未検証、秘密情報のハードコード等はセキュリティ・保守性の観点からリスクが高い。 Decision constitution.md の「III. Clean & Secure Code (クリーンでセキュアなコード)」セクションに、以下の要件を追加する決定を行う。 例外の扱い: 空の catch { } を禁止し、無視する場合は理由をコメントで明記しログに記録すること。 特定例外の捕捉: 汎用的な Exception の丸抱え捕捉を避けること。 入力検証: 外部入力は常に検証・正規化を行うこと。 秘密情報の管理: シークレットマネージャ等の利用を義務化すること。 最小権限の原則: 実行コンテキストは最小権限で構成すること。 依存関係の脆弱性対応: 重大/高リスクは72時間以内に対応計画を提示すること。 重大セキュリティ問題の優先対応: High/Critical はマージ前に解決するか審査で許可を得ること。 これらはガイドラインとし、例外は ADR に理由を記録して承認すること。 Consequences コードレビューと CI における静的解析の重要度が高まるため、レビュープロセスが若干厳格化する。 一部既存コードは修正（例: 空の catch へのコメント追加、例外の具体化、入力検証追加）が必要となる。 依存関係管理・セキュリティ対応のフロー整備が必要になる（自動スキャン、通知、対応トラッキング）。 Alternatives Considered 何もしない: リスクが残るため却下。 すべての警告を blocker として強制する: 過剰負荷となるため段階的運用を採用。 Authors Jun Kurihara lh182051+src@gmail.com"
  },
  "docs/adr/0002-sbom-format-and-signature-choice.html": {
    "href": "docs/adr/0002-sbom-format-and-signature-choice.html",
    "title": "ADR 0002: SBOM Format and Digital Signature Choice | wt",
    "summary": "ADR 0002: SBOM Format and Digital Signature Choice Status: Accepted Date: 2026-01-05 Context: Feature 003 - Automated Binary Release Pipeline Related: spec.md, research.md Context To ensure software supply chain security and transparency, we need to: Generate Software Bill of Materials (SBOM) for all releases Provide digital signatures for critical artifacts (SBOM and checksums) Enable users to verify the integrity and authenticity of downloaded binaries This decision records our choices for SBOM format and signature mechanism. Decision SBOM Format: CycloneDX 1.4 (JSON) We will use CycloneDX 1.4 in JSON format for all SBOM generation. Tool: anchore/sbom-action GitHub Action Rationale: Industry Standard: CycloneDX is widely adopted and supported by security tools (Dependency-Track, OWASP, etc.) Comprehensive: Captures dependencies, licenses, vulnerabilities, and component relationships Machine-Readable: JSON format is easy to parse and integrate with automated tools GitHub Actions Integration: anchore/sbom-action provides seamless integration with minimal configuration Multi-Language Support: Supports .NET, Go, Python, Java, JavaScript, and more Security: Using pinned commit SHA (61119d458adab75f756bc0b9e4bde25725f86a7a) prevents supply chain attacks Maintainability: Reduces custom script complexity (50+ lines reduced to 4 lines of YAML) Alternative Considered: SPDX 2.3 Pros: SPDX is also widely adopted, supported by Linux Foundation Cons: Less comprehensive for vulnerability tracking compared to CycloneDX; JSON tooling less mature Digital Signature: GPG (GNU Privacy Guard) We will use GPG with RSA 4096-bit keys to sign SBOM and SHA256SUMS files. Implementation: .github/scripts/sign-artifacts.sh Signed Artifacts: wt-v<version>-sbom.json.asc (SBOM signature) SHA256SUMS.asc (Checksum file signature) Rationale: Ubiquitous: GPG is available on all platforms (Windows, Linux, macOS) and widely understood Trust Model: Supports web-of-trust and key verification through public key servers GitHub Integration: GitHub Actions supports GPG signing via secrets Standard: Used by major open-source projects (Debian, Fedora, Apache Foundation) Free: No external service fees (unlike commercial certificate authorities) Scriptable: Easy to automate in CI/CD pipelines Alternative Considered: Sigstore/Cosign Pros: Modern, keyless signing, integrated with OIDC, supports container images Cons: Requires external Sigstore infrastructure; less familiar to developers; primarily container-focused Alternative Considered: GitHub Actions Attestations Pros: Native GitHub integration, no key management needed Cons: Verification requires GitHub CLI or API; not widely adopted outside GitHub ecosystem Consequences Positive Transparency: Users can verify all dependencies in the binary Security: Digital signatures prevent tampering and ensure authenticity Automation: SBOM generation is fully automated via GitHub Actions Compliance: Meets NTIA minimum elements for SBOM requirements Trust: GPG signatures provide cryptographic proof of artifact origin Negative Key Management: GPG private key must be securely stored in GitHub Secrets Key Rotation: Requires manual process to rotate GPG keys and re-sign old releases User Friction: Users must import GPG public key before verification (one-time setup) File Size: SBOM and signature files add ~100-500 KB per release Maintenance GPG Key Expiration: Keys should be renewed every 2 years Public Key Distribution: Public key is published in /docs/GPG_PUBLIC_KEY.asc SBOM Updates: If SBOM format changes, update workflow and documentation Implementation Notes SBOM Generation Workflow - name: Generate SBOM uses: anchore/sbom-action@61119d458adab75f756bc0b9e4bde25725f86a7a # v0.17.2 with: path: ./wt.cli format: cyclonedx-json output-file: release-assets/wt-${{ needs.calculate-version.outputs.version }}-sbom.json GPG Signing Workflow # Import GPG key from secrets echo \"$GPG_PRIVATE_KEY\" | gpg --batch --import # Sign SBOM gpg --batch --yes --passphrase \"$GPG_PASSPHRASE\" \\ --pinentry-mode loopback \\ --armor --detach-sign wt-v1.0.0-sbom.json # Sign checksums gpg --batch --yes --passphrase \"$GPG_PASSPHRASE\" \\ --pinentry-mode loopback \\ --armor --detach-sign SHA256SUMS User Verification (Documented in quickstart.md) # Import public key (one-time) curl -fsSL https://raw.githubusercontent.com/kuju63/wt/main/docs/GPG_PUBLIC_KEY.asc | gpg --import # Verify SBOM signature gpg --verify wt-v1.0.0-sbom.json.asc wt-v1.0.0-sbom.json # Verify checksum signature gpg --verify SHA256SUMS.asc SHA256SUMS References CycloneDX Specification NTIA SBOM Minimum Elements GNU Privacy Guard Anchore SBOM Action GitHub Secrets Management Review Schedule This ADR should be reviewed: Before major version 1.0.0 release If SBOM format standards change (CycloneDX 2.0 release) If GPG key rotation is required If Sigstore/Cosign adoption becomes widespread"
  },
  "docs/adr/0003-semantic-versioning-conventional-commits.html": {
    "href": "docs/adr/0003-semantic-versioning-conventional-commits.html",
    "title": "ADR 0003: Semantic Versioning Strategy and Conventional Commits | wt",
    "summary": "ADR 0003: Semantic Versioning Strategy and Conventional Commits Status: Accepted Date: 2026-01-05 Context: Feature 003 - Automated Binary Release Pipeline Related: spec.md, research.md Context To automate the release process, we need a consistent versioning strategy that: Automatically determines the next version number based on commit history Follows industry-standard semantic versioning principles Communicates breaking changes, new features, and bug fixes clearly Integrates seamlessly with GitHub Actions workflows Decision Semantic Versioning 2.0.0 We will follow Semantic Versioning 2.0.0 with the format: MAJOR.MINOR.PATCH Example: v1.2.3 where: MAJOR (1): Incompatible API changes (breaking changes) MINOR (2): New features (backward-compatible) PATCH (3): Bug fixes (backward-compatible) Conventional Commits 1.0.0 All commit messages MUST follow Conventional Commits 1.0.0 specification. Format: <type>: <subject> Supported Types: feat: - New feature (triggers MINOR version bump) fix: - Bug fix (triggers PATCH version bump) BREAKING CHANGE: - Breaking change footer (triggers MAJOR version bump) docs: - Documentation only (no version bump) style: - Code style/formatting (no version bump) refactor: - Code refactoring (no version bump) test: - Test changes (no version bump) chore: - Build/tool changes (no version bump) Version Bump Rules Commit Type Version Bump Example Transition BREAKING CHANGE: in commit body/footer MAJOR v0.5.2 → v1.0.0 feat: in commit subject MINOR v0.5.2 → v0.6.0 fix: in commit subject PATCH v0.5.2 → v0.5.3 docs:, style:, refactor:, test:, chore: None No release Implementation Tool Tool: paulhatch/semantic-version GitHub Action (v5.4.0) Rationale: Mature: 1,000+ stars, actively maintained, widely used Configurable: Supports custom patterns for MAJOR/MINOR/PATCH detection Commit History Parsing: Analyzes all commits since last tag Git-Native: No external dependencies, works with standard Git tags Deterministic: Same commits → same version calculation GitHub Actions Native: Seamless integration with workflows Configuration: - name: Calculate next version uses: paulhatch/semantic-version@a8f8f59fd7f0625188492e945240f12d7ad2dca3 # v5.4.0 with: tag_prefix: \"v\" major_pattern: \"(BREAKING CHANGE:|BREAKING:)\" minor_pattern: \"feat:\" version_format: \"v${major}.${minor}.${patch}\" bump_each_commit: false search_commit_body: true Git Tag Format Tag Prefix: v (e.g., v1.2.3) GitHub Release Name: Same as tag (e.g., v1.2.3) Binary File Names: Include version (e.g., wt-v1.2.3-linux-x64) Initial Version First Release: v0.1.0 (pre-stable) Stable Release: v1.0.0 (production-ready) Alternatives Considered Alternative 1: Manual Versioning Approach: Developers manually specify version in VERSION file or package.json Pros: Full control over version numbers No dependency on commit message format Cons: Error-prone (developers forget to update version) Merge conflicts on version files No automated validation Inconsistent versioning across team Rejected: Does not meet automation requirements (FR-006). Alternative 2: semantic-release (Node.js) Approach: Use semantic-release NPM package Pros: Industry standard for Node.js projects Rich plugin ecosystem Automatic changelog generation Cons: Requires Node.js runtime (adds dependency to .NET project) Complex configuration (.releaserc file) Slower execution (npm install + semantic-release run) Overkill for simple version calculation Rejected: Adds unnecessary runtime dependency and complexity. Alternative 3: Custom Bash Script Approach: Write custom script to parse commits and calculate version Pros: No external dependencies Full control over logic Cons: Maintenance burden (testing, edge cases) Reinventing the wheel Potential for bugs in version calculation Rejected: GitHub Action provides tested, proven solution. Consequences Positive Automation: Version numbers calculated automatically from commit history Consistency: All team members follow the same versioning rules Clarity: Commit messages clearly communicate the type of change Predictability: Users can understand version impact (MAJOR = breaking, MINOR = features, PATCH = fixes) Traceability: Version history is traceable through Git tags and commit messages Negative Learning Curve: Developers must learn Conventional Commits format Strict Discipline: Invalid commit messages block automated versioning Merge Commits: Squash-and-merge strategy recommended to maintain clean commit history No Version Downgrade: Cannot manually decrease version number (only forward) Migration Strategy For existing projects without Conventional Commits: Start Fresh: First release with new pipeline is v0.1.0 Prefix Requirement: All new commits must follow Conventional Commits Git Hooks: Add commitlint to validate commit messages locally Documentation: Provide team training on Conventional Commits Enforcement Pre-Commit Hook (Optional) # .git/hooks/commit-msg #!/bin/sh npx --no-install commitlint --edit \"$1\" Pull Request Validation GitHub Actions workflow validates commit messages: - name: Validate commit messages run: | git log origin/main..HEAD --pretty=format:%s | \\ grep -Ev '^(feat|fix|docs|style|refactor|test|chore|BREAKING CHANGE):' && \\ { echo \"Invalid commit messages found!\"; exit 1; } || echo \"All commits valid\" Examples Example 1: Feature Addition (MINOR bump) git commit -m \"feat: add support for multiple worktrees\" # v0.5.2 → v0.6.0 Example 2: Bug Fix (PATCH bump) git commit -m \"fix: handle special characters in branch names\" # v0.5.2 → v0.5.3 Example 3: Breaking Change (MAJOR bump) git commit -m \"feat: change CLI argument format BREAKING CHANGE: All CLI arguments now use kebab-case instead of camelCase. Migration guide: docs/migration/v2.0.md\" # v0.5.2 → v1.0.0 Example 4: Documentation (No bump) git commit -m \"docs: update installation guide\" # v0.5.2 → v0.5.2 (no release) Documentation Team Guide: docs/ja/CONVENTIONAL_COMMITS.md User Guide: specs/003-automated-release-pipeline/quickstart.md Enforcement: Documented in .github/CONTRIBUTING.md References Semantic Versioning 2.0.0 Conventional Commits 1.0.0 paulhatch/semantic-version GitHub Action commitlint Review Schedule This ADR should be reviewed: Before major version 1.0.0 release If versioning strategy proves too restrictive or too lenient If Conventional Commits 2.0 is released Annually as part of architecture review"
  },
  "docs/adr/0004-release-workflow-timeout-sla.html": {
    "href": "docs/adr/0004-release-workflow-timeout-sla.html",
    "title": "ADR 0004: Release Workflow Timeout and Performance SLA | wt",
    "summary": "ADR 0004: Release Workflow Timeout and Performance SLA Status: Accepted Date: 2026-01-05 Context: Feature 003 - Automated Binary Release Pipeline Related: spec.md, SC-003, T048a Context The specification defines a performance requirement: SC-003: Release must be published within 30 minutes of merging to main branch. To ensure this SLA is met, we need to: Set appropriate GitHub Actions workflow timeouts Provide safety buffer for cleanup and error handling Prevent workflows from hanging indefinitely Log clear error messages when timeout occurs Decision Workflow Timeout: 25 Minutes The create-release job in .github/workflows/release.yml will have a 25-minute timeout. Configuration: create-release: name: Create GitHub Release needs: [calculate-version, build] runs-on: ubuntu-latest timeout-minutes: 25 # SLA: 30 minutes total, 5-minute buffer Rationale SLA Compliance: 25 minutes + 5-minute buffer = 30-minute total Safety Margin: Allows 5 minutes for: GitHub Actions queue time Artifact download delays Network latency for Release API calls Graceful error logging and cleanup Fail-Fast: Prevents indefinite hangs if external service fails (e.g., Codacy, GitHub API) User Experience: Users receive clear timeout error within SLA window Timeout Buffer Allocation Phase Expected Duration Timeout Allocation Build Job (parallel) 10-15 minutes 20 minutes per platform Create Release Job 8-12 minutes 25 minutes Total Pipeline 18-27 minutes 30 minutes (SLA) Buffer - 5 minutes Breakdown of Create Release Job Step Expected Time Notes Checkout repository 10-30 seconds Fetch all history for release notes Download build artifacts 1-2 minutes 4 platform binaries (~20-50 MB total) Organize binaries 5-10 seconds Copy and rename files Generate checksums 5-10 seconds SHA256 for all binaries Generate SBOM 30-60 seconds Anchore SBOM scan Sign artifacts 10-20 seconds GPG signing Generate release notes 10-30 seconds Parse commits since last tag Create Git tag 5-10 seconds Tag + push Create GitHub Release 30-60 seconds Upload 8-10 files to Release API Release summary 5 seconds Generate workflow summary Total 3-6 minutes Under normal conditions Worst-Case Scenarios Covered by 25-Minute Timeout: SBOM generation fails/retries (up to 5 minutes) GitHub API rate limiting (up to 10 minutes backoff) Artifact download slow network (up to 10 minutes) Multiple platform build retries (parallel, max 20 minutes) Alternatives Considered Alternative 1: No Timeout (Default GitHub Actions) Approach: Use default 360-minute (6-hour) timeout Pros: Never fails due to timeout Handles extreme edge cases Cons: Violates SC-003 SLA requirement Workflows can hang indefinitely on failures Wastes GitHub Actions minutes Poor user experience (no feedback) Rejected: Does not meet SLA requirement. Alternative 2: 15-Minute Timeout Approach: Aggressive timeout to ensure fast feedback Pros: Guarantees very fast failure detection Forces optimization of workflow Cons: Too tight for edge cases (slow network, API rate limits) High risk of false positives (legitimate builds failing) No buffer for transient failures Rejected: Too risky, may cause legitimate releases to fail. Alternative 3: 30-Minute Timeout (Exact SLA) Approach: Set timeout exactly at SLA boundary Pros: Matches SLA precisely Cons: No buffer for cleanup/logging User receives timeout error exactly at SLA deadline (bad UX) No time for graceful degradation Rejected: No safety margin for cleanup. Consequences Positive SLA Guarantee: Ensures releases complete within 30 minutes or fail clearly Resource Efficiency: Prevents runaway workflows from consuming GitHub Actions minutes Clear Failures: Timeout errors logged with context for debugging Performance Accountability: Forces workflow optimization to stay under 25 minutes Negative Potential False Positives: Legitimate releases may fail if external service is slow Timeout Handling: Requires careful error logging before timeout Monitoring Required: Need to track timeout frequency to identify systemic issues Error Handling When timeout occurs: GitHub Actions Logs: Workflow shows \"timeout-minutes exceeded\" error Step Summary: Last completed step visible in workflow summary User Notification: No release published, users check Actions tab for details Debugging: Logs indicate which step timed out Example Timeout Log: Error: The operation was canceled. ##[error]The action 'Create GitHub Release' has timed out after 25 minutes. ##[error]Workflow canceled by GitHub Actions (timeout-minutes: 25) Monitoring and Alerting Metrics to Track Average Release Duration: Target < 20 minutes (80% of timeout) Timeout Frequency: Target < 5% of releases Bottleneck Steps: Identify slowest steps via workflow logs When to Re-evaluate Timeout Re-evaluate timeout if: > 5% of releases fail due to timeout → Increase timeout or optimize workflow Average duration > 20 minutes → Optimize slow steps SLA requirement changes → Adjust timeout accordingly Implementation Notes Timeout Configuration # .github/workflows/release.yml create-release: name: Create GitHub Release needs: [calculate-version, build] runs-on: ubuntu-latest timeout-minutes: 25 # SLA: 30 minutes total, 5-minute buffer steps: # ... release steps Build Job Timeout (Per Platform) # .github/workflows/build.yml build: name: Build ${{ matrix.platform }}-${{ matrix.arch }} runs-on: ${{ matrix.os }} timeout-minutes: 20 # Per-platform timeout Rationale: Builds run in parallel, so 20-minute individual timeout + 25-minute release timeout = max 45 minutes total (exceeds SLA if builds serialize, but they don't). Graceful Timeout Handling - name: Upload to GitHub Release timeout-minutes: 10 # Step-level timeout continue-on-error: false # Fail job if timeout Testing Performance Test (T093) # Measure time from main merge to release availability time_start=$(git log -1 --format=%ct main) time_release=$(gh release view --json publishedAt -q .publishedAt) duration=$((time_release - time_start)) if [ $duration -gt 1800 ]; then echo \"FAIL: Release took ${duration}s (> 30 minutes)\" exit 1 fi Timeout Simulation # Simulate slow SBOM generation - name: Generate SBOM (with artificial delay) run: | sleep 600 # 10 minutes # ... actual SBOM generation Expected: Workflow completes within 25 minutes or fails gracefully. References GitHub Actions Timeout Limits SC-003: Performance Requirements T048a: Configure timeout Review Schedule This ADR should be reviewed: If timeout failures exceed 5% of releases If average release duration exceeds 20 minutes If SLA requirement changes (SC-003) Quarterly during performance reviews"
  },
  "docs/adr/0005-quality-gates-testing-requirements.html": {
    "href": "docs/adr/0005-quality-gates-testing-requirements.html",
    "title": "ADR 0005: Quality Gates and Testing Requirements | wt",
    "summary": "ADR 0005: Quality Gates and Testing Requirements Status: Accepted Date: 2026-01-05 Context: Feature 003 - Automated Binary Release Pipeline Related: spec.md, FR-007, FR-008, T062-T065 Context To ensure code quality and prevent regressions, we need automated quality gates that: Run tests on all branches before allowing merge to main Report code coverage to Codacy for visibility Enforce minimum quality standards Balance strictness with developer productivity The specification defines: FR-007: All feature/fix branches tested before merge FR-008: Code coverage reported to Codacy SC-002: Target 80% code coverage (aspirational, not blocking) Decision Test Execution: Mandatory and Blocking Rule: All tests MUST pass before merging to main. Implementation: GitHub branch protection rule + .github/workflows/test.yml Configuration: # Repository Settings → Branches → main → Branch protection rules - Require status checks to pass before merging - Required status check: \"Test and Coverage / Run Tests\" Behavior: ❌ Test failure → Merge blocked, PR shows red status ✅ Test success → Merge allowed, PR shows green status Rationale: Regression Prevention: Broken code cannot reach main branch Quality Assurance: Every release is backed by passing tests Developer Confidence: Failures caught early in PR review Compliance: Meets FR-007 requirement Code Coverage: Warning Only (Non-Blocking) Rule: Code coverage reported to Codacy, but coverage drops do NOT block merge. Implementation: Codacy integration in .github/workflows/test.yml Configuration: - name: Upload coverage to Codacy uses: codacy/codacy-coverage-reporter-action@a38818475bb21847788496e9f0fddaa4e84955ba with: project-token: ${{ secrets.CODACY_PROJECT_TOKEN }} coverage-reports: ${{ steps.coverage.outputs.coverage-file }} continue-on-error: true # Coverage upload failure does not block PR Behavior: \uD83D\uDCCA Coverage < 80% → Codacy comment on PR (warning), merge allowed \uD83D\uDCC9 Coverage drops → Codacy comment shows decrease, merge allowed \uD83D\uDCC8 Coverage increases → Codacy comment shows improvement, merge allowed ❌ Codacy upload fails → Warning logged, merge allowed (transient failure tolerance) Rationale: Visibility: Coverage trends visible in Codacy dashboard and PR comments Non-Blocking: Allows pragmatic balance between coverage and velocity Aspirational Goal: 80% is a target, not a hard requirement Transient Failure Tolerance: Codacy API outages do not block development Developer Accountability: Coverage warnings encourage but do not enforce coverage improvements Quality Gate Policy Summary Check Status Blocks Merge? Rationale Test Execution Required ✅ Yes Prevents regressions, ensures correctness Code Coverage Informational ❌ No Encourages improvement, tolerates pragmatism Coverage Threshold (80%) Aspirational ❌ No Goal, not requirement (SC-002) Codacy Upload Failure Warning ❌ No Transient API failures should not block work Alternatives Considered Alternative 1: Strict Coverage Threshold (80% Blocking) Approach: Require 80% code coverage before allowing merge Pros: Forces high test coverage Ensures comprehensive testing Cons: Blocks pragmatic development (e.g., integration tests vs. unit tests) Encourages \"gaming the system\" (meaningless tests to hit threshold) Slows velocity for diminishing returns (80% → 85% may require disproportionate effort) Transient failures (Codacy API outage) block all PRs Rejected: Too strict, reduces developer productivity without proportional quality gain. Alternative 2: No Coverage Reporting Approach: Run tests, but do not report coverage Pros: Simplest implementation No external service dependency Cons: Violates FR-008 requirement (Codacy integration) No visibility into coverage trends Cannot track quality improvements over time Rejected: Does not meet specification requirement. Alternative 3: Coverage Threshold on Main Only Approach: Enforce 80% coverage only on main branch, not on feature branches Pros: Allows experimentation on feature branches Ensures main branch quality Cons: Requires post-merge enforcement (revert bad merges) Poor developer experience (surprises after merge) Defeats purpose of PR review Rejected: Post-merge enforcement is too late. Consequences Positive Regression Prevention: Broken tests cannot merge to main Developer Experience: Clear pass/fail status in PR checks Quality Visibility: Coverage trends visible in Codacy dashboard Pragmatic Balance: Strict on correctness (tests), lenient on metrics (coverage) Resilience: Transient Codacy failures do not block development Negative Coverage Not Enforced: Projects may drift below 80% coverage without intervention Manual Oversight Required: Team must review Codacy warnings and act on them Potential Technical Debt: Low-coverage code may accumulate over time Mitigation Strategies Regular Coverage Reviews: Monthly review of Codacy dashboard in team meetings Coverage Targets in PRs: Encourage reviewers to request tests for low-coverage changes Codacy Quality Goals: Set Codacy project goal to 80%, track progress Documentation: Document coverage expectations in CONTRIBUTING.md Implementation Branch Protection Rules (GitHub Repository Settings) # Settings → Branches → main → Branch protection rules protection: required_status_checks: strict: true # Require branch to be up to date before merging checks: - \"Test and Coverage / Run Tests\" # Required # Note: Codacy checks are NOT required Test Workflow Configuration # .github/workflows/test.yml jobs: test: name: Run Tests runs-on: ubuntu-latest steps: - name: Run tests with coverage run: | dotnet test wt.sln \\ --configuration Release \\ --no-build \\ --verbosity normal \\ --collect:\"XPlat Code Coverage\" \\ --results-directory ./coverage \\ --logger \"trx;LogFileName=test-results.trx\" - name: Upload coverage to Codacy uses: codacy/codacy-coverage-reporter-action@a38818475bb21847788496e9f0fddaa4e84955ba with: project-token: ${{ secrets.CODACY_PROJECT_TOKEN }} coverage-reports: ${{ steps.coverage.outputs.coverage-file }} continue-on-error: true # Non-blocking - name: Publish test results if: always() uses: dorny/test-reporter@bdab7eb6dfb6be17ac3d72352f67e559a72c8db1 with: name: Test Results path: '**/TestResults/*.trx' reporter: dotnet-trx fail-on-error: true # Test failures block merge Release Workflow Quality Gate # .github/workflows/release.yml build: name: Build Binaries needs: calculate-version if: needs.calculate-version.outputs.should-release == 'true' # Implicitly depends on test.yml passing (branch protection) Note: Release workflow only runs on main branch, which already has passing tests (enforced by branch protection). Testing Requirements Documentation Developer Guide (docs/ja/CONTRIBUTING.md) Test Expectations: All new features must include tests Coverage Goal: Aim for 80% coverage, but not strictly enforced Test Types: Unit tests (required), integration tests (recommended) Test Failures: Must be fixed before merge Pull Request Template (.github/PULL_REQUEST_TEMPLATE.md) ## Testing Checklist - [ ] All tests pass locally (`dotnet test`) - [ ] New features include unit tests - [ ] Coverage is maintained or improved (check Codacy comment) - [ ] No test warnings or errors in output Monitoring and Metrics Metrics to Track Test Pass Rate: % of PRs with passing tests (target: 100%) Average Coverage: Project-wide coverage (target: 80%) Coverage Trend: Month-over-month coverage change Codacy Upload Success Rate: % of coverage reports successfully uploaded (target: > 95%) Alerts Test Failure Spike: > 10% of PRs failing tests → Investigate test flakiness Coverage Drop: > 5% coverage decrease in 1 month → Team review required Codacy Upload Failures: > 20% failures → Check Codacy service health Documentation User Guide: quickstart.md Developer Guide: docs/ja/CONTRIBUTING.md (to be created) Testing Guide: specs/003-automated-release-pipeline/testing-guide.md (T070) References GitHub Branch Protection Rules Codacy Coverage Reporter Action FR-007: Test Automation FR-008: Coverage Reporting SC-002: Coverage Goal Review Schedule This ADR should be reviewed: If test pass rate drops below 90% If average coverage drops below 70% (10% below goal) If quality gates prove too strict or too lenient Quarterly during team retrospectives"
  },
  "docs/adr/004-sbom-generation.html": {
    "href": "docs/adr/004-sbom-generation.html",
    "title": "ADR 004: SBOM Generation for Release Pipeline | wt",
    "summary": "ADR 004: SBOM Generation for Release Pipeline Status Accepted Context As a command-line tool distributed through GitHub releases, we need to provide transparency about our software supply chain. Users need to know: What dependencies are included in each release License information for compliance Vulnerability tracking through automated tools Complete bill of materials for audit purposes Decision We will implement SBOM (Software Bill of Materials) generation as part of our release pipeline with the following approach: Tool Selection: Microsoft SBOM Tool Rationale: Official Microsoft tool for .NET ecosystem Native support for .NET project dependency analysis Generates SPDX 2.3+ format (ISO/IEC 5962:2021 compliant) Easy integration with GitHub Actions Multi-platform support (Windows/Linux/macOS) Alternatives Considered: CycloneDX Generator: More generic but less .NET-specific → Rejected OWASP Dependency-Check: Focused on vulnerability scanning, SBOM is secondary → Rejected Syft/Grype: Container-focused, overkill for .NET projects → Rejected SBOM Format: SPDX 2.3 (JSON) Rationale: ISO international standard (ISO/IEC 5962:2021) Required by US government and many regulations Microsoft's recommended format Strong tool ecosystem support Long-term maintenance by Linux Foundation Alternatives Considered: CycloneDX: More developer-friendly but not an ISO standard → Rejected for regulatory compliance SWID Tags: Legacy format, not suitable for modern CI/CD → Rejected Implementation Approach Dependency Restoration: Complete restore of all project dependencies before SBOM generation Multi-platform Support: Restore for all target platforms (win-x64, linux-x64, linux-arm, osx-arm64) Validation: Verify SBOM completeness and format compliance GitHub Integration: Submit to GitHub Dependency Graph API Attach SBOM to release assets PR Testing: Pre-release validation workflow Key Requirements FR-001: Complete dependency restore before SBOM generation FR-002: All direct and transitive dependencies must be included FR-006: SPDX 2.3+ format compliance FR-011: GitHub Dependency Graph integration FR-019: PR testing workflow for early detection Consequences Positive Supply Chain Transparency: Users can verify all components in the software Vulnerability Management: Automated detection via Dependabot/Renovate License Compliance: Clear license information for all dependencies Regulatory Compliance: Meets government and enterprise requirements Audit Trail: Versioned SBOM files attached to each release Early Detection: PR workflow catches issues before release Negative Build Time: Adds 2-5 minutes to release pipeline (acceptable within 15-minute SLA) Storage: SBOM files add ~100KB per release (minimal impact) Maintenance: Requires monitoring of Microsoft SBOM Tool updates Neutral Learning Curve: Team needs to understand SPDX format for troubleshooting Toolchain Dependency: Relies on Microsoft maintaining the SBOM tool Implementation Notes Workflow Integration Points Release Pipeline (.github/workflows/release.yml): Dependency restore with --locked-mode Multi-platform restore SBOM generation with Microsoft SBOM Tool SPDX format validation GitHub API submission Release asset attachment PR Testing Pipeline (.github/workflows/sbom-test.yml): Dry-run SBOM generation Format validation Dependency verification Performance benchmarking Critical Success Factors Complete Dependency Capture: Must restore all dependencies before SBOM generation Format Compliance: Must pass SPDX 2.3 validation API Integration: Must successfully submit to GitHub Dependency Graph Performance: Must complete within 15-minute workflow timeout Monitoring & Maintenance Monitor Microsoft SBOM Tool release notes for updates Review GitHub Dependency Graph for accuracy Validate SBOM files on each release Track workflow execution times References Microsoft SBOM Tool SPDX Specification 2.3 ISO/IEC 5962:2021 GitHub Dependency Submission API Executive Order 14028 (US Cybersecurity) Date 2026-01-10"
  },
  "docs/adr/adr.html": {
    "href": "docs/adr/adr.html",
    "title": "Architecture Decision Records | wt",
    "summary": "Architecture Decision Records This directory contains Architecture Decision Records (ADRs) for this project. ADRs are used to document important architectural decisions made during the development of the project. Each ADR is stored in its own Markdown file, named with a unique identifier and a brief description of the decision. List of ADRs ADR 0001: Add Clean & Secure Code requirements to Constitution ADR 0002: SBOM Format and Digital Signature Choice ADR 0003: Semantic Versioning Strategy and Conventional Commits ADR 0004: Release Workflow Timeout and Performance SLA ADR 0005: Quality Gates and Testing Requirements"
  },
  "docs/api/index.html": {
    "href": "docs/api/index.html",
    "title": "API Reference | wt",
    "summary": "API Reference Welcome to the wt API reference documentation. This section provides comprehensive documentation for all public interfaces, classes, and methods in the wt library. Overview The wt library is organized into the following namespaces: Kuju63.WorkTree.CommandLine.Commands - Command implementations for worktree operations Kuju63.WorkTree.CommandLine.Models - Data models and result types Kuju63.WorkTree.CommandLine.Services - Core services for Git, worktree, and editor operations Kuju63.WorkTree.CommandLine.Formatters - Output formatting utilities Kuju63.WorkTree.CommandLine.Utils - Utility classes and helpers Getting Started with the API While wt is primarily a CLI tool, its underlying API can be integrated into your own .NET applications for programmatic worktree management. Basic Integration Example using System.IO.Abstractions; using Kuju63.WorkTree.CommandLine.Services.Git; using Kuju63.WorkTree.CommandLine.Services.Worktree; using Kuju63.WorkTree.CommandLine.Utils; using Kuju63.WorkTree.CommandLine.Models; // Setup dependencies var fileSystem = new FileSystem(); var processRunner = new ProcessRunner(); var pathHelper = new PathHelper(fileSystem); var gitService = new GitService(processRunner); var worktreeService = new WorktreeService(gitService, pathHelper, null); // Create a worktree var options = new CreateWorktreeOptions { BranchName = \"feature-branch\", BaseBranch = \"main\", WorktreePath = null, // Uses default path OutputFormat = OutputFormat.Human, Verbose = false }; var result = await worktreeService.CreateWorktreeAsync(options, CancellationToken.None); if (result.IsSuccess) { Console.WriteLine($\"Worktree created at: {result.Data.Path}\"); } else { Console.WriteLine($\"Error: {result.ErrorMessage}\"); } List Worktrees Example // List all worktrees var listResult = await worktreeService.ListWorktreesAsync(CancellationToken.None); if (listResult.IsSuccess) { foreach (var worktree in listResult.Data) { Console.WriteLine($\"{worktree.Path} - {worktree.Branch} ({worktree.Status})\"); } } Key Interfaces IWorktreeService The primary interface for worktree operations. Provides methods for creating and listing worktrees. Methods: ListWorktreesAsync - Lists all worktrees in the repository IGitService Low-level Git operations interface. Provides direct access to Git commands. Methods: IsGitRepositoryAsync - Checks if the current directory is a Git repository BranchExistsAsync - Checks if a branch exists GetCurrentBranchAsync - Gets the currently checked-out branch name CreateBranchAsync - Creates a new Git branch CreateWorktreeAsync - Creates a worktree using git worktree add IEditorService Editor integration interface for launching editors after worktree creation. Methods: LaunchEditorAsync - Launches the specified editor with the given path Models CommandResult<T> Generic result type for command operations. Provides success/failure status, data, error information, and solutions. Properties: IsSuccess - Indicates if the operation was successful Data - The result data (when successful) ErrorCode - Error code for debugging ErrorMessage - Human-readable error message Solution - Suggested solution for the error Warnings - List of non-critical warnings WorktreeInfo Represents information about a Git worktree. Properties: Path - File system path to the worktree Branch - Branch name checked out in the worktree Commit - Current commit hash Status - Worktree status (active, missing, etc.) Exists - Whether the worktree directory exists on disk CreateWorktreeOptions Options for creating a new worktree. Properties: BranchName - Name of the new branch to create (required) BaseBranch - Base branch to branch from (optional) WorktreePath - Custom path for the worktree (optional) EditorType - Editor to launch after creation (optional) OutputFormat - Output format (Human or Json) Verbose - Enable verbose diagnostic output Error Handling All service methods return CommandResult<T> which includes comprehensive error information: var result = await worktreeService.CreateWorktreeAsync(options, cancellationToken); if (!result.IsSuccess) { Console.WriteLine($\"Error: {result.ErrorMessage}\"); Console.WriteLine($\"Error Code: {result.ErrorCode}\"); if (!string.IsNullOrEmpty(result.Solution)) { Console.WriteLine($\"Solution: {result.Solution}\"); } } Browse the API Use the navigation on the left to explore the complete API documentation, including: Detailed class and interface documentation Method signatures and parameters Property descriptions Code examples (where available) Inheritance hierarchies Implementation details Support For questions about the API or integration: GitHub Issues - Report bugs or request features Contributing Guide - Contribute to the project Note: This API is primarily designed for internal use by the wt CLI. While it can be used in your applications, the API surface may change between versions. For stable integrations, consider using the CLI as a subprocess or waiting for an official SDK release."
  },
  "docs/commands/create.html": {
    "href": "docs/commands/create.html",
    "title": "wt create | wt",
    "summary": "wt create Create a new worktree with a new branch Syntax wt create <branch> [options] Arguments <branch> Name of the branch to create Options -b, --base <base> Base branch to branch from (default: current branch) -p, --path <path> Path where the worktree will be created (default: ../wt- ) -e, --editor <Emacs|IntelliJIDEA|Nano|Vim|VSCode> Editor to launch after creating worktree --output <Human|Json> Output format (human or json) [default: Human] -v, --verbose Show detailed diagnostic information Examples See the command reference documentation for usage examples."
  },
  "docs/commands/index.html": {
    "href": "docs/commands/index.html",
    "title": "Command Reference | wt",
    "summary": "Command Reference Complete reference documentation for all wt commands. Overview wt provides a simple command-line interface for managing Git worktrees. All commands follow a consistent pattern and provide helpful error messages. Available Commands Worktree Management Command Description create Create a new worktree with a new branch list List all worktrees with their branch information Quick Reference Create a worktree # Basic usage wt create feature-login # With options wt create feature-auth --base main --editor vscode List worktrees wt list Common Options Most commands support these common options: -h, --help Show help and usage information for the command. -v, --verbose Show detailed diagnostic information (where applicable). Global Behavior Exit Codes All commands use consistent exit codes: Code Meaning 0 Success 1 General error 2 Not a Git repository 10 Git command failed 99 Unexpected error Output Formats Commands that produce structured output support multiple formats: Human (default): Formatted tables and messages for terminal display JSON: Machine-readable output for automation and scripting Example: wt create feature-api --output json | jq '.worktree.path' Getting Help Command help Get help for any command: wt --help wt create --help wt list --help Documentation Installation Guide - Install wt on your system Quick Start Guide - Get started in 5 minutes GitHub Repository - Source code and issues Examples by Use Case Starting a new feature wt create feature-user-auth --base main --editor vscode cd ../wt-feature-user-auth # Work on your feature... Bug fix workflow wt create bugfix-login-timeout --base main cd ../wt-bugfix-login-timeout # Fix the bug... Code review # Create worktree from pull request branch wt create pr-123 --base origin/pr-123 cd ../wt-pr-123 # Review code... Checking worktree status wt list Tips and Best Practices Use descriptive branch names: feature-user-auth is better than feature1 Clean up regularly: Remove worktrees when done with git worktree remove <path> Leverage editor integration: Use --editor to save time opening files Automate with JSON: Use --output json for scripts and CI/CD pipelines See Also Installation Quick Start Git Worktree Documentation"
  },
  "docs/commands/list.html": {
    "href": "docs/commands/list.html",
    "title": "wt list | wt",
    "summary": "wt list List all worktrees with their branch information Syntax wt list [options] Options Examples See the command reference documentation for usage examples."
  },
  "docs/coverage-report.html": {
    "href": "docs/coverage-report.html",
    "title": "Code Coverage Report | wt",
    "summary": "Code Coverage Report Generated: 2026-01-04 Branch: copilot/sub-pr-2 Commits Tested: 813360c (fix: resolve git directory from .git file for worktrees), 79b7ac5 (refactor: remove redundant Directory.Exists check), and latest test additions Overall Coverage Summary Line Coverage: 84% (747/889 lines) ⬆️ +2.2% Branch Coverage: 67.6% (176/260 branches) ⬆️ +3.4% Method Coverage: 97.5% (121/124 methods) Full Method Coverage: 83% (103/124 fully covered methods) Test Results Total Tests: 175 (⬆️ +4 new tests) Passed: 173 ✓ Failed: 1 (unrelated to changes - EditorService special characters test) Skipped: 1 Coverage by Component Component Line Coverage Change ListCommand 100% - CreateCommand 79.4% - TableFormatter 100% - GitService 80.6% ⬆️ +10% EditorService 97.3% - WorktreeService 77% - ProcessRunner 100% - Validators 100% - GitService Coverage Analysis The GitService class now has 80.6% line coverage (up from 70.6%). The CreateWorktreeInfo method, which contains the changes made in this PR, now has significantly improved coverage. New Integration Tests Added Four new integration tests were added in GitDirectoryResolutionTests.cs: ListWorktreesAsync_WhenRunFromWorktree_ResolvesGitDirectoryCorrectly Tests running from within a worktree where .git is a file Verifies the .git file parsing logic Confirms all worktrees are listed correctly ListWorktreesAsync_WhenRunFromMainRepo_ListsWorktreesWithTimestamps Tests timestamp reading from worktree metadata Verifies creation time accuracy GitFile_InWorktree_ContainsValidGitdirReference Tests .git file format validation Verifies gitdir reference parsing ListWorktreesAsync_WithMultipleWorktrees_ReturnsAllWorktrees Tests with multiple worktrees Verifies comprehensive worktree listing Coverage of New Code The new .git file parsing logic (lines 302-323) is now mostly covered: ✅ Covered: Checking if .git is a file (line 302) Reading the .git file contents (line 304) Parsing the gitdir: prefix (lines 307-309) Extracting and trimming the path (line 311) Resolving absolute paths (line 319) Using the resolved gitDir variable (lines 326-327) File creation time reading (lines 329-332) ⚠️ Not Covered: Relative path resolution (lines 315-317) - Edge case, most worktrees use absolute paths Exception handling blocks (lines 334+) - Would require fault injection Improvement Summary Before Tests: Line Coverage: 28.57% for CreateWorktreeInfo method Branch Coverage: 16.66% After Tests: Line Coverage: ~80%+ for CreateWorktreeInfo method Branch Coverage: ~67%+ All critical paths are now tested with real worktree scenarios Coverage Report Files Full coverage reports are available in: HTML Report: TestResults/CoverageReport/index.html Cobertura XML: TestResults/**/coverage.cobertura.xml Text Summary: TestResults/CoverageReport/Summary.txt How to Reproduce # Run tests with coverage collection dotnet test wt.tests/wt.tests.csproj --collect:\"XPlat Code Coverage\" --results-directory ./TestResults # Generate HTML report dotnet tool install --global dotnet-reportgenerator-globaltool reportgenerator -reports:\"TestResults/**/coverage.cobertura.xml\" -targetdir:\"TestResults/CoverageReport\" -reporttypes:\"Html;TextSummary\" # View the report # Open TestResults/CoverageReport/index.html in a browser Conclusion The addition of 4 integration tests has successfully improved coverage of the new .git file parsing logic from essentially 0% to over 80%. The tests verify real worktree scenarios and ensure the code correctly handles the case where .git is a file pointing to a git directory rather than being a directory itself."
  },
  "docs/getting-started.html": {
    "href": "docs/getting-started.html",
    "title": "Getting Started | wt",
    "summary": "Getting Started This guide will help you get started with the wt CLI tool for managing Git worktrees. Prerequisites .NET 10.0 SDK or later Git 2.5 or later (for git worktree support) A Git repository Installation Build from Source git clone https://github.com/kuju63/wt.git cd wt dotnet build Run the Tool dotnet run --project wt.cli -- <command> Install Globally (Optional) dotnet pack dotnet tool install --global --add-source ./nupkg wt Basic Workflow 1. Create a New Worktree Create a new worktree for a feature branch: wt create feature-login This command will: Create a new branch feature-login from your current branch Create a worktree at ../wt-feature-login Check out the new branch in the worktree 2. List All Worktrees View all worktrees in your repository: wt list Output example: ┌─────────────────────────────────┬──────────────────┬─────────┐ │ Path │ Branch │ Status │ ├─────────────────────────────────┼──────────────────┼─────────┤ │ /Users/dev/project/wt │ main │ active │ │ /Users/dev/project/wt-feature │ feature-login │ active │ └─────────────────────────────────┴──────────────────┴─────────┘ The list shows: Path: The filesystem path of the worktree Branch: The checked-out branch (or commit hash for detached HEAD) Status: active if the worktree exists, missing if it's registered but not on disk 3. Navigate to Your Worktree cd ../wt-feature-login # Start working on your feature 4. Work with Multiple Features You can create multiple worktrees to work on different features simultaneously: wt create feature-auth wt create feature-ui wt create bugfix-123 --base main wt list Each worktree is independent, allowing you to switch between features without stashing changes. Advanced Usage Custom Worktree Path wt create feature-api --path ~/projects/myapp-api Auto-Launch Editor wt create feature-ui --editor vscode Supported editors: vscode - Visual Studio Code vim - Vim emacs - Emacs nano - Nano idea - IntelliJ IDEA JSON Output for Automation wt create feature-test --output json wt list --format json # Coming in future release Common Scenarios Scenario 1: Working on Multiple Features # Main repository for code reviews cd ~/projects/myapp # Feature 1: User authentication wt create feature-auth cd ../wt-feature-auth # ... work on authentication ... # Feature 2: New UI while auth is in progress cd ~/projects/myapp wt create feature-ui cd ../wt-feature-ui # ... work on UI ... # View all active worktrees cd ~/projects/myapp wt list Scenario 2: Hotfix on Production # Create hotfix from main branch wt create hotfix-critical-bug --base main # Work on the fix in isolation cd ../wt-hotfix-critical-bug # ... fix the bug ... # ... commit and push ... Scenario 3: Review Pull Requests # Create worktree for PR review wt create review-pr-123 --base main cd ../wt-review-pr-123 # Fetch and checkout the PR branch git fetch origin pull/123/head:pr-123 git checkout pr-123 # Review the code, test, etc. Tips and Best Practices Keep worktrees organized: Use the default naming convention wt-<branch> for consistency List regularly: Use wt list to see all your worktrees and their status Clean up: Remove worktrees when done with git worktree remove <path> Missing worktrees: If wt list shows a worktree as missing, remove it with git worktree prune Detached HEAD: Be careful with detached HEAD state - create a branch if you need to keep changes Next Steps See Command Reference for detailed command options Learn about Architecture Decision Records for design decisions Read the API Documentation for programmatic usage"
  },
  "docs/guides/quickstart.html": {
    "href": "docs/guides/quickstart.html",
    "title": "Quick Start Guide | wt",
    "summary": "Quick Start Guide Get started with wt in just a few minutes. This guide walks you through creating your first worktree and covers basic commands. Prerequisites Git installed and configured wt installed (see Installation Guide) An existing Git repository Your First Worktree Step 1: Navigate to Your Repository Open a terminal and navigate to any Git repository: cd /path/to/your/project Step 2: Create a Worktree Create a new worktree for a feature branch: wt create feature-new-feature This command will: Create a new branch called feature-new-feature Set up a worktree at ../wt-feature-new-feature Automatically open the worktree in your default editor (if configured) Output: ✓ Created branch: feature-new-feature ✓ Created worktree: /Users/username/projects/wt-feature-new-feature ✓ Checked out: feature-new-feature Step 3: List Your Worktrees View all worktrees in your repository: wt list Output: ┌─────────────────────────────────────────────┬──────────────────────┬─────────┐ │ Path │ Branch │ Status │ ├─────────────────────────────────────────────┼──────────────────────┼─────────┤ │ /Users/username/projects/wt │ main │ active │ │ /Users/username/projects/wt-feature-new │ feature-new-feature │ active │ └─────────────────────────────────────────────┴──────────────────────┴─────────┘ Basic Commands Create Worktree with Custom Path Specify a custom location for your worktree: wt create feature-login --path ~/projects/myapp-login Create Worktree from Specific Base Branch Create a branch from a specific base (e.g., main): wt create feature-login --base main Auto-Launch Editor Create a worktree and automatically open it in your editor: wt create feature-login --editor vscode Supported editors: vscode, vim, emacs, nano, idea Common Workflows Feature Development Workflow Start a new feature: wt create feature-user-auth cd ../wt-feature-user-auth Work on your feature: # Make changes, commit as usual git add . git commit -m \"Add user authentication\" Switch back to main: cd ../wt # or your main worktree path Clean up when done: git worktree remove ../wt-feature-user-auth Parallel Development Work on multiple features simultaneously: # Terminal 1: Work on feature A wt create feature-a cd ../wt-feature-a # Terminal 2: Work on feature B wt create feature-b cd ../wt-feature-b # Terminal 3: Review code in main cd /path/to/wt Each worktree is independent - changes in one don't affect others. Editor Integration wt can automatically open new worktrees in your preferred editor. Supported Editors Visual Studio Code (vscode) Vim (vim) Emacs (emacs) Nano (nano) IntelliJ IDEA (idea) Example wt create feature-ui --editor vscode This will create the worktree and automatically launch VS Code in that directory. Tips and Best Practices 1. Naming Conventions Use descriptive branch names with prefixes: wt create feature-user-authentication wt create bugfix-login-timeout wt create hotfix-security-patch 2. Default Directory Structure Worktrees are created as sibling directories with wt- prefix by default: projects/ ├── wt/ (main worktree) ├── wt-feature-a/ ├── wt-feature-b/ └── wt-bugfix-login/ 3. Clean Up Regularly Remove worktrees when you're done: git worktree remove ../wt-feature-name Or use Git's built-in prune command: git worktree prune 4. Use JSON Output for Automation For scripting and automation: wt create feature-api --output json | jq '.worktree.path' Next Steps Command Reference: Detailed documentation for all commands Installation Guide: Advanced installation options Contributing: Help improve wt Getting Help Run wt --help for command help Run wt create --help for create command options Visit the GitHub repository Report issues on GitHub Issues"
  },
  "docs/guides/sbom-usage.html": {
    "href": "docs/guides/sbom-usage.html",
    "title": "SBOM生成 クイックスタートガイド | wt",
    "summary": "SBOM生成 クイックスタートガイド このガイドでは、wtプロジェクトのSBOM（Software Bill of Materials）生成機能の使用方法を説明します。 \uD83D\uDCCB 目次 概要 ユーザー向けガイド 開発者向けガイド トラブルシューティング 概要 SBOMとは？ SBOM（Software Bill of Materials）は、ソフトウェアの「部品表」です。アプリケーションが使用しているすべての依存関係（ライブラリ、パッケージ）を一覧化したドキュメントで、以下の目的で使用されます： サプライチェーンの透明性: ソフトウェアに含まれる全コンポーネントを明示 脆弱性管理: 依存関係の脆弱性を追跡・修正 ライセンスコンプライアンス: 使用ライブラリのライセンスを確認 監査証跡: セキュリティ監査やコンプライアンスチェックに利用 wtプロジェクトのSBOM wtプロジェクトは、各リリースに対して以下を提供します： ✅ SPDX 2.3形式のSBOM - ISO/IEC 5962:2021準拠 ✅ GitHub依存関係グラフ統合 - Dependabot/Renovateアラート自動有効化 ✅ リリースアセット添付 - 誰でもダウンロード可能 ユーザー向けガイド SBOMの取得方法 方法1: GitHubリリースからダウンロード（推奨） wtのリリースページにアクセス 使用しているバージョンを選択（例: v1.0.0） Assets セクションから wt-v1.0.0-sbom.spdx.json をダウンロード # 最新リリースからダウンロード（Linux/macOS） VERSION=$(curl -s https://api.github.com/repos/kuju63/wt/releases/latest | grep '\"tag_name\":' | sed -E 's/.*\"([^\"]+)\".*/\\1/') curl -L https://github.com/kuju63/wt/releases/download/${VERSION}/wt-${VERSION}-sbom.spdx.json \\ -o wt-sbom.spdx.json # または特定バージョンを指定してダウンロード curl -L https://github.com/kuju63/wt/releases/download/v1.0.0/wt-v1.0.0-sbom.spdx.json \\ -o wt-sbom.spdx.json 方法2: GitHub依存関係グラフから確認 wtリポジトリにアクセス Insights タブをクリック Dependency graph を選択 すべての依存関係とバージョンを確認 SBOMの検証 SBOMが正しいフォーマットか検証する方法： # SPDX検証ツールをインストール npm install -g @spdx/spdx-validator # SBOMを検証 spdx-validator wt-sbom.spdx.json 成功時の出力： ✓ SPDX document is valid SBOMの内容を確認 依存関係の一覧表示 # jqを使用してパッケージ名とバージョンを抽出 jq -r '.packages[] | \"\\(.name)@\\(.versionInfo)\"' wt-sbom.spdx.json 出力例： System.CommandLine@2.0.1 System.IO.Abstractions@22.1.0 System.Memory@4.5.5 ... ライセンス情報の確認 # パッケージ名とライセンスを表示 jq -r '.packages[] | \"\\(.name): \\(.licenseDeclared)\"' wt-sbom.spdx.json 出力例： System.CommandLine: MIT System.IO.Abstractions: MIT System.Memory: MIT ... 脆弱性チェック 方法1: GitHub Dependabot（自動） wtプロジェクトは自動的にDependabotが有効化されており、脆弱性が発見されると： リポジトリの Security タブにアラート表示 メンテナに自動通知 可能であれば自動修正PRが作成される 方法2: ローカルでのスキャン # OSV Scannerを使用（推奨） osv-scanner --sbom=wt-sbom.spdx.json # Grypeを使用 grype sbom:wt-sbom.spdx.json エンタープライズ向け: SBOM統合 1. Dependency-Trackへのインポート # Dependency-Track APIを使用 curl -X POST \"https://your-dependency-track.com/api/v1/bom\" \\ -H \"X-Api-Key: YOUR_API_KEY\" \\ -H \"Content-Type: application/json\" \\ -d @wt-sbom.spdx.json 2. コンプライアンスチェック # SPDX Toolsを使用してライセンスコンプライアンスを確認 spdx-tools verify wt-sbom.spdx.json 開発者向けガイド ローカルでのSBOM生成 開発中にローカルでSBOMを生成する方法： 1. Microsoft SBOM Toolのインストール dotnet tool install --global Microsoft.Sbom.DotNetTool 2. 依存関係のリストア cd /path/to/wt dotnet restore --locked-mode 3. SBOM生成 sbom-tool generate \\ -b ./sbom-output \\ -bc . \\ -pn kuju63/wt \\ -pv 1.0.0-dev \\ -nsb https://github.com/kuju63/wt/sbom/dev パラメータ説明 -b: 出力ディレクトリ -bc: ビルドコンポーネントのルートパス -pn: パッケージ名 -pv: バージョン -nsb: 名前空間URI（一意性保証） 生成されたSBOMは ./sbom-output/_manifest/spdx_2.2/manifest.spdx.json に出力されます。 CI/CDでの動作確認 PR時の自動テスト（推奨） Pull Requestを作成すると、SBOM生成テストが自動実行されます： # ブランチを作成してPRを開く git checkout -b feature/add-dependency git push origin feature/add-dependency gh pr create --title \"Add new dependency\" # テスト結果を確認 gh pr checks PR時テストで確認される項目： ✅ 依存関係のリストアが成功するか ✅ SBOM生成が成功するか ✅ SPDX 2.3フォーマットが正しいか ✅ 必須パッケージ（System.CommandLine等）が含まれているか ✅ パフォーマンス目標（15分以内）を満たしているか ワークフローの手動実行 # リリースワークフローを手動トリガー gh workflow run release.yml \\ --ref feature/your-branch # SBOM テストワークフローを手動実行 gh workflow run sbom-test.yml \\ --ref feature/your-branch # 実行状況の確認 gh run list --workflow=release.yml --limit 1 gh run list --workflow=sbom-test.yml --limit 1 ローカルでのワークフロー検証 # act を使用してGitHub Actionsをローカル実行 act release --secret GITHUB_TOKEN=your_token SBOM生成のカスタマイズ プラットフォーム固有の依存関係を含める # 特定のランタイムIDで生成 dotnet restore --locked-mode -r win-x64 sbom-tool generate -b ./sbom-output -bc . -pn kuju63/wt -pv 1.0.0 -nsb https://github.com/kuju63/wt/sbom/1.0.0 新しい依存関係の追加時 新しいNuGetパッケージを追加する際の手順： 依存関係を追加 dotnet add wt.cli/wt.cli.csproj package NewPackage ロックファイルを更新 dotnet restore --locked-mode SBOM生成をテスト sbom-tool generate -b ./test-sbom -bc . -pn kuju63/wt -pv test -nsb https://github.com/kuju63/wt/sbom/test jq '.packages[] | select(.name==\"NewPackage\")' ./test-sbom/_manifest/spdx_2.2/manifest.spdx.json リリース時に自動反映: リリースワークフローが自動的に新しい依存関係を含むSBOMを生成 トラブルシューティング よくある問題と解決方法 問題1: SBOM生成が失敗する 症状: Error: No packages found in the build directory 原因: 依存関係が復元されていない 解決方法: # 依存関係をリストア dotnet restore --locked-mode # SBOM生成を再実行 sbom-tool generate -b ./sbom-output -bc . -pn kuju63/wt -pv 1.0.0 -nsb https://github.com/kuju63/wt/sbom/1.0.0 問題2: GitHub API呼び出しが403 Forbiddenで失敗 症状: Error: Resource not accessible by integration 原因: GITHUB_TOKENの権限不足 解決方法: # .github/workflows/release.ymlで権限を設定 permissions: contents: write id-token: write 問題3: SBOMに一部の依存関係が含まれていない 症状: NuGetパッケージの一部がSBOMに表示されない 原因: プラットフォーム固有の依存関係が復元されていない 解決方法: # すべてのターゲットプラットフォームで復元 dotnet restore --locked-mode -r win-x64 dotnet restore --locked-mode -r linux-x64 dotnet restore --locked-mode -r linux-arm dotnet restore --locked-mode -r osx-arm64 # SBOM生成 sbom-tool generate -b ./sbom-output -bc . -pn kuju63/wt -pv 1.0.0 -nsb https://github.com/kuju63/wt/sbom/1.0.0 問題4: ワークフローがタイムアウトする 症状: GitHub Actionsが15分でタイムアウト 原因: 大規模な依存関係ツリー 解決方法: # キャッシュを有効化 - uses: actions/cache@v4 with: path: ~/.nuget/packages key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }} # タイムアウトを延長（最大60分） timeout-minutes: 30 デバッグ方法 詳細ログの有効化 # SBOM Tool詳細ログ sbom-tool generate \\ -b ./sbom-output \\ -bc . \\ -pn kuju63/wt \\ -pv 1.0.0 \\ -nsb https://github.com/kuju63/wt/sbom/1.0.0 \\ -v Diagnostic # ログレベル: Diagnostic, Information, Warning, Error # GitHub Actions詳細ログ - name: Generate SBOM run: sbom-tool generate ... env: ACTIONS_STEP_DEBUG: true SBOM内容の詳細確認 # すべてのパッケージ情報を表示 jq '.packages[]' wt-sbom.spdx.json # 特定パッケージの依存関係を表示 jq '.relationships[] | select(.spdxElementId | contains(\"System.CommandLine\"))' wt-sbom.spdx.json # ドキュメントメタデータを表示 jq '{version: .spdxVersion, name: .name, created: .creationInfo.created}' wt-sbom.spdx.json 追加リソース ドキュメント SPDX仕様 Microsoft SBOM Tool GitHub Dependency Submission API Package URL仕様 ツール SPDX Validator - SPDXフォーマット検証 OSV Scanner - 脆弱性スキャン Grype - 脆弱性検出 Dependency-Track - SBOMプラットフォーム コミュニティ Issue報告 Discussion サポート 質問や問題がある場合は、以下の方法でお問い合わせください： GitHub Issues: https://github.com/kuju63/wt/issues GitHub Discussions: https://github.com/kuju63/wt/discussions 最終更新: 2026-01-10"
  },
  "docs/installation.html": {
    "href": "docs/installation.html",
    "title": "Installation Guide | wt",
    "summary": "Installation Guide This guide will help you install the wt command-line tool for Git worktree management. System Requirements Before installing wt, ensure your system meets the following requirements: Operating System Minimum Version Architecture Windows Windows 10 x64 macOS macOS 11 (Big Sur) ARM64 (Apple Silicon) Linux Any modern distribution x64, ARM Prerequisites Git: Version 2.25 or later must be installed and available in your PATH To verify: git --version Terminal/Command Prompt: Access to a terminal or command prompt Download Download the latest release for your platform from the GitHub Releases page. Available Downloads Download the latest version from the releases page. Files are named with the version number: Platform Architecture File Pattern Windows x64 wt-v{version}-win-x64.zip macOS ARM64 wt-v{version}-osx-arm64.tar.gz Linux x64 wt-v{version}-linux-x64.tar.gz Linux ARM wt-v{version}-linux-arm.tar.gz Example: For version 0.0.3, the Linux x64 file would be wt-v0.0.3-linux-x64.tar.gz Installation Instructions Choose the installation method for your operating system: Windows Installation Download the wt-v{version}-win-x64.zip file from the releases page Extract the archive: Right-click the downloaded file and select \"Extract All...\" Choose a destination folder (e.g., C:\\Program Files\\wt) Add to PATH: Open System Properties → Environment Variables Under \"System variables\", find and select \"Path\" Click \"Edit\" and add the folder containing wt.exe Click \"OK\" to save Verify installation: wt --version macOS Installation Download the wt-v{version}-osx-arm64.tar.gz file from the releases page Extract and install: tar -xzf wt-v*-osx-arm64.tar.gz sudo mv wt /usr/local/bin/ sudo chmod +x /usr/local/bin/wt Verify installation: wt --version Linux Installation Download the appropriate file for your architecture: x64: wt-v{version}-linux-x64.tar.gz ARM: wt-v{version}-linux-arm.tar.gz Extract and install: tar -xzf wt-v*-linux-*.tar.gz sudo mv wt /usr/local/bin/ sudo chmod +x /usr/local/bin/wt Verify installation: wt --version Troubleshooting Command not found Symptom: After installation, running wt shows \"command not found\" or similar error. Solutions: Windows: Verify the installation folder is in your PATH. Restart your terminal after modifying PATH. macOS/Linux: Ensure /usr/local/bin is in your PATH. Run echo $PATH to verify. Try specifying the full path: /usr/local/bin/wt --version Restart your terminal or open a new terminal window Permission denied Symptom: Error message saying \"permission denied\" when trying to run wt. Solutions: macOS/Linux: Make the file executable: sudo chmod +x /usr/local/bin/wt Verify file ownership: ls -l /usr/local/bin/wt Try running with sudo: sudo wt --version (not recommended for regular use) Git not found Symptom: wt reports that Git is not installed or cannot be found. Solutions: Install Git from git-scm.com Windows: Ensure Git is added to PATH during installation macOS: Install via Homebrew: brew install git Linux: Install via package manager: sudo apt install git or sudo yum install git Verify Git installation: git --version Additional Help If you encounter other issues: Check the GitHub Issues for known problems Create a new issue with details about your environment and error messages Consult the Quick Start Guide for usage examples Next Steps Once installed, check out the Quick Start Guide to learn how to use wt effectively."
  },
  "docs/introduction.html": {
    "href": "docs/introduction.html",
    "title": "Introduction | wt",
    "summary": "Introduction"
  },
  "docs/ja/CONVENTIONAL_COMMITS.html": {
    "href": "docs/ja/CONVENTIONAL_COMMITS.html",
    "title": "Conventional Commits 規約 | wt",
    "summary": "Conventional Commits 規約 このプロジェクトでは、コミットメッセージに Conventional Commits 規約を採用しています。 公式仕様 公式サイト: https://www.conventionalcommits.org/ バージョン: 1.0.0 基本フォーマット <type>[optional scope]: <description> [optional body] [optional footer(s)] type (必須) コミットの種類を示します。以下のtypeを使用してください: feat: 新機能の追加 (MINOR version bump) fix: バグ修正 (PATCH version bump) docs: ドキュメントのみの変更 style: コードの意味に影響を与えない変更 (空白、フォーマット、セミコロン等) refactor: バグ修正や機能追加を伴わないコード変更 perf: パフォーマンス改善 test: テストの追加や修正 chore: ビルドプロセス、補助ツール、ライブラリの変更 (例: package.json更新) ci: CI設定ファイルやスクリプトの変更 (例: GitHub Actions) build: ビルドシステムや外部依存関係に影響する変更 scope (オプション) 変更の影響範囲を示します。このプロジェクトでは原則として使用しませんが、必要な場合のみ以下のように記述できます: feat(cli): add --version flag fix(worktree): handle invalid branch names description (必須) 変更内容を簡潔に説明します: 英語で記述すること 命令形・現在形を使用 (例: \"add\" not \"added\" or \"adds\") 小文字で開始 (最初の文字は小文字) 末尾にピリオドを付けない body (オプション) 変更の理由、以前の動作との違い、影響範囲などを説明します: description から1行空けて記述 複数行可能 Markdown形式可能 footer (オプション) Breaking changes、Issue参照を記述します: BREAKING CHANGE: 破壊的変更を示す (MAJOR version bump) Closes #123: Issueのクローズを示す 例 新機能 (feat) feat: add multi-platform binary distribution Implement GitHub Actions workflow to build binaries for Windows x64, Linux x64/ARM, and Mac ARM64. Closes #42 バグ修正 (fix) fix: prevent crash when branch name contains special characters Handle edge case where branch names with slashes cause path resolution errors. 破壊的変更 (BREAKING CHANGE) feat: change CLI argument format to kebab-case BREAKING CHANGE: All CLI arguments now use kebab-case instead of camelCase. Users must update scripts: `--outputFormat` → `--output-format` Migration guide: docs/migration/v2.0.md ドキュメント (docs) docs: update installation guide for macOS ARM64 CI/CD (ci) ci: add Codacy coverage upload to test workflow テスト (test) test: add integration tests for SBOM generation セマンティックバージョニングとの関係 Conventional Commitsは、自動バージョニングに使用されます: Commit Type Version Bump 例 fix: PATCH (0.0.X) 0.1.0 → 0.1.1 feat: MINOR (0.X.0) 0.1.0 → 0.2.0 BREAKING CHANGE: MAJOR (X.0.0) 0.1.0 → 1.0.0 その他 (docs, style, etc.) バージョン変更なし - 自動バージョニングの仕組み mainブランチへのマージ時、最新Gitタグを取得 前回リリース以降のコミットメッセージを解析 feat:, fix:, BREAKING CHANGE: の有無でバージョンを決定 新しいバージョンタグを作成し、GitHub Releaseを公開 コミットメッセージのチェック 将来的に、以下のツールを導入予定です: commitlint: コミットメッセージの形式チェック husky: Git hooksによるローカルバリデーション 現在は、手動でConventional Commits規約に従ってください。 参考資料 Conventional Commits 日本語翻訳 Semantic Versioning 2.0.0 GitHub - semantic-release 最終更新: 2026-01-05 担当者: Release Pipeline Team"
  },
  "docs/ja/user-guide.html": {
    "href": "docs/ja/user-guide.html",
    "title": "wt - Git Worktree 作成ツール ユーザーガイド | wt",
    "summary": "wt - Git Worktree 作成ツール ユーザーガイド バージョン: 1.0.0 最終更新: 2026-01-03 目次 概要 インストール 基本的な使い方 コマンドリファレンス 使用例 トラブルシューティング FAQ 概要 wt は Git worktree の作成を簡単にする CLI ツールです。複雑な Git コマンドを覚える必要なく、ブランチ名を指定するだけで、新しいブランチの作成と worktree の追加を一度に実行できます。 主な機能 シンプルなコマンド: wt create <ブランチ名> だけで worktree を作成 自動ブランチ作成: 指定したブランチが存在しない場合は自動的に作成 エディター起動: worktree 作成後、指定したエディターを自動起動（オプション） カスタムパス: worktree の作成場所を自由に指定可能 エラーメッセージ: わかりやすいエラーメッセージと解決策を表示 クロスプラットフォーム: Windows、macOS、Linux で動作 インストール 前提条件 Git 2.5 以上 .NET 10 Runtime インストール手順 macOS / Linux # リポジトリをクローン git clone https://github.com/your-org/wt.git cd wt # ビルド dotnet build -c Release # インストール（オプション） sudo cp wt.cli/bin/Release/net10.0/wt.cli /usr/local/bin/wt sudo chmod +x /usr/local/bin/wt Windows # リポジトリをクローン git clone https://github.com/your-org/wt.git cd wt # ビルド dotnet build -c Release # インストール（オプション） # wt.cli/bin/Release/net10.0/wt.cli.exe を PATH に追加 インストール確認 wt --help 正常にインストールされていれば、ヘルプメッセージが表示されます。 基本的な使い方 最もシンプルな使い方 wt create <ブランチ名> これだけで、以下が自動的に実行されます： 現在のブランチをベースに新しいブランチを作成 ../worktrees/<ブランチ名> に worktree を追加 作成された worktree のパスを表示 例 # feature-login という名前のブランチと worktree を作成 wt create feature-login 実行結果： ✓ Created branch 'feature-login' from 'main' ✓ Added worktree at: /Users/yourname/projects/worktrees/feature-login → Next: cd /Users/yourname/projects/worktrees/feature-login コマンドリファレンス コマンド構文 wt create <ブランチ名> [オプション] 必須引数 <ブランチ名> 作成する新しいブランチの名前を指定します。 制約: Git の命名規則に準拠（英数字、-、_、/ のみ） 例: feature-login, bugfix/issue-123, user_story_1 オプション --base, -b <ベースブランチ> 新しいブランチを作成する際のベースとなるブランチを指定します。 デフォルト: 現在のブランチ 例: --base main, -b develop wt create hotfix-urgent --base production --path, -p <パス> worktree を作成する場所を指定します。 デフォルト: ../worktrees/<ブランチ名> 指定可能: 絶対パスまたは相対パス 例: --path ~/projects/my-feature, -p /tmp/test-worktree wt create experiment --path ~/experiments/test-feature --editor, -e <エディター> worktree 作成後に自動起動するエディターを指定します。 指定可能な値: vscode, vim, emacs, nano, idea デフォルト: なし（エディターを起動しない） 例: --editor vscode, -e vim wt create feature-ui --editor vscode --checkout-existing 既存のブランチが存在する場合、そのブランチをチェックアウトします。 型: フラグ（値なし） デフォルト: false（エラーを表示） wt create existing-branch --checkout-existing --output, -o <形式> 出力形式を指定します。 指定可能な値: human（人間可読）、json（JSON形式） デフォルト: human 例: --output json, -o json wt create api-v2 --output json --verbose, -v 詳細な診断情報を出力します。 型: フラグ（値なし） デフォルト: false wt create debug-test --verbose --help, -h ヘルプメッセージを表示します。 wt --help wt create --help 使用例 例1: 基本的な worktree 作成 現在のブランチをベースに、デフォルトの場所に worktree を作成します。 wt create feature-authentication 実行結果: ✓ Created branch 'feature-authentication' from 'main' ✓ Added worktree at: /Users/dev/projects/worktrees/feature-authentication → Next: cd /Users/dev/projects/worktrees/feature-authentication 例2: ベースブランチを指定 develop ブランチをベースに worktree を作成します。 wt create feature-payment --base develop 例3: エディターを自動起動 worktree 作成後、VS Code を自動起動します。 wt create feature-dashboard --editor vscode 実行結果: ✓ Created branch 'feature-dashboard' from 'main' ✓ Added worktree at: /Users/dev/projects/worktrees/feature-dashboard ✓ Launched VS Code 例4: カスタムパスに作成 ホームディレクトリ配下の任意の場所に worktree を作成します。 wt create experiment --path ~/experiments/feature-x 例5: 既存ブランチをチェックアウト 既に存在するブランチで worktree を作成します。 wt create existing-feature --checkout-existing 例6: JSON 形式で出力 スクリプトから利用しやすい JSON 形式で結果を出力します。 wt create api-endpoint --output json 実行結果: { \"success\": true, \"worktree\": { \"path\": \"/Users/dev/projects/worktrees/api-endpoint\", \"branch\": \"api-endpoint\", \"baseBranch\": \"main\", \"createdAt\": \"2026-01-03T14:30:00Z\" }, \"editorLaunched\": false } 例7: 詳細情報を表示 トラブルシューティング用に詳細な実行ログを出力します。 wt create test-branch --verbose 実行結果: [DEBUG] Checking for Git repository... [DEBUG] Found Git repository at: /Users/dev/projects/my-repo [DEBUG] Current branch: main [DEBUG] Checking if branch 'test-branch' exists... [DEBUG] Branch 'test-branch' does not exist [DEBUG] Creating branch 'test-branch' from 'main'... [DEBUG] Executing: git branch test-branch main [DEBUG] Creating worktree at: /Users/dev/projects/worktrees/test-branch [DEBUG] Executing: git worktree add /Users/dev/projects/worktrees/test-branch test-branch ✓ Created branch 'test-branch' from 'main' ✓ Added worktree at: /Users/dev/projects/worktrees/test-branch → Next: cd /Users/dev/projects/worktrees/test-branch 例8: 複数オプションを組み合わせ ベースブランチ、カスタムパス、エディター起動を同時に指定します。 wt create hotfix-urgent --base production --path ~/hotfixes/urgent --editor vim トラブルシューティング エラー: Git が見つかりません エラーメッセージ: ✗ Error: Git not found in PATH → Solution: Install Git 2.5 or later and ensure it's in your PATH 解決方法: Git をインストールします macOS: brew install git Ubuntu/Debian: sudo apt install git Windows: git-scm.com からインストーラーをダウンロード Git が PATH に含まれていることを確認 git --version エラー: Git リポジトリではありません エラーメッセージ: ✗ Error: Not a Git repository → Solution: Run this command from within a Git repository, or run 'git init' to create one 解決方法: Git リポジトリ内で実行していることを確認 git status まだリポジトリでない場合は初期化 git init エラー: ブランチが既に存在します エラーメッセージ: ✗ Error: Branch 'feature-x' already exists → Solution: Use --checkout-existing to checkout the existing branch, or choose a different branch name 解決方法: オプション1: 既存ブランチをチェックアウト wt create feature-x --checkout-existing オプション2: 別のブランチ名を使用 wt create feature-x-v2 エラー: 無効なブランチ名 エラーメッセージ: ✗ Error: Invalid branch name '-invalid' → Solution: Branch names must start with alphanumeric character and contain only alphanumeric, '-', '_', '/' characters 解決方法: Git の命名規則に従ったブランチ名を使用してください： ✅ 正しい例: feature-login, bugfix/issue-123, user_story_1 ❌ 間違った例: -invalid, feature..test, branch name (スペース含む) エラー: パスに書き込み権限がありません エラーメッセージ: ✗ Error: No write permission to path '/protected/directory' → Solution: Choose a different path or check directory permissions 解決方法: 書き込み可能な別のパスを指定 wt create test-branch --path ~/projects/worktrees/test-branch ディレクトリの権限を確認・修正 ls -ld /protected/directory chmod u+w /protected/directory # 必要に応じて エラー: エディターが見つかりません エラーメッセージ: ⚠ Warning: Editor 'vscode' not found in PATH ✓ Created branch 'test' from 'main' ✓ Added worktree at: /Users/dev/projects/worktrees/test 注意: これは警告のみで、worktree の作成は正常に完了しています。 解決方法: エディターが PATH に含まれているか確認 which code # VS Code の場合 which vim # Vim の場合 VS Code の場合は PATH に追加 VS Code を開く Command Palette (Cmd+Shift+P または Ctrl+Shift+P) を開く \"Shell Command: Install 'code' command in PATH\" を実行 エラー: ディスク容量不足 エラーメッセージ: ✗ Error: Insufficient disk space → Solution: Free up disk space or choose a different location with more available space 解決方法: ディスク容量を確認 df -h 不要なファイルを削除してスペースを確保 別のディスクにパスを指定 wt create test --path /mnt/external/worktrees/test FAQ Q1: worktree を削除するにはどうすればよいですか？ A: Git の標準コマンドを使用します。 # worktree を削除 git worktree remove <worktree-path> # または、ディレクトリを直接削除 rm -rf <worktree-path> git worktree prune # クリーンアップ Q2: 作成した worktree の一覧を確認できますか？ A: Git の標準コマンドで確認できます。 git worktree list Q3: デフォルトのエディターを設定できますか？ A: 現在のバージョンでは、デフォルトのエディター設定機能はありません。毎回 --editor オプションで指定する必要があります。 将来のバージョンで設定ファイル機能を追加予定です。 Q4: 複数の worktree を同時に作成できますか？ A: 現在のバージョンでは、一度に1つの worktree しか作成できません。 複数作成する場合は、コマンドを繰り返し実行してください： wt create feature-1 wt create feature-2 wt create feature-3 Q5: worktree のパスのデフォルト値を変更できますか？ A: 現在のバージョンでは、デフォルトパス (../worktrees/<ブランチ名>) は固定です。 毎回カスタムパスを指定する場合は、シェルエイリアスを使用すると便利です： # ~/.bashrc または ~/.zshrc に追加 alias wtc='wt create --path ~/my-worktrees' 使用例： wtc feature-login # ~/my-worktrees/feature-login に作成される Q6: Windows でパス区切り文字はどうなりますか？ A: wt は自動的にプラットフォームに応じた適切なパス区切り文字を使用します。 Windows: \\ (バックスラッシュ) macOS/Linux: / (スラッシュ) ユーザーはどちらを指定しても正常に動作します。 Q7: リモートブランチから worktree を作成できますか？ A: 現在のバージョンでは、ローカルブランチのみサポートしています。 リモートブランチから作成する場合は、まずローカルにチェックアウトしてから使用してください： git checkout -b feature-remote origin/feature-remote wt create feature-remote --checkout-existing Q8: CI/CD パイプラインで使用できますか？ A: はい、--output json オプションを使用すると、スクリプトから扱いやすくなります。 result=$(wt create test-branch --output json) echo $result | jq '.worktree.path' Q9: worktree 内で別の worktree を作成できますか？ A: 技術的には可能ですが、推奨しません。 worktree は常にメインリポジトリから作成することをお勧めします。 Q10: ライセンスは何ですか？ A: このプロジェクトは MIT ライセンスの下で公開されています。 詳細は LICENSE ファイルを参照してください。 サポート 問題が解決しない場合は、以下の方法でサポートを受けることができます： GitHub Issues: Issues ページ でバグ報告や機能リクエストを投稿 ドキュメント: README.md を参照 コミュニティ: GitHub Discussions で質問 関連リンク Git Worktree 公式ドキュメント GitHub リポジトリ 最終更新: 2026-01-03 バージョン: 1.0.0"
  },
  "index.html": {
    "href": "index.html",
    "title": "wt - Git Worktree Manager | wt",
    "summary": "wt - Git Worktree Manager A modern CLI tool to simplify Git worktree management. Create worktrees with a single command and optionally launch your favorite editor. ✨ Features Simple worktree creation: wt create feature-branch List all worktrees: Display all worktrees with their branches in a beautiful table Smart defaults: Automatically creates worktrees in ../wt-<branch> directory Editor integration: Auto-launch VS Code, Vim, Emacs, or IntelliJ IDEA Custom paths: Specify where to create worktrees Multiple output formats: Human-readable or JSON for automation Cross-platform: Works on macOS, Linux, and Windows \uD83D\uDE80 Quick Start Installation Get started in minutes! Download the latest release for your platform: \uD83D\uDCE5 Installation Guide Your First Worktree # Create a new feature branch worktree wt create feature-login # List all worktrees wt list \uD83D\uDCD6 Quick Start Guide \uD83D\uDCDA Documentation For Users Installation Guide - Install wt on your system Quick Start Guide - Get up and running in 5 minutes Command Reference - Detailed command documentation with examples \uD83D\uDCA1 Quick Search: Use the search bar above to find specific commands, options, or topics instantly. For Developers API Reference - Complete API documentation Contributing Guide - Help improve wt \uD83D\uDCA1 Why Use Worktrees? Git worktrees allow you to have multiple working directories from a single repository: Work on multiple features simultaneously without switching branches Review pull requests without stashing your current work Run different versions side-by-side for testing Keep your workspace organized with parallel directories wt makes managing worktrees simple and intuitive. \uD83C\uDFAF Example Workflow # Start working on a new feature wt create feature-user-auth --editor vscode # In another terminal, fix a bug wt create bugfix-login-timeout --base main # Check all your worktrees wt list Output: ┌─────────────────────────────────┬──────────────────────┬─────────┐ │ Path │ Branch │ Status │ ├─────────────────────────────────┼──────────────────────┼─────────┤ │ /projects/wt │ main │ active │ │ /projects/wt-feature-user-auth │ feature-user-auth │ active │ │ /projects/wt-bugfix-login │ bugfix-login-timeout │ active │ └─────────────────────────────────┴──────────────────────┴─────────┘ \uD83D\uDD17 Links GitHub Repository Report an Issue Release Notes \uD83D\uDCC4 License MIT License"
  },
  "specs/001-create-worktree/checklists/requirements.html": {
    "href": "specs/001-create-worktree/checklists/requirements.html",
    "title": "Specification Quality Checklist: Git Worktree 作成コマンド | wt",
    "summary": "Specification Quality Checklist: Git Worktree 作成コマンド Purpose: Validate specification completeness and quality before proceeding to planning Created: 2026-01-03 Feature: spec.md Content Quality [x] No implementation details (languages, frameworks, APIs) [x] Focused on user value and business needs [x] Written for non-technical stakeholders [x] All mandatory sections completed Requirement Completeness [x] No [NEEDS CLARIFICATION] markers remain [x] Requirements are testable and unambiguous [x] Success criteria are measurable [x] Success criteria are technology-agnostic (no implementation details) [x] All acceptance scenarios are defined [x] Edge cases are identified [x] Scope is clearly bounded [x] Dependencies and assumptions identified Feature Readiness [x] All functional requirements have clear acceptance criteria [x] User scenarios cover primary flows [x] Feature meets measurable outcomes defined in Success Criteria [x] No implementation details leak into specification Validation Results Status: ✅ PASSED - All quality checks passed Details: All 14 checklist items validated successfully Specification is ready for /speckit.clarify or /speckit.plan No issues identified Validated: 2026-01-03 Notes Specification quality is excellent. Ready to proceed to planning phase."
  },
  "specs/001-create-worktree/contracts/cli-interface.html": {
    "href": "specs/001-create-worktree/contracts/cli-interface.html",
    "title": "CLI Interface Contract: Worktree Create Command | wt",
    "summary": "CLI Interface Contract: Worktree Create Command Feature: 001-create-worktree Date: 2026-01-03 Version: 1.0.0 Command Syntax wt create <branch-name> [OPTIONS] Note: wt自体が「worktree tool」を意味するため、worktreeサブコマンドは省略しています。シンプルで使いやすいCLIを実現します。 Arguments Required <branch-name>: 作成する新しいブランチ名 Type: string Validation: Git命名規則に準拠（英数字、-、_、/のみ） Example: feature-x, bugfix/issue-123, user_story_1 Options --base, -b ベースブランチの指定（デフォルト: 現在のブランチ） Type: string Default: 現在のブランチ Example: --base main または -b develop --path, -p Worktreeを作成するパス（デフォルト: ../worktrees/<branch-name>） Type: string (絶対パスまたは相対パス) Default: ../worktrees/<branch-name> Example: --path ~/projects/my-worktree または -p ../feature-branch --editor, -e Worktree作成後に起動するエディター Type: string (enum: vscode|vim|emacs|nano|idea) Default: なし（エディターを起動しない） Example: --editor vscode または -e vim --checkout-existing 既存ブランチが存在する場合、それをチェックアウトする Type: boolean flag Default: false Example: --checkout-existing --output, -o 出力形式の指定 Type: string (enum: human|json) Default: human Example: --output json または -o json --verbose, -v 詳細な診断情報を出力 Type: boolean flag Default: false Example: --verbose または -v --help, -h ヘルプメッセージを表示 Type: boolean flag Example: --help または -h Usage Examples Example 1: 基本的な使用方法 $ wt create feature-login ✓ Created branch 'feature-login' from 'main' ✓ Added worktree at: /Users/dev/projects/worktrees/feature-login → Next: cd /Users/dev/projects/worktrees/feature-login Example 2: ベースブランチを指定 $ wt create hotfix-123 --base production ✓ Created branch 'hotfix-123' from 'production' ✓ Added worktree at: /Users/dev/projects/worktrees/hotfix-123 → Next: cd /Users/dev/projects/worktrees/hotfix-123 Example 3: エディターを起動 $ wt create feature-ui --editor vscode ✓ Created branch 'feature-ui' from 'main' ✓ Added worktree at: /Users/dev/projects/worktrees/feature-ui ✓ Launched VS Code Example 4: カスタムパスを指定 $ wt create experiment --path ~/experiments/test-feature ✓ Created branch 'experiment' from 'main' ✓ Added worktree at: /Users/dev/experiments/test-feature → Next: cd /Users/dev/experiments/test-feature Example 5: JSON出力 $ wt create api-v2 --output json { \"success\": true, \"worktree\": { \"path\": \"/Users/dev/projects/worktrees/api-v2\", \"branch\": \"api-v2\", \"baseBranch\": \"main\", \"createdAt\": \"2026-01-03T13:15:30Z\" }, \"editorLaunched\": false } Example 6: 既存ブランチをチェックアウト $ wt create feature-x ✗ Error: Branch 'feature-x' already exists → Solution: Use --checkout-existing to checkout the existing branch $ wt create feature-x --checkout-existing ✓ Checked out existing branch 'feature-x' ✓ Added worktree at: /Users/dev/projects/worktrees/feature-x → Next: cd /Users/dev/projects/worktrees/feature-x Example 7: Verbose モード $ wt create test --verbose [DEBUG] Checking for Git repository... [DEBUG] Found Git repository at: /Users/dev/projects/my-repo [DEBUG] Current branch: main [DEBUG] Checking if branch 'test' exists... [DEBUG] Branch 'test' does not exist [DEBUG] Creating branch 'test' from 'main'... [DEBUG] Executing: git branch test main [DEBUG] Creating worktree at: /Users/dev/projects/worktrees/test [DEBUG] Executing: git worktree add /Users/dev/projects/worktrees/test test ✓ Created branch 'test' from 'main' ✓ Added worktree at: /Users/dev/projects/worktrees/test → Next: cd /Users/dev/projects/worktrees/test Exit Codes Code Meaning Description 0 Success Worktree created successfully 1 General Error Unspecified error occurred 2 Invalid Arguments Command-line arguments are invalid 10 Git Not Found Git is not installed or not in PATH 11 Not Git Repository Current directory is not a Git repository 12 Git Command Failed Git command execution failed 20 Invalid Branch Name Branch name doesn't follow Git naming rules 21 Branch Exists Branch already exists and --checkout-existing not specified 30 Worktree Exists Worktree with same name already exists 31 Invalid Path Specified path is invalid 32 Path Not Writable Don't have write permissions to target directory 40 Disk Space Low Insufficient disk space 50 Editor Not Found Specified editor is not found (warning, not fatal) Error Handling Standard Error Format (Human) ✗ Error: <Error Message> → Solution: <Suggested Solution> Additional Details: <Optional Details> JSON Error Format { \"success\": false, \"error\": { \"code\": \"BR002\", \"message\": \"Branch 'feature-x' already exists\", \"solution\": \"Use --checkout-existing to checkout the existing branch\", \"details\": \"Branch 'feature-x' was created on 2026-01-02 at commit abc123\" }, \"warnings\": [] } Environment Variables WT_DEFAULT_WORKTREE_PATH デフォルトのworktreeパスを設定 Type: string Default: ../worktrees Example: export WT_DEFAULT_WORKTREE_PATH=~/my-worktrees WT_DEFAULT_EDITOR デフォルトのエディターを設定 Type: string Default: なし Example: export WT_DEFAULT_EDITOR=vscode Validation Rules Branch Name Validation 空文字列ではない 以下の文字のみ: a-zA-Z0-9, -, _, / 以下で開始しない: -, . 以下を含まない: .., @{, \\, スペース、制御文字 Path Validation 空文字列ではない 親ディレクトリが存在する 書き込み権限がある 十分なディスク容量がある（最低100MB） Editor Validation プリセットまたはカスタムコマンドのいずれか カスタムコマンドは実行可能ファイルとしてPATHに存在 Performance Expectations Operation Target Time Notes バリデーション < 100ms 入力チェック Gitリポジトリ確認 < 200ms .gitディレクトリ検索 ブランチ作成 < 1s Gitコマンド実行 Worktree追加 < 2s ファイルコピー含む エディター起動 < 1s プロセス起動 Total < 5s 通常のケース Compatibility Minimum Requirements Git 2.5+ (git worktree サポート) 100MB ディスク空き容量 Note: Self-contained deployment（ワンバイナリ）として配布するため、.NET Runtimeのインストールは不要です。 Supported Platforms ✅ Windows 10+ ✅ macOS 11+ ✅ Linux (Ubuntu 20.04+, その他主要ディストリビューション) Supported Editors ✅ Visual Studio Code ✅ Vim ✅ Emacs ✅ Nano ✅ IntelliJ IDEA Security Considerations Command Injection Prevention: ユーザー入力はサニタイズされ、Gitコマンドに直接渡されない Path Traversal Prevention: パスは正規化され、許可されたディレクトリ内に制限される Validation: すべての入力は厳格にバリデーションされる Future Extensions (Out of Scope for v1.0) wt list: 既存worktreeの一覧表示 wt remove <branch>: Worktreeの削除 wt switch <branch>: Worktree間の切り替え wt status: すべてのworktreeのステータス表示 Design Philosophy: wt自体がworktree管理ツールであるため、worktreeサブコマンドグループは不要。すべてのコマンドはトップレベルに配置し、シンプルで覚えやすいCLIを実現します。 Changelog 1.0.0 (2026-01-03) Initial specification Basic worktree creation Editor integration Cross-platform support"
  },
  "specs/001-create-worktree/data-model.html": {
    "href": "specs/001-create-worktree/data-model.html",
    "title": "Data Model: Git Worktree 作成コマンド | wt",
    "summary": "Data Model: Git Worktree 作成コマンド Feature: 001-create-worktree Date: 2026-01-03 Source: spec.md Core Entities 1. WorktreeInfo Worktreeの情報を表現するモデル。 Properties: Path (string): worktreeの絶対パス Branch (string): 関連するブランチ名 BaseBranch (string): ベースブランチ名 CreatedAt (DateTime): 作成日時 IsActive (bool): アクティブかどうか Relationships: 1つのWorktreeは1つのBranchに関連付けられる Validation Rules: Pathは有効な絶対パスでなければならない Branchは空文字列ではない BaseBranchは空文字列ではない State Transitions: [Not Exists] --create--> [Active] --remove--> [Removed] 2. BranchInfo Gitブランチの情報を表現するモデル。 Properties: Name (string): ブランチ名 BaseBranch (string, optional): ベースブランチ名（nullの場合は現在のブランチ） Exists (bool): 既に存在するか IsRemote (bool): リモートブランチか Validation Rules: Nameは Git命名規則に準拠（英数字、-、_、/のみ） Nameは以下で開始してはならない: -、. Nameに以下を含めてはならない: ..、@{、\\、スペース Validation Logic: private static readonly Regex BranchNamePattern = new(@\"^[a-zA-Z0-9][a-zA-Z0-9/_-]*$\", RegexOptions.Compiled); public bool IsValidBranchName(string name) { if (string.IsNullOrWhiteSpace(name)) return false; if (name.Contains(\"..\") || name.Contains(\"@{\")) return false; return BranchNamePattern.IsMatch(name); } 3. EditorConfig エディター設定を表現するモデル。 Properties: EditorType (EditorType enum): エディターの種類 Command (string): 実行コマンド Arguments (string): コマンド引数テンプレート IsAvailable (bool): エディターが利用可能か EditorType Enum: public enum EditorType { VSCode, Vim, Emacs, Nano, IntelliJIDEA } Preset Examples: EditorType Command Arguments VSCode code {path} Vim vim {path} Emacs emacs {path} Nano nano {path} IntelliJIDEA idea {path} Validation Rules: Commandは空文字列ではない Argumentsには{path}プレースホルダーを含む必要がある 4. CommandResult<T> コマンド実行結果を表現するジェネリックモデル（Resultパターン）。 Properties: Success (bool): 成功したか Data (T, optional): 成功時のデータ Error (ErrorInfo, optional): エラー情報 Warnings (List<string>): 警告メッセージ ErrorInfo: Code (string): エラーコード Message (string): エラーメッセージ Solution (string): 解決策の提案 Details (string, optional): 詳細情報（verboseモード用） Usage Pattern: var result = await worktreeService.CreateAsync(options); if (result.Success) { Console.WriteLine($\"Worktree created: {result.Data.Path}\"); } else { Console.Error.WriteLine($\"Error: {result.Error.Message}\"); Console.Error.WriteLine($\"Solution: {result.Error.Solution}\"); } 5. CreateWorktreeOptions Worktree作成オプションを表現するモデル。 Properties: BranchName (string, required): 作成するブランチ名 BaseBranch (string, optional): ベースブランチ（nullの場合は現在のブランチ） WorktreePath (string, optional): worktreeパス（nullの場合はデフォルト） EditorType (EditorType, optional): 起動するエディター CustomEditorCommand (string, optional): カスタムエディターコマンド ForceCheckout (bool): 既存ブランチを強制チェックアウトするか OutputFormat (OutputFormat enum): 出力形式（Human/Json） Verbose (bool): 詳細出力を有効にするか OutputFormat Enum: public enum OutputFormat { Human, Json } Validation Rules: BranchNameは必須かつ有効な名前 WorktreePathが指定された場合は有効なパスでなければならない EditorTypeとCustomEditorCommandは排他的（両方指定はエラー） Data Flow Worktree作成フロー User Input (BranchName + Options) ↓ CreateWorktreeOptions (バリデーション) ↓ WorktreeService ├→ GitService: リポジトリチェック ├→ GitService: ブランチ存在確認 ├→ BranchInfo: ブランチ情報作成 ├→ GitService: ブランチ作成 ├→ GitService: worktree追加 ├→ WorktreeInfo: worktree情報作成 └→ EditorService: エディター起動 (optional) ↓ CommandResult<WorktreeInfo> ↓ OutputFormatter (Human/Json) ↓ Console Output Error Codes エラーコードの体系的な定義。 Code Category Message Solution GIT001 Git Git not found Install Git 2.5 or later GIT002 Git Not a git repository Run command in a git repository or run 'git init' GIT003 Git Git command failed Check git status and try again BR001 Branch Invalid branch name Use only alphanumeric, -, _, / characters BR002 Branch Branch already exists Use --checkout-existing to checkout existing branch WT001 Worktree Worktree already exists Choose a different branch name or remove existing worktree WT002 Worktree Invalid worktree path Specify a valid absolute or relative path WT003 Worktree Path not writable Check directory permissions FS001 FileSystem Disk space low Free up disk space (need at least 100MB) ED001 Editor Editor not found Check editor installation or use a different editor Performance Considerations Memory Usage 各エンティティのメモリフットプリント（概算）: WorktreeInfo: ~200 bytes BranchInfo: ~150 bytes EditorConfig: ~100 bytes CommandResult<WorktreeInfo>: ~500 bytes Total for single operation: < 1KB（目標の100MB内に十分収まる） Caching Strategy 現時点ではキャッシングは実装しません（シンプルさ優先）。将来的な拡張として検討可能： エディタープリセットのキャッシュ Git設定のキャッシュ Extensibility 将来的な拡張を考慮した設計： Additional Editor Support: EditorPresetsクラスに追加するだけ Remote Worktrees: WorktreeInfoにRemoteInfoプロパティを追加 Worktree Templates: 新しいTemplateInfoエンティティを追加 Summary このデータモデルは以下の要件を満たします： ✅ 明確な責任分離（Single Responsibility） ✅ バリデーションルールの明示 ✅ エラーハンドリングの体系化 ✅ 拡張性の確保 ✅ パフォーマンス目標との整合性"
  },
  "specs/001-create-worktree/plan.html": {
    "href": "specs/001-create-worktree/plan.html",
    "title": "Implementation Plan: Git Worktree 作成コマンド | wt",
    "summary": "Implementation Plan: Git Worktree 作成コマンド Branch: 001-create-worktree | Date: 2026-01-03 | Spec: spec.md Input: Feature specification from /specs/001-create-worktree/spec.md Note: This template is filled in by the /speckit.plan command. See .specify/templates/commands/plan.md for the execution workflow. Summary Git worktree の作成を1コマンドで実行できるCLIツールを開発します。開発者はブランチ名を指定するだけで、新しいブランチが作成され、自動的に git worktree として登録されます（wt create <branch-name>）。オプションでエディターの自動起動や worktree パスのカスタマイズが可能です。これにより、複雑な git worktree コマンドを覚える必要がなくなり、AIコードエージェントとの並列開発や手作業との併用が容易になります。 Technical Approach: C# .NET 10を使用したクロスプラットフォームCLIツールとして実装。System.Diagnostics.Processを使用してgitコマンドを実行し、標準ライブラリのみで実装します（最小限の依存関係）。 Technical Context Language/Version: C# .NET 10 (既存プロジェクトに統合) Primary Dependencies: System.CommandLine (CLI フレームワーク), System.IO.Abstractions (パス操作の抽象化), Newtonsoft.Json または System.Text.Json (JSON出力) Storage: N/A (ファイルシステムのみ使用) Testing: xUnit (既存プロジェクトで使用中), FluentAssertions (アサーション), Moq (モック) Target Platform: Windows, macOS, Linux (クロスプラットフォーム) Project Type: single (CLIツール) Performance Goals: コマンド実行開始から完了まで 5秒以内（通常のGit操作含む） worktree作成 + エディター起動まで 30秒以内（ユーザー体験目標） メモリ使用量 < 100MB（CLIツールとして軽量） Constraints: Git 2.5以上が必要（git worktree サポート） クロスプラットフォーム対応必須（憲章 II） 外部依存関係は最小限（憲章 V） TDDアプローチ必須（憲章 VI） Scale/Scope: 単一ユーザー・単一リポジトリでの使用 同時実行想定なし（ローカルCLI） worktree数の制限なし（Gitの制限に依存） Constitution Check GATE: Must pass before Phase 0 research. Re-check after Phase 1 design. Principle Requirement Status Notes I. Developer Usability CLI優先、明瞭な操作 ✅ PASS コマンド構文はシンプル(wt create <branch>形式)、ヘルプ完備、JSON/人間可読出力対応 I. Developer Usability エラーメッセージに解決策 ✅ PASS FR-010で明記、verboseモードで詳細診断 II. Cross-Platform Windows/macOS/Linux対応 ✅ PASS .NET 10はクロスプラットフォーム、System.IO.Abstractionsでパス抽象化 II. Cross-Platform OS固有機能に非依存 ✅ PASS Gitコマンド実行のみ、プラットフォーム固有処理を分離 III. Clean & Secure セキュアなコード ✅ PASS 機密情報ハードコードなし、入力バリデーション実装（FR-008） III. Clean & Secure 静的解析 ✅ PASS .NETの標準アナライザー使用 IV. Documentation 日本語ドキュメント優先 ✅ PASS README、ガイドは日本語で作成 IV. Documentation ADRで技術決定記録 ✅ PASS 技術選択（C#、System.CommandLine等）をADRとして記録予定 V. Minimal Dependencies 最小限の依存 ✅ PASS System.CommandLine、System.IO.Abstractions、JSONライブラリのみ（3つ） V. Minimal Dependencies 標準ライブラリ優先 ✅ PASS System.Diagnostics.Process等の標準ライブラリを最大限活用 VI. Testing TDD必須 ✅ PASS xUnit + FluentAssertions + Moq でテスト先行開発 VI. Testing CI/CDでテスト自動化 ⚠️ DEFERRED CI/CDパイプラインは別タスクで設定（プロジェクト全体の設定） Overall Status: ✅ PASS - All gates passed. 1 item deferred to project-level task. Justifications: None required - no violations. Project Structure Documentation (this feature) specs/001-create-worktree/ ├── plan.md # This file (/speckit.plan command output) ├── research.md # Phase 0 output (/speckit.plan command) ├── data-model.md # Phase 1 output (/speckit.plan command) ├── quickstart.md # Phase 1 output (/speckit.plan command) ├── contracts/ # Phase 1 output (/speckit.plan command) │ └── cli-interface.md # CLIコマンドインターフェース仕様 └── tasks.md # Phase 2 output (/speckit.tasks command - NOT created by /speckit.plan) Source Code (repository root) wt.cli/ # 既存CLIプロジェクト ├── Program.cs # エントリーポイント ├── Commands/ # 新規: コマンド実装 │ ├── Worktree/ # worktreeコマンドグループ │ │ ├── CreateCommand.cs # 'worktree create' コマンド │ │ ├── WorktreeOptions.cs # コマンドオプション定義 │ │ └── WorktreeHandler.cs # コマンドハンドラー │ └── BaseCommand.cs # 共通コマンド基底クラス ├── Services/ # 新規: ビジネスロジック │ ├── Git/ │ │ ├── IGitService.cs # Gitサービスインターフェース │ │ ├── GitService.cs # Git操作実装 │ │ └── GitCommandExecutor.cs # Gitコマンド実行 │ ├── Worktree/ │ │ ├── IWorktreeService.cs # Worktreeサービスインターフェース │ │ ├── WorktreeService.cs # Worktree作成ロジック │ │ └── WorktreeValidator.cs # バリデーション │ ├── Editor/ │ │ ├── IEditorService.cs # エディターサービスインターフェース │ │ ├── EditorService.cs # エディター起動ロジック │ │ └── EditorPresets.cs # エディタープリセット定義 │ └── Output/ │ ├── IOutputFormatter.cs # 出力フォーマッターIF │ ├── JsonFormatter.cs # JSON出力 │ └── HumanFormatter.cs # 人間可読出力 ├── Models/ # 新規: データモデル │ ├── WorktreeInfo.cs # Worktree情報 │ ├── BranchInfo.cs # ブランチ情報 │ ├── EditorConfig.cs # エディター設定 │ └── CommandResult.cs # コマンド実行結果 └── Utils/ # 新規: ユーティリティ ├── PathHelper.cs # パス操作ヘルパー └── ValidationHelper.cs # バリデーションヘルパー wt.tests/ # 既存テストプロジェクト ├── Commands/ # 新規: コマンドテスト │ └── Worktree/ │ └── CreateCommandTests.cs ├── Services/ # 新規: サービステスト │ ├── Git/ │ │ └── GitServiceTests.cs │ ├── Worktree/ │ │ ├── WorktreeServiceTests.cs │ │ └── WorktreeValidatorTests.cs │ ├── Editor/ │ │ └── EditorServiceTests.cs │ └── Output/ │ └── OutputFormatterTests.cs ├── Integration/ # 新規: 統合テスト │ └── WorktreeE2ETests.cs # E2Eテスト └── TestHelpers/ # 新規: テストヘルパー ├── MockGitRepository.cs # Gitリポジトリモック └── TestFixtures.cs # テストフィクスチャ Structure Decision: 既存の単一プロジェクト構造を拡張します。Commands、Services、Models、Utilsディレクトリを追加し、機能ごとに明確に分離します。テストプロジェクトも同様の構造で対応するテストを配置します。この構造により、TDDアプローチを実践しやすく、将来的な拡張も容易になります。 Phase 0: Research (Complete) Status: ✅ Complete Output: research.md Research Areas Covered CLI Framework Selection: System.CommandLine選定理由とメリット Git Command Execution: Process wrapperパターン Cross-Platform Path Handling: System.IO.Abstractionsの活用 Editor Detection Strategy: プリセット + PATH検索 Output Formatting: JSON/Human-readable出力 Error Handling Pattern: Result<T>パターン Testing Strategy: Unit/Integration/E2E 3層アプローチ Cross-Platform Considerations: プラットフォーム固有処理の分離 Performance Optimization: 同期処理、最小限のディスク操作 Security Considerations: 入力サニタイゼーション、コマンドインジェクション対策 Key Decisions: System.CommandLineを採用（Microsoft公式、強力なヘルプ生成） Git実行はProcessRunnerラッパークラス（テスト容易性） Result<T>パターンでエラーハンドリング（null安全、明示的） 3層テスト戦略（Unit 80%, Integration 15%, E2E 5%） Phase 1: Design & Contracts (Complete) Status: ✅ Complete Outputs: data-model.md contracts/cli-interface.md quickstart.md Core Data Model 5つのコアエンティティを定義: WorktreeInfo: Worktree情報（パス、ブランチ、作成日時） BranchInfo: ブランチ情報（名前、ベース、SHA） EditorConfig: エディター設定（タイプ、コマンド、引数） CommandResult<T>: 実行結果（成功/失敗、データ、エラー詳細） CreateWorktreeOptions: コマンドオプション（全パラメータ） Validation Rules ブランチ名: 正規表現 ^[a-zA-Z0-9][a-zA-Z0-9/_-]*$ 禁止パターン: .., @{, 空白、制御文字 パス検証: 親ディレクトリ存在、書き込み権限、ディスク容量 Error Code Taxonomy 11のエラーコード定義（5カテゴリ）: GIT系 (GIT001-003): Git実行エラー BR系 (BR001-002): ブランチエラー WT系 (WT001-002): Worktreeエラー FS系 (FS001-003): ファイルシステムエラー ED系 (ED001): エディターエラー CLI Interface コマンド構文: wt create <branch-name> [OPTIONS] Design Philosophy: wt自体が「worktree tool」を意味するため、worktreeサブコマンドは省略。シンプルで覚えやすいCLIを実現します。 主要オプション: --base-branch, -b: ベースブランチ指定 --path, -p: カスタムパス指定 --editor, -e: エディター起動 --checkout-existing: 既存ブランチをチェックアウト --output, -o: 出力形式 (human|json) --verbose, -v: 詳細診断出力 終了コード: 0-1 (一般), 10-12 (Git), 20-21 (ブランチ), 30-32 (Worktree), 40 (ディスク), 50 (エディター) Quickstart Guide 開発者向けガイド作成済み: 5フェーズの実装ワークフロー Test-First実装例 統合テスト・E2Eテスト戦略 トラブルシューティング Constitution Re-Check (Post-Design) Final validation after Phase 1 design completion. Principle Requirement Status Notes I. Developer Usability CLI優先、明瞭な操作 ✅ PASS CLI仕様確定、全7オプション定義、usage例8件作成 I. Developer Usability エラーメッセージに解決策 ✅ PASS 11エラーコード定義、全てにソリューション記載 II. Cross-Platform Windows/macOS/Linux対応 ✅ PASS プラットフォーム別考慮事項を明記、パス処理抽象化 II. Cross-Platform OS固有機能に非依存 ✅ PASS 標準.NETライブラリのみ使用 III. Clean & Secure セキュアなコード ✅ PASS バリデーション規則定義、入力サニタイゼーション戦略策定 III. Clean & Secure 静的解析 ✅ PASS .NET標準アナライザー適用予定 IV. Documentation 日本語ドキュメント優先 ✅ PASS 全ドキュメント日本語（4文書作成済み） IV. Documentation ADRで技術決定記録 ✅ PASS research.mdに10分野の技術決定を記録 V. Minimal Dependencies 最小限の依存 ✅ PASS 3依存のみ（System.CommandLine, System.IO.Abstractions, JSON lib） V. Minimal Dependencies 標準ライブラリ優先 ✅ PASS System.Diagnostics.Process等の標準ライブラリ中心 VI. Testing TDD必須 ✅ PASS Quickstartに5フェーズTDDワークフロー記載 VI. Testing CI/CDでテスト自動化 ⚠️ DEFERRED プロジェクト全体タスクとして別途設定 Final Status: ✅ PASS - All gates remain passed after design phase. Design Impact: 設計によりすべての憲章要件を満たすことが確認されました。依存関係は計画通り最小限（3つ）、ドキュメントは日本語で充実、TDD戦略も具体的に定義されています。 Agent Context Update Status: ✅ Complete File: .github/agents/copilot-instructions.md Changes: Added C# .NET 10 as active language Added System.CommandLine, System.IO.Abstractions, JSON library as frameworks Recorded feature 001-create-worktree Next Steps Immediate Actions Run /speckit.tasks: 実装タスクを生成 /speckit.tasks Review Generated Artifacts: 以下のファイルをレビュー [x] plan.md - この実装計画書 [x] research.md - 技術リサーチ（10分野） [x] data-model.md - データモデル定義（5エンティティ） [x] contracts/cli-interface.md - CLI仕様（完全定義） [x] quickstart.md - 開発者ガイド（5フェーズ） Implementation Preparation Setup Development Environment: .NET 10 SDK インストール確認 Git 2.5+ インストール確認 IDE/エディター設定 Create Feature Branch: git checkout -b 001-create-worktree Install Dependencies: dotnet add wt.cli package System.CommandLine dotnet add wt.cli package System.IO.Abstractions dotnet add wt.cli package System.Text.Json dotnet add wt.tests package xUnit dotnet add wt.tests package FluentAssertions dotnet add wt.tests package Moq Follow Quickstart Guide: quickstart.mdを参照し、5フェーズのワークフローに従って実装 Quality Gates 実装時に以下を確認: ✅ すべてのテストが通過（Green） ✅ コードカバレッジ80%以上 ✅ 憲章の全要件を満たす ✅ ドキュメントが最新 Artifacts Summary Document Status Purpose Lines plan.md ✅ Complete 実装計画書 ~240 research.md ✅ Complete 技術リサーチ ~350 data-model.md ✅ Complete データモデル定義 ~280 contracts/cli-interface.md ✅ Complete CLI仕様 ~420 quickstart.md ✅ Complete 開発者ガイド ~480 .github/agents/copilot-instructions.md ✅ Updated エージェントコンテキスト ~35 Total Documentation: ~1,800 lines across 6 files Complexity Tracking No violations detected - All constitution requirements are met without compromise."
  },
  "specs/001-create-worktree/quickstart.html": {
    "href": "specs/001-create-worktree/quickstart.html",
    "title": "Quickstart Guide: Worktree Create Feature | wt",
    "summary": "Quickstart Guide: Worktree Create Feature Feature: 001-create-worktree Date: 2026-01-03 Audience: Developers implementing the feature Prerequisites .NET 10 SDK インストール済み Git 2.5+ インストール済み 基本的なC#とGitの知識 Development Setup 1. Clone & Build # リポジトリのクローン git clone https://github.com/your-org/wt.git cd wt # ビルド dotnet build # テスト実行 dotnet test 2. Project Structure wt/ ├── wt.cli/ # メインCLIプロジェクト │ ├── Commands/ # コマンド実装 │ │ └── WorktreeCreateCommand.cs │ ├── Services/ # ビジネスロジック │ │ ├── GitService.cs │ │ ├── WorktreeService.cs │ │ └── EditorService.cs │ ├── Models/ # データモデル │ │ ├── WorktreeInfo.cs │ │ ├── BranchInfo.cs │ │ ├── EditorConfig.cs │ │ ├── CommandResult.cs │ │ └── CreateWorktreeOptions.cs │ └── Utils/ # ユーティリティ │ ├── PathHelper.cs │ ├── ProcessRunner.cs │ └── Validators.cs └── wt.tests/ # テストプロジェクト ├── Commands/ ├── Services/ ├── Models/ └── Integration/ Implementation Workflow Phase 1: Core Models (Day 1) Task: データモデルとエラータイプの実装 // Models/WorktreeInfo.cs public record WorktreeInfo( string Path, string BranchName, string BaseBranch, DateTime CreatedAt ); // Models/CommandResult.cs public record CommandResult<T>( bool IsSuccess, T? Data = default, string? ErrorCode = null, string? ErrorMessage = null, string? Solution = null ); Test First: [Fact] public void WorktreeInfo_ValidPath_ShouldCreate() { var info = new WorktreeInfo( \"/path/to/worktree\", \"feature-x\", \"main\", DateTime.Now ); info.Path.Should().Be(\"/path/to/worktree\"); } Phase 2: Git Service (Day 2) Task: Git操作のラッパー実装 // Services/GitService.cs public interface IGitService { Task<CommandResult<bool>> IsGitRepositoryAsync(); Task<CommandResult<string>> GetCurrentBranchAsync(); Task<CommandResult<bool>> BranchExistsAsync(string branchName); Task<CommandResult<BranchInfo>> CreateBranchAsync(string name, string baseBranch); } public class GitService : IGitService { private readonly IProcessRunner _processRunner; public async Task<CommandResult<bool>> IsGitRepositoryAsync() { var result = await _processRunner.RunAsync( \"git\", \"rev-parse --git-dir\" ); return result.ExitCode == 0 ? CommandResult<bool>.Success(true) : CommandResult<bool>.Failure(\"GIT001\", \"Not a Git repository\"); } } Test First: [Fact] public async Task IsGitRepository_WhenInGitRepo_ReturnsTrue() { // Arrange _mockProcessRunner .Setup(x => x.RunAsync(\"git\", \"rev-parse --git-dir\")) .ReturnsAsync(new ProcessResult(0, \"\", \"\")); // Act var result = await _gitService.IsGitRepositoryAsync(); // Assert result.IsSuccess.Should().BeTrue(); result.Data.Should().BeTrue(); } Phase 3: Worktree Service (Day 3) Task: Worktree作成ロジック // Services/WorktreeService.cs public interface IWorktreeService { Task<CommandResult<WorktreeInfo>> CreateWorktreeAsync( CreateWorktreeOptions options ); } public class WorktreeService : IWorktreeService { private readonly IGitService _gitService; private readonly IPathHelper _pathHelper; public async Task<CommandResult<WorktreeInfo>> CreateWorktreeAsync( CreateWorktreeOptions options) { // 1. バリデーション var validation = ValidateOptions(options); if (!validation.IsSuccess) return validation; // 2. ブランチ作成 var branch = await _gitService.CreateBranchAsync( options.BranchName, options.BaseBranch ); if (!branch.IsSuccess) return CommandResult<WorktreeInfo>.Failure( branch.ErrorCode, branch.ErrorMessage ); // 3. Worktree追加 var worktreePath = _pathHelper.ResolveWorktreePath( options.Path ?? $\"../worktrees/{options.BranchName}\" ); var result = await _gitService.AddWorktreeAsync( worktreePath, options.BranchName ); if (!result.IsSuccess) return CommandResult<WorktreeInfo>.Failure( result.ErrorCode, result.ErrorMessage ); // 4. 成功レスポンス return CommandResult<WorktreeInfo>.Success( new WorktreeInfo( worktreePath, options.BranchName, options.BaseBranch, DateTime.UtcNow ) ); } } Phase 4: Editor Service (Day 4) Task: エディター起動機能 // Services/EditorService.cs public interface IEditorService { Task<CommandResult<bool>> LaunchEditorAsync( EditorType editor, string path ); CommandResult<string> ResolveEditorCommand(EditorType editor); } public class EditorService : IEditorService { private static readonly Dictionary<EditorType, string[]> EditorCommands = new() { [EditorType.VSCode] = new[] { \"code\", \"code-insiders\" }, [EditorType.Vim] = new[] { \"vim\" }, [EditorType.Emacs] = new[] { \"emacs\" }, [EditorType.Nano] = new[] { \"nano\" }, [EditorType.Idea] = new[] { \"idea\" } }; public async Task<CommandResult<bool>> LaunchEditorAsync( EditorType editor, string path) { var command = ResolveEditorCommand(editor); if (!command.IsSuccess) return CommandResult<bool>.Failure( command.ErrorCode, command.ErrorMessage ); var result = await _processRunner.RunAsync( command.Data!, path ); return result.ExitCode == 0 ? CommandResult<bool>.Success(true) : CommandResult<bool>.Failure(\"ED001\", \"Failed to launch editor\"); } } Phase 5: CLI Command (Day 5) Task: System.CommandLineでCLI統合 // Commands/WorktreeCreateCommand.cs public class WorktreeCreateCommand : Command { public WorktreeCreateCommand() : base( \"create\", \"Create a new worktree with branch\") { var branchNameArg = new Argument<string>( \"branch-name\", \"Name of the branch to create\" ); var baseBranchOpt = new Option<string?>( aliases: new[] { \"--base\", \"-b\" }, description: \"Base branch (default: current branch)\" ); var pathOpt = new Option<string?>( aliases: new[] { \"--path\", \"-p\" }, description: \"Worktree path (default: ../worktrees/<branch-name>)\" ); var editorOpt = new Option<EditorType?>( aliases: new[] { \"--editor\", \"-e\" }, description: \"Editor to launch after creation\" ); AddArgument(branchNameArg); AddOption(baseBranchOpt); AddOption(pathOpt); AddOption(editorOpt); this.SetHandler(ExecuteAsync, branchNameArg, baseBranchOpt, pathOpt, editorOpt ); } private async Task<int> ExecuteAsync( string branchName, string? baseBranch, string? path, EditorType? editor) { var options = new CreateWorktreeOptions { BranchName = branchName, BaseBranch = baseBranch ?? await _gitService.GetCurrentBranchAsync(), Path = path, Editor = editor }; var result = await _worktreeService.CreateWorktreeAsync(options); if (!result.IsSuccess) { Console.WriteLine($\"✗ Error: {result.ErrorMessage}\"); Console.WriteLine($\"→ Solution: {result.Solution}\"); return 1; } Console.WriteLine($\"✓ Created branch '{result.Data.BranchName}' from '{result.Data.BaseBranch}'\"); Console.WriteLine($\"✓ Added worktree at: {result.Data.Path}\"); Console.WriteLine($\"→ Next: cd {result.Data.Path}\"); return 0; } } Testing Strategy Unit Tests (80% coverage target) // wt.tests/Services/WorktreeServiceTests.cs public class WorktreeServiceTests { [Fact] public async Task CreateWorktree_ValidOptions_CreatesSuccessfully() { // Arrange var options = new CreateWorktreeOptions { BranchName = \"feature-test\", BaseBranch = \"main\", Path = null }; // Act var result = await _service.CreateWorktreeAsync(options); // Assert result.IsSuccess.Should().BeTrue(); result.Data.BranchName.Should().Be(\"feature-test\"); } [Theory] [InlineData(\"\")] [InlineData(\" \")] [InlineData(\"feature..test\")] [InlineData(\"feature@{test\")] public async Task CreateWorktree_InvalidBranchName_ReturnsError( string invalidName) { // Arrange var options = new CreateWorktreeOptions { BranchName = invalidName }; // Act var result = await _service.CreateWorktreeAsync(options); // Assert result.IsSuccess.Should().BeFalse(); result.ErrorCode.Should().Be(\"BR001\"); } } Integration Tests // wt.tests/Integration/WorktreeCreationTests.cs public class WorktreeCreationTests : IDisposable { private readonly string _testRepoPath; public WorktreeCreationTests() { // テスト用Gitリポジトリを作成 _testRepoPath = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString()); Directory.CreateDirectory(_testRepoPath); ProcessRunner.Run(\"git\", \"init\", _testRepoPath); ProcessRunner.Run(\"git\", \"commit --allow-empty -m 'Initial'\", _testRepoPath); } [Fact] public async Task EndToEnd_CreateWorktree_Success() { // Arrange var service = new WorktreeService(/* ... */); var options = new CreateWorktreeOptions { BranchName = \"test-branch\", BaseBranch = \"main\", Path = Path.Combine(_testRepoPath, \"worktrees\", \"test-branch\") }; // Act var result = await service.CreateWorktreeAsync(options); // Assert result.IsSuccess.Should().BeTrue(); Directory.Exists(result.Data.Path).Should().BeTrue(); } public void Dispose() { Directory.Delete(_testRepoPath, true); } } E2E Tests # wt.tests/E2E/test-worktree-creation.sh #!/bin/bash # Setup TEMP_REPO=$(mktemp -d) cd \"$TEMP_REPO\" git init git commit --allow-empty -m \"Initial commit\" # Test 1: Basic creation ../wt create feature-test if [ $? -ne 0 ]; then echo \"FAIL: Basic creation\" exit 1 fi # Test 2: With base branch ../wt create hotfix --base main if [ $? -ne 0 ]; then echo \"FAIL: With base branch\" exit 1 fi # Test 3: Invalid branch name ../wt create \"invalid..name\" if [ $? -eq 0 ]; then echo \"FAIL: Should reject invalid name\" exit 1 fi echo \"PASS: All E2E tests\" Development Tips 1. Test-Driven Development # Red: テスト作成（失敗することを確認） dotnet test # Green: 最小限の実装 # code... # Refactor: コード品質向上 # code... # 確認 dotnet test 2. Debugging # デバッグビルド dotnet build --configuration Debug # デバッガーアタッチ dotnet run --project wt.cli -- worktree create test-branch 3. Local Testing # テスト用リポジトリ作成 mkdir /tmp/test-repo cd /tmp/test-repo git init git commit --allow-empty -m \"Initial\" # wtコマンドをテスト /path/to/wt/bin/Debug/net10.0/wt create feature-test # 結果確認 git worktree list Common Issues & Solutions Issue 1: Git Not Found Problem: git コマンドが見つからない Solution: # PATH確認 echo $PATH # Gitインストール確認 which git # 環境変数設定 export PATH=\"/usr/local/bin:$PATH\" Issue 2: Permission Denied Problem: Worktree作成時にパーミッションエラー Solution: # ディレクトリの権限確認 ls -la ../worktrees # 権限変更 chmod 755 ../worktrees Issue 3: Branch Already Exists Problem: 同名のブランチが既に存在 Solution: # --checkout-existingオプションを使用 wt create feature-x --checkout-existing # または別の名前を使用 wt create feature-x-v2 Performance Benchmarks # ベンチマーク実行 cd wt.tests dotnet run --configuration Release --project Benchmarks # 期待値: # - バリデーション: < 100ms # - ブランチ作成: < 1s # - Worktree追加: < 2s # - Total: < 5s Next Steps Phase 0完了後: data-model.mdとresearch.mdをレビュー Phase 1開始: CoreモデルとGitServiceから実装開始 各Phase完了時: テストが全てグリーンであることを確認 Phase 5完了後: E2Eテストで全シナリオを検証 Resources System.CommandLine Docs Git Worktree Docs .NET Testing Best Practices Specification Document Data Model CLI Interface Contract Contact 質問やフィードバックは Issue または Pull Request でお願いします。"
  },
  "specs/001-create-worktree/research.html": {
    "href": "specs/001-create-worktree/research.html",
    "title": "Research: Git Worktree 作成コマンド | wt",
    "summary": "Research: Git Worktree 作成コマンド Feature: 001-create-worktree Date: 2026-01-03 Purpose: 技術選択とベストプラクティスのリサーチ結果 Research Tasks 本フェーズでは、Technical Contextで特定された技術スタックとアプローチの妥当性を検証し、ベストプラクティスを調査しました。 1. CLIフレームワークの選択 Decision: System.CommandLine Rationale: Microsoft公式のCLIフレームワーク 強力なコマンドパース機能とヘルプ生成 型安全なオプション定義 .NETエコシステムとの統合 Alternatives Considered: CommandLineParser: 成熟しているが、System.CommandLineより機能が少ない McMaster.Extensions.CommandLineUtils: 良い選択肢だが、Microsoftの公式サポートが System.CommandLine に移行 Best Practices: コマンドとハンドラーを分離（CQRS的アプローチ） オプションクラスで型安全性を確保 ヘルプテキストを詳細に記述 2. Gitコマンド実行パターン Decision: System.Diagnostics.Process + ラッパークラス Rationale: 標準ライブラリで実現可能（依存関係最小化） クロスプラットフォーム対応 テストしやすい抽象化 Alternatives Considered: LibGit2Sharp: 強力だが、依存関係が大きい。憲章Vに反する Git CLI直接呼び出し: 抽象化なしではテストが困難 Best Practices: IGitService インターフェースで抽象化 標準出力/エラー出力を適切にキャプチャ タイムアウト設定を実装 エラーハンドリングを徹底 Implementation Pattern: public interface IGitService { Task<GitResult> ExecuteAsync(string command, string[]args, CancellationToken ct); Task<bool> IsGitRepositoryAsync(string path); Task<string> GetCurrentBranchAsync(); Task<bool> BranchExistsAsync(string branchName); } 3. パス操作の抽象化 Decision: System.IO.Abstractions Rationale: クロスプラットフォームのパス操作を抽象化 テスト時にファイルシステムのモックが容易 .NET標準のPath/Directory/Fileクラスと互換性 Best Practices: IFileSystem を依存性注入 パス区切り文字はOSに応じて自動処理 絶対パスと相対パスの明確な区別 Path Handling Strategy: 入力: branch-name デフォルトパス生成: Path.Combine(repoParent, \"worktrees\", branch-name) カスタムパス: ユーザー指定の絶対パス or カレントディレクトリからの相対パス 4. エディター検出とプリセット Decision: エディタープリセット + PATH検索 Rationale: 一般的なエディターの標準コマンドをプリセットとして定義 環境変数PATHから実行可能ファイルを検索 ユーザーカスタムコマンドもサポート Editor Presets: public static class EditorPresets { public static Dictionary<string, EditorConfig> KnownEditors = new() { [\"vscode\"] = new(\"code\", \"{path}\"), [\"vim\"] = new(\"vim\", \"{path}\"), [\"emacs\"] = new(\"emacs\", \"{path}\"), [\"nano\"] = new(\"nano\", \"{path}\"), [\"idea\"] = new(\"idea\", \"{path}\"), }; } Best Practices: エディターが見つからない場合は警告のみ（worktree作成は継続） verboseモードで検索パスを表示 Windows: .exe拡張子を自動追加 5. 出力フォーマット戦略 Decision: Strategyパターン + System.Text.Json Rationale: JSON出力には標準の System.Text.Json を使用（追加依存なし） 人間可読出力は構造化されたテキスト形式 フォーマッターを切り替え可能 Output Formats: // JSON format { \"success\": true, \"worktree\": { \"path\": \"/path/to/worktrees/feature-x\", \"branch\": \"feature-x\", \"baseBranch\": \"main\" }, \"editorLaunched\": true } // Human-readable format ✓ Created branch 'feature-x' from 'main' ✓ Added worktree at: /path/to/worktrees/feature-x ✓ Launched VS Code → Next: cd /path/to/worktrees/feature-x 6. エラーハンドリング戦略 Decision: Result パターン + カスタム例外 Rationale: Resultパターンで成功/失敗を明示的に表現 カスタム例外で詳細なエラー情報を提供 各エラーに解決策を含める Error Categories: Git関連: GitNotFound, NotGitRepository, BranchExists ファイルシステム: PathNotWritable, DiskSpaceLow Worktree関連: WorktreeExists, InvalidBranchName エディター関連: EditorNotFound (警告レベル) Best Practices: すべてのエラーメッセージに解決策を含める verboseモードでスタックトレースと診断情報を出力 エラーコードで種類を識別可能にする 7. テスト戦略 Decision: xUnit + FluentAssertions + Moq + TestContainers (Git) Rationale: xUnit: 既存プロジェクトで使用中 FluentAssertions: 読みやすいアサーション Moq: インターフェースのモック テストでは実際のGitリポジトリを一時的に作成してE2Eテスト Test Layers: Unit Tests: サービス、バリデーター、フォーマッター Integration Tests: Git操作の実際の実行 E2E Tests: コマンド全体の動作確認 Best Practices: Given-When-Then パターン 各テストは独立して実行可能 テスト用の一時ディレクトリを使用 クリーンアップを確実に実行 8. クロスプラットフォーム対応 Decision: .NET 10 + 条件付きコンパイル Rationale: .NET 10はWindows、macOS、Linuxをネイティブサポート 必要に応じて #if ディレクティブで分岐 Platform-Specific Considerations: Windows: パス区切り \\、実行ファイル .exe macOS/Linux: パス区切り /、実行ファイル拡張子なし 共通: System.IO.Abstractionsで抽象化 Testing Strategy: CI/CDで3プラットフォームでテスト実行 プラットフォーム固有の動作は個別にテスト 9. パフォーマンス最適化 Decision: 非同期パターン + キャンセレーション Rationale: Git操作は時間がかかる可能性がある async/awaitで非ブロッキング実行 CancellationTokenでユーザーによる中断をサポート Performance Goals (from Technical Context): コマンド実行: < 5秒 worktree作成 + エディター起動: < 30秒 メモリ使用: < 100MB Optimization Strategies: Git操作の並列化（可能な場合） 不要なGit情報の取得を避ける 出力バッファリングの最適化 10. セキュリティ考慮事項 Decision: 入力バリデーション + コマンドインジェクション防止 Rationale: ブランチ名の厳格なバリデーション Gitコマンドのパラメータ化 パストラバーサル攻撃の防止 Security Measures: ブランチ名のホワイトリスト検証（英数字、-、_のみ） パスのサニタイズ ユーザー入力をGitコマンドに直接渡さない エディターコマンドのバリデーション Summary すべてのリサーチタスクが完了し、技術選択の妥当性が確認されました。Technical Contextで「NEEDS CLARIFICATION」とマークされた項目はすべて解決されています。Phase 1（Design & Contracts）に進む準備が整いました。 Key Technologies Confirmed: CLI Framework: System.CommandLine Git Interaction: System.Diagnostics.Process + カスタムラッパー Path Operations: System.IO.Abstractions JSON: System.Text.Json Testing: xUnit + FluentAssertions + Moq No Blockers: すべての技術選択は憲章の要件を満たしています。"
  },
  "specs/001-create-worktree/spec.html": {
    "href": "specs/001-create-worktree/spec.html",
    "title": "Feature Specification: Git Worktree 作成コマンド | wt",
    "summary": "Feature Specification: Git Worktree 作成コマンド Feature Branch: 001-create-worktree Created: 2026-01-03 Status: Draft Input: User description: \"ユーザーはコマンドを実行することで新規にブランチ作成するとともにgit worktree への追加を行うことができる。追加後は必要に応じてVSCodeをや任意のエディターを起動できるようにする。ブランチはユーザーからの入力を元にして作成する。ブランチ作成時にgit worktreeへ自動的に追加することで、AIコードエージェントを並列で実行できたり、AIコードエージェントの作業と平行して手作業による開発を行うようにする。特にgit worktreeへの登録はコマンドが複雑であり、これを簡略化することで開発者は本来注力するべき、仕様や実装にリソースを割くことができるようになる。\" Clarifications Session 2026-01-03 Q: 新しいブランチを作成する際のベースブランチの決定方法は？ → A: 現在のブランチをベースとし、オプションで指定可能 Q: デフォルト worktree パスの命名規則は？ → A: ../worktrees/<branch-name> - 複数worktreeを1ディレクトリに集約 Q: VS Code 以外のエディター対応範囲は？ → A: 一般的なエディター（VS Code、vim、emacs、nano、IntelliJ IDEA）のプリセットを提供 Q: エラーメッセージの詳細度は？ → A: 基本エラー + 解決策の提示 + verbose モードで詳細 Q: ブランチ名が既に存在する場合の動作は？ → A: エラーで停止 + 既存ブランチをチェックアウトするオプション提示 User Scenarios & Testing (mandatory) User Story 1 - Git Worktree 作成の基本機能 (Priority: P1) 開発者が新しいブランチ名を指定してコマンドを実行すると、ブランチが作成され、自動的に git worktree として登録される。これにより、開発者は複雑な git worktree コマンドを覚える必要がなく、すぐに並列開発を開始できる。 Why this priority: この機能の中核であり、これがなければ他の機能も成立しない。git worktree の複雑なコマンドを抽象化することが最大の価値提供。 Independent Test: ブランチ名を指定してコマンドを実行し、worktree が作成されることを確認すれば、この機能は独立してテスト可能。 Acceptance Scenarios: Given 既存のGitリポジトリがある、When ユーザーが新しいブランチ名を指定してコマンドを実行する、Then 指定したブランチが作成され、worktree ディレクトリが生成される Given worktree が作成された、When worktree ディレクトリに移動する、Then 指定したブランチにチェックアウトされている Given ユーザーが既存のブランチ名を指定する、When コマンドを実行する、Then エラーメッセージが表示され、worktree は作成されない User Story 2 - エディター自動起動機能 (Priority: P2) worktree 作成後、開発者がオプションで指定したエディター（VS Code など）を自動起動できる。これにより、worktree 作成からコーディング開始までの手順が1コマンドで完結する。 Why this priority: 開発者体験を大幅に向上させるが、P1 の基本機能がなければ意味がない。付加価値として位置づけられる。 Independent Test: worktree 作成時にエディター起動オプションを指定し、エディターが自動的に開くことを確認すれば、この機能は独立してテスト可能。 Acceptance Scenarios: Given VS Code がインストールされている、When ユーザーが VS Code オプション付きでコマンドを実行する、Then worktree が作成され、VS Code が worktree ディレクトリで起動する Given エディターが指定されていない、When コマンドを実行する、Then worktree のみが作成され、エディターは起動しない Given 指定されたエディターが見つからない、When コマンドを実行する、Then 警告メッセージが表示されるが、worktree は正常に作成される User Story 3 - Worktree パスのカスタマイズ (Priority: P3) 開発者が worktree を作成する場所（パス）をカスタマイズできる。デフォルトでは親ディレクトリに作成されるが、特定のプロジェクト構造やディスク容量の制約がある場合に柔軟に対応できる。 Why this priority: 一部の開発者には必要だが、デフォルト動作で大半のユースケースをカバーできる。 Independent Test: カスタムパスを指定してコマンドを実行し、指定した場所に worktree が作成されることを確認すれば、この機能は独立してテスト可能。 Acceptance Scenarios: Given カスタムパスを指定する、When コマンドを実行する、Then 指定したパスに worktree が作成される Given 無効なパス（書き込み権限がない等）を指定する、When コマンドを実行する、Then エラーメッセージが表示され、worktree は作成されない Given パスが指定されていない、When コマンドを実行する、Then デフォルトパス（親ディレクトリ）に worktree が作成される Edge Cases 既存のブランチ名を指定した場合: エラーで停止し、既存ブランチをチェックアウトして worktree を作成するオプション（例：--checkout-existing）を提示する 既存の worktree と同じ名前を指定した場合: エラーメッセージを表示し、既存の worktree 一覧を提示する Git リポジトリではないディレクトリでコマンドを実行した場合: 明確なエラーメッセージと解決策を表示する ブランチ名に不正な文字が含まれている場合: Git の命名規則に基づいてバリデーションを行い、エラーメッセージと有効な文字の例を表示する ディスク容量が不足している場合: 作成前にスペースをチェックし、警告を表示する ネットワーク共有ディレクトリで実行した場合: パフォーマンス警告を表示するが、処理は継続する 指定されたエディターが見つからない場合: 警告メッセージを表示するが、worktree は正常に作成される（verbose モードで詳細な診断情報を提供） Requirements (mandatory) Functional Requirements FR-001: システムは CLI コマンドとして動作し、ブランチ名を引数として受け取る必要がある FR-002: システムは指定されたブランチ名でGitブランチを作成する必要がある。デフォルトでは現在のブランチをベースとし、オプションでベースブランチを指定可能にする FR-003: システムは作成したブランチを git worktree として自動的に登録する必要がある FR-004: システムは worktree の作成場所をデフォルト（../worktrees/<branch-name>）として、オプションでカスタマイズ可能にする必要がある FR-005: システムはオプションでエディター（VS Code、vim、emacs、nano、IntelliJ IDEA）を自動起動できる必要がある。これらの一般的なエディターのプリセットを提供する FR-006: システムは既存のブランチ名や worktree 名の重複を検出し、エラーで停止する必要がある。その際、既存ブランチをチェックアウトして worktree を作成するオプション（例：--checkout-existing）を提示する FR-007: システムは Git リポジトリの存在を確認し、非 Git ディレクトリでは実行できないようにする必要がある FR-008: システムはブランチ名のバリデーションを行い、Git の命名規則に従わない名前を拒否する必要がある FR-009: システムは処理の進行状況を明確に表示する必要がある（ブランチ作成中、worktree 作成中など） FR-010: システムはエラー発生時に基本エラーメッセージと具体的な解決策を表示する必要がある。verbose モードで詳細なスタックトレースと診断情報を提供する FR-011: システムは人間が読める形式と JSON 形式の両方で出力をサポートする必要がある Key Entities Branch: Git ブランチを表現する。名前、ベースブランチ（デフォルトは現在のブランチ、オプションで指定可能）の情報を持つ Worktree: Git worktree を表現する。パス（デフォルト: ../worktrees/<branch-name>）、関連するブランチ、作成日時の情報を持つ EditorConfig: エディター設定を表現する。エディター種類（VS Code、vim、emacs、nano、IntelliJ IDEA のプリセット）、起動コマンド、パスの情報を持つ Success Criteria (mandatory) Measurable Outcomes SC-001: 開発者が worktree 作成コマンドを実行してから作業を開始するまでの時間が 30 秒以内である SC-002: 開発者が git worktree の複雑なコマンド構文を覚える必要がなく、1つの明瞭なコマンドで操作できる SC-003: コマンド実行の 95% 以上が初回で成功する（明確なエラーメッセージによりユーザーが問題を即座に修正できる） SC-004: Windows、macOS、Linux の主要 OS で同じコマンド構文が動作する SC-005: エディター自動起動機能により、worktree 作成から開発開始までの手作業が 1 コマンドに削減される Assumptions Git のバージョン: Git 2.5 以上がインストールされていることを前提とする（git worktree サポート開始バージョン） デフォルト worktree パス: ../worktrees/<branch-name> をデフォルトとし、複数の worktree を1ディレクトリに集約する ベースブランチ: 新しいブランチは現在のブランチをベースとして作成され、オプションで異なるベースブランチを指定可能 エディター検出: 一般的なエディター（VS Code、vim、emacs、nano、IntelliJ IDEA）は標準的なインストールパスで検出可能と仮定する ブランチ名規則: Git の標準的な命名規則（英数字、ハイフン、アンダースコア）に従う 権限: ユーザーは worktree 作成先ディレクトリ（デフォルトは ../worktrees/）への書き込み権限を持つと仮定する 既存ブランチ: 既存のブランチ名を指定した場合はエラーで停止し、既存ブランチをチェックアウトするオプションを提示する Out of Scope 既存 worktree の管理機能: 既存 worktree の削除、リスト表示、切り替えは本機能の範囲外（将来的な拡張として検討可能） リモートブランチの自動プッシュ: 作成したブランチをリモートリポジトリに自動的にプッシュする機能は含まない Worktree 間の変更のマージ: 複数 worktree 間での変更のマージやコンフリクト解決支援は含まない IDE の高度な設定: エディター起動は単純な起動のみで、IDE のプロジェクト設定やワークスペース設定は行わない"
  },
  "specs/001-create-worktree/tasks.html": {
    "href": "specs/001-create-worktree/tasks.html",
    "title": "Tasks: Git Worktree 作成コマンド | wt",
    "summary": "Tasks: Git Worktree 作成コマンド Feature: 001-create-worktree Branch: 001-create-worktree Date: 2026-01-03 Input: Design documents from /specs/001-create-worktree/ Prerequisites: ✅ All design documents complete plan.md - 実装計画書 spec.md - 機能仕様（3 User Stories） data-model.md - 5 Core Entities contracts/cli-interface.md - CLI仕様 quickstart.md - 開発ガイド Tests: TDD approach required per constitution. All tests must be written FIRST and FAIL before implementation. Format: - [ ] [ID] [P?] [Story?] Description with file path [P]: Can run in parallel (different files, no dependencies) [Story]: User story label (US1, US2, US3) - only for user story phases Include exact file paths Phase 1: Setup (Project Initialization) Purpose: プロジェクト初期化と基本構造 [X] T001 既存プロジェクト構造を確認し、specs/001-create-worktree/plan.mdのProject Structureに記載された新規ディレクトリを作成（wt.cli/Commands, Services, Models, Utils） [X] T002 NuGetパッケージをwt.cliに追加: System.CommandLine, System.IO.Abstractions, System.Text.Json [X] T003 [P] NuGetパッケージをwt.testsに追加: xUnit, FluentAssertions, Moq [X] T004 [P] .editorconfig と静的解析設定を確認（既存設定を維持） Checkpoint: ✅ プロジェクト構造とパッケージ準備完了 Phase 2: Foundational (Blocking Prerequisites) Purpose: 全User Storyで共通利用する基盤実装。この Phase が完了するまで User Story の実装は開始できません。 ⚠️ CRITICAL: この Phase 完了まで User Story 実装は不可 Foundational Tests (Write FIRST, ensure they FAIL) [X] T005 [P] ProcessRunner のユニットテストを作成: wt.tests/Utils/ProcessRunnerTests.cs（Gitコマンド実行の成功・失敗ケース） [X] T006 [P] PathHelper のユニットテストを作成: wt.tests/Utils/PathHelperTests.cs（パス正規化、検証） [X] T007 [P] Validators のユニットテストを作成: wt.tests/Utils/ValidatorsTests.cs（ブランチ名バリデーション） Foundational Implementation [X] T008 [P] ProcessRunner を実装: wt.cli/Utils/ProcessRunner.cs（System.Diagnostics.Process wrapper、Git コマンド実行） [X] T009 [P] PathHelper を実装: wt.cli/Utils/PathHelper.cs（System.IO.Abstractions 使用、パス正規化・検証） [X] T010 [P] Validators を実装: wt.cli/Utils/Validators.cs（ブランチ名バリデーション、正規表現: ^[a-zA-Z0-9][a-zA-Z0-9/_.-]*$） [X] T011 [P] CommandResult<T> モデルを実装: wt.cli/Models/CommandResult.cs（Result パターン、Success/Error/Warnings） [X] T012 [P] エラーコード定数クラスを実装: wt.cli/Models/ErrorCodes.cs（GIT001-ED001 の11コード定義） Checkpoint: ✅ 基盤完了 - User Story 実装開始可能 Phase 3: User Story 1 - Git Worktree 作成の基本機能 (Priority: P1) \uD83C\uDFAF MVP Goal: ブランチ名を指定してコマンド実行すると、ブランチが作成され、自動的に git worktree として登録される Independent Test: wt create feature-test を実行し、../worktrees/feature-test に worktree が作成され、feature-test ブランチにチェックアウトされていることを確認 Tests for US1 (Write FIRST, ensure they FAIL) ⚠️ [X] T013 [P] [US1] WorktreeInfo モデルのユニットテストを作成: wt.tests/Models/WorktreeInfoTests.cs（プロパティ検証） [X] T014 [P] [US1] BranchInfo モデルのユニットテストを作成: wt.tests/Models/BranchInfoTests.cs（バリデーション規則） [X] T015 [P] [US1] CreateWorktreeOptions モデルのユニットテストを作成: wt.tests/Models/CreateWorktreeOptionsTests.cs [X] T016 [P] [US1] GitService のユニットテストを作成: wt.tests/Services/Git/GitServiceTests.cs（IsGitRepository, GetCurrentBranch, BranchExists, CreateBranch, AddWorktree の各メソッド） [X] T017 [P] [US1] WorktreeService のユニットテストを作成: wt.tests/Services/Worktree/WorktreeServiceTests.cs（CreateWorktreeAsync の成功・失敗ケース） [X] T018 [US1] WorktreeCreateCommand のユニットテストを作成: wt.tests/Commands/Worktree/CreateCommandTests.cs（コマンド解析、実行フロー、System.CommandLine 2.0対応） [X] T019 [US1] E2E統合テストを作成: wt.tests/Integration/WorktreeE2ETests.cs（テスト用Gitリポジトリ作成、worktree作成、クリーンアップ、5テスト成功） Implementation for US1 [X] T020 [P] [US1] WorktreeInfo モデルを実装: wt.cli/Models/WorktreeInfo.cs（Path, Branch, BaseBranch, CreatedAt プロパティ） [X] T021 [P] [US1] BranchInfo モデルを実装: wt.cli/Models/BranchInfo.cs（Name, BaseBranch, Exists, IsRemote プロパティ + バリデーション） [X] T022 [P] [US1] CreateWorktreeOptions モデルを実装: wt.cli/Models/CreateWorktreeOptions.cs（BranchName, BaseBranch, Path, Editor, CheckoutExisting, OutputFormat, Verbose） [X] T023 [P] [US1] IGitService インターフェースを定義: wt.cli/Services/Git/IGitService.cs（IsGitRepositoryAsync, GetCurrentBranchAsync, BranchExistsAsync, CreateBranchAsync, AddWorktreeAsync） [X] T024 [US1] GitService を実装: wt.cli/Services/Git/GitService.cs（ProcessRunner 使用、全メソッド実装、エラーハンドリング） [X] T025 [P] [US1] IWorktreeService インターフェースを定義: wt.cli/Services/Worktree/IWorktreeService.cs（CreateWorktreeAsync） [X] T026 [US1] WorktreeService を実装: wt.cli/Services/Worktree/WorktreeService.cs（GitService, PathHelper, Validators 依存、CreateWorktreeAsync 実装） [X] T027 [US1] WorktreeCreateCommand を実装: wt.cli/Commands/Worktree/CreateCommand.cs（System.CommandLine 2.0 使用、引数・オプション定義、handler 実装） [X] T028 [US1] Program.cs を更新: wt.cli/Program.cs（WorktreeCreateCommand を RootCommand に追加、DI設定） [X] T029 [US1] エラー処理とログ出力を追加: wt.cli/Commands/Worktree/CreateCommand.cs（CommandResult に基づくエラー表示、✓/✗記号、解決策表示） Checkpoint: US1 完了 - wt create <branch> で worktree 作成が動作 Phase 4: User Story 2 - エディター自動起動機能 (Priority: P2) Goal: worktree 作成後、指定したエディター（VS Code など）を自動起動できる Independent Test: wt create feature-ui --editor vscode を実行し、worktree 作成後に VS Code が自動起動することを確認 Tests for US2 (Write FIRST, ensure they FAIL) ⚠️ [X] T030 [P] [US2] EditorConfig モデルのユニットテストを作成: wt.tests/Models/EditorConfigTests.cs（EditorType, Command, Arguments, IsAvailable） [X] T031 [P] [US2] EditorService のユニットテストを作成: wt.tests/Services/Editor/EditorServiceTests.cs（LaunchEditorAsync, ResolveEditorCommand の各ケース） [X] T032 [US2] エディター起動のE2Eテストを作成: wt.tests/Integration/EditorLaunchTests.cs（VS Code起動の統合テスト） Implementation for US2 [X] T033 [P] [US2] EditorConfig モデルを実装: wt.cli/Models/EditorConfig.cs（EditorType enum, Command, Arguments, IsAvailable プロパティ） [X] T034 [P] [US2] EditorPresets を実装: wt.cli/Services/Editor/EditorPresets.cs（5エディター: vscode, vim, emacs, nano, idea のプリセット定義） [X] T035 [P] [US2] IEditorService インターフェースを定義: wt.cli/Services/Editor/IEditorService.cs（LaunchEditorAsync, ResolveEditorCommand） [X] T036 [US2] EditorService を実装: wt.cli/Services/Editor/EditorService.cs（EditorPresets 使用、PATH検索、ProcessRunner でエディター起動） [X] T037 [US2] CreateCommand に --editor オプションを追加: wt.cli/Commands/Worktree/CreateCommand.cs（-e エイリアス、EditorType enum、handler でエディター起動） [X] T038 [US2] WorktreeService にエディター起動統合: wt.cli/Services/Worktree/WorktreeService.cs（CreateWorktreeAsync 完了後に EditorService.LaunchEditorAsync 呼び出し） [X] T039 [US2] エディターが見つからない場合の警告表示: wt.cli/Services/Editor/EditorService.cs（ED001 エラーコード、worktree 作成は継続） Checkpoint: US2 完了 - wt create <branch> --editor <type> でエディター自動起動が動作 Phase 5: User Story 3 - Worktree パスのカスタマイズ (Priority: P3) Goal: worktree を作成する場所（パス）をカスタマイズできる Independent Test: wt create experiment --path ~/custom/path を実行し、指定したパスに worktree が作成されることを確認 Tests for US3 (Write FIRST, ensure they FAIL) ⚠️ [X] T040 [P] [US3] カスタムパスバリデーションのユニットテストを追加: wt.tests/Utils/PathHelperTests.cs（無効パス、権限エラー、ディスク容量チェック） [X] T041 [US3] カスタムパスのE2Eテストを作成: wt.tests/Integration/CustomPathTests.cs（絶対パス、相対パス、無効パスのテスト） Implementation for US3 [X] T042 [US3] PathHelper にカスタムパス検証を追加: wt.cli/Utils/PathHelper.cs（親ディレクトリ存在チェック、書き込み権限チェック、ディスク容量チェック） [X] T043 [US3] CreateCommand に --path オプションを追加: wt.cli/Commands/Worktree/CreateCommand.cs（-p エイリアス、デフォルト: ../worktrees/<branch>） [X] T044 [US3] WorktreeService でカスタムパス処理: wt.cli/Services/Worktree/WorktreeService.cs（options.Path が null の場合デフォルトパス、非 null の場合カスタムパス使用） [X] T045 [US3] パスエラーハンドリングを追加: wt.cli/Services/Worktree/WorktreeService.cs（FS001-FS003 エラーコード、解決策表示） Checkpoint: US3 完了 - wt create <branch> --path <custom> でカスタムパス指定が動作 Phase 6: Polish & Cross-Cutting Concerns Purpose: 全User Storyに影響する改善と仕上げ [X] T046 [P] --checkout-existing オプションを実装: wt.cli/Commands/Worktree/CreateCommand.cs（既存ブランチをチェックアウト、BR002エラー時の提案） [X] T047 [P] --output オプションを実装: wt.cli/Commands/Worktree/CreateCommand.cs（human|json 出力形式、JsonFormatter/HumanFormatter） [X] T048 [P] --verbose オプションを実装: wt.cli/Commands/Worktree/CreateCommand.cs（詳細診断情報、Git コマンド実行ログ） [X] T049 [P] --base オプションを実装: wt.cli/Commands/Worktree/CreateCommand.cs（-b エイリアス、ベースブランチ指定） [X] T050 IOutputFormatter インターフェースを定義: wt.cli/Services/Output/IOutputFormatter.cs（Format メソッド） [X] T051 [P] JsonFormatter を実装: wt.cli/Services/Output/JsonFormatter.cs（System.Text.Json 使用） [X] T052 [P] HumanFormatter を実装: wt.cli/Services/Output/HumanFormatter.cs（✓/✗記号、色付き出力） [X] T053 プログレス表示を追加: wt.cli/Commands/Worktree/CreateCommand.cs（\"Creating branch...\", \"Adding worktree...\" メッセージ） [X] T054 [P] クロスプラットフォーム対応を検証: wt.tests/Integration/CrossPlatformTests.cs（Windows/macOS/Linux でのパス処理、改行コード） [X] T055 [P] パフォーマンステストを追加: wt.tests/Performance/PerformanceTests.cs（5秒以内の実行時間、メモリ100MB以下） [X] T056 [P] README.md を更新: README.md（インストール、使用方法、例、トラブルシューティング） [X] T057 [P] 日本語ユーザーガイドを作成: docs/ja/user-guide.md（全オプション説明、使用例） [X] T058 quickstart.md のバリデーションを実行（5フェーズワークフローが正しく動作することを確認） [X] T059 全テストを実行してカバレッジ80%以上を確認: dotnet test --collect:\"XPlat Code Coverage\" [X] T060 憲章チェックリストを最終確認: 全12項目 PASS を検証 Checkpoint: 機能完成 - すべてのオプションが動作し、品質基準を満たす Dependencies & Execution Order Phase Dependencies Setup (Phase 1): 依存なし - 即開始可能 Foundational (Phase 2): Setup 完了後 - 全 User Story をブロック User Story 1 (Phase 3): Foundational 完了後 - MVP User Story 2 (Phase 4): Foundational 完了後 - US1と並行可能（別ファイル） User Story 3 (Phase 5): Foundational 完了後 - US1/US2と並行可能（別ファイル） Polish (Phase 6): 全 User Story 完了後 User Story Dependencies US1 (P1): Foundational 完了後に開始可能 - 他 Story への依存なし US2 (P2): Foundational 完了後に開始可能 - US1 の WorktreeService に統合するが、独立してテスト可能 US3 (P3): Foundational 完了後に開始可能 - US1 の PathHelper を拡張するが、独立してテスト可能 Within Each User Story (TDD Workflow) Tests FIRST (必ず失敗することを確認) Models (依存なし) Services (Models に依存) Commands (Services に依存) Integration (全コンポーネントに依存) Parallel Opportunities Setup Phase: T002, T003, T004 は並行実行可能 Foundational Phase: Tests: T005, T006, T007 は並行実行可能 Implementation: T008, T009, T010, T011, T012 は並行実行可能（異なるファイル） User Story 1: Tests: T013, T014, T015, T016, T017 は並行実行可能 Models: T020, T021, T022 は並行実行可能 Interfaces: T023, T025 は並行実行可能 User Story 2: Tests: T030, T031 は並行実行可能 Models/Presets: T033, T034, T035 は並行実行可能 User Story 3: Tests: T040 と T041 は並行実行可能 Polish Phase: T046, T047, T048, T049 は並行実行可能（同一ファイルだが別オプション） T051, T052 は並行実行可能 T054, T055, T056, T057 は並行実行可能 全 User Story の並行実行: Foundational (Phase 2) 完了後、Phase 3, 4, 5 は並行開始可能（異なる開発者、異なるファイル） Parallel Example: User Story 1 # テストを並行で作成（Phase 3 開始時） Task T013: WorktreeInfo model tests Task T014: BranchInfo model tests Task T015: CreateWorktreeOptions model tests Task T016: GitService tests Task T017: WorktreeService tests # モデルを並行で実装（テスト失敗確認後） Task T020: WorktreeInfo model Task T021: BranchInfo model Task T022: CreateWorktreeOptions model # インターフェースを並行で定義 Task T023: IGitService interface Task T025: IWorktreeService interface Implementation Strategy MVP First (User Story 1 のみ実装) ✅ Phase 1: Setup (T001-T004) ✅ Phase 2: Foundational (T005-T012) - CRITICAL ✅ Phase 3: User Story 1 (T013-T029) STOP and VALIDATE: wt create feature-test を実行して動作確認 MVP Ready: US1 のみでデプロイ可能 この時点で以下が動作: wt create <branch> で worktree 作成 デフォルトパス ../worktrees/<branch> に作成 エラー時の解決策表示 Incremental Delivery (優先度順) Setup + Foundational → 基盤完成 US1 → 独立テスト → デプロイ可能 (MVP!) US2 追加 → 独立テスト → デプロイ可能（エディター起動機能付き） US3 追加 → 独立テスト → デプロイ可能（カスタムパス対応） Polish → 全オプション完備 各 Story が前の Story を壊さずに価値を追加 Parallel Team Strategy 複数開発者の場合: チーム全員で Setup + Foundational を完成（T001-T012） Foundational 完了後: Developer A: US1 (T013-T029) - コア機能 Developer B: US2 (T030-T039) - エディター起動 Developer C: US3 (T040-T045) - カスタムパス 各 Story は独立して完成し、最後に統合 Quality Gates 各フェーズ完了時にチェック: ✅ 全テストが GREEN（失敗なし） ✅ コードカバレッジ 80% 以上 ✅ 憲章の全要件を満たす（12項目） ✅ 各 User Story が独立してテスト可能 ✅ ドキュメント最新（README, user-guide） Task Summary Phase Task Count Can Parallelize Description Phase 1: Setup 4 3 tasks プロジェクト初期化 Phase 2: Foundational 8 7 tasks 基盤実装（BLOCKING） Phase 3: US1 (P1) 17 11 tasks コア機能 - MVP Phase 4: US2 (P2) 10 6 tasks エディター起動 Phase 5: US3 (P3) 6 2 tasks カスタムパス Phase 6: Polish 15 11 tasks 仕上げ Total 60 40 全タスク Parallel Efficiency: 67% のタスクが並行実行可能（40/60） Estimated Timeline (1 developer): Phase 1: 0.5 day Phase 2: 2 days Phase 3 (US1): 3 days → MVP Ready (5.5 days total) Phase 4 (US2): 2 days Phase 5 (US3): 1.5 days Phase 6 (Polish): 2 days Total: ~11 days for full feature MVP Timeline: 5.5 days (Setup + Foundational + US1) Notes [P] = 並行実行可能（異なるファイル、依存関係なし） [Story] = User Story ラベル（US1, US2, US3）でタスクをトレース TDD必須: 全テストを実装前に作成し、RED（失敗）を確認 各 User Story は独立して完成・テスト可能 Checkpoint で独立動作を検証 小さく頻繁にコミット（各タスクまたは論理グループごと） 避けるべき: 曖昧なタスク、同一ファイルの競合、Story 間の強い依存関係 Suggested MVP Scope MVP = User Story 1 のみ 含まれる機能: ✅ wt create <branch> で worktree 作成 ✅ デフォルトパス ../worktrees/<branch> ✅ 現在のブランチをベースに新規ブランチ作成 ✅ エラーメッセージ + 解決策表示 ✅ ブランチ名バリデーション ✅ Git リポジトリチェック 含まれない機能（将来追加可能）: ❌ エディター自動起動（US2） ❌ カスタムパス指定（US3） ❌ JSON 出力 ❌ ベースブランチ指定 MVP で検証すること: 開発者が worktree を簡単に作成できるか？ git worktree の複雑なコマンドを隠蔽できているか？ エラーメッセージは理解しやすいか？ MVP が成功したら、US2, US3 を追加して機能拡張。"
  },
  "specs/001-github-pages-docs/MVP-SUMMARY.html": {
    "href": "specs/001-github-pages-docs/MVP-SUMMARY.html",
    "title": "MVP Implementation Summary - GitHub Pages Documentation Publishing | wt",
    "summary": "MVP Implementation Summary - GitHub Pages Documentation Publishing Feature Branch: 001-github-pages-docs Status: ✅ MVP Complete Date: 2026-01-16 Implementation Overview Successfully implemented the MVP for GitHub Pages documentation publishing system with automatic version management and comprehensive user documentation. Completed Phases Phase 1: Setup (3 tasks) ✅ Enabled XML documentation generation in wt.cli.csproj Verified DocFX configuration Created DocGenerator console project Commit: e8fb65f Phase 2: Foundational Infrastructure (8 tasks) ✅ Implemented command documentation generator framework Created GitHub Actions workflow for documentation deployment Added version extraction and manifest management Configured GitHub Pages deployment Commit: 231bc10 Phase 3: User Story 1 - Installation Guide (9 tasks) ✅ Created comprehensive installation guide with system requirements Added platform-specific instructions (Windows, macOS, Linux) Included troubleshooting section Created quick start guide with tutorials Commit: 66fda6c Phase 4: User Story 2 - Command Reference (8/9 tasks) ✅ Created command reference documentation (create, list) Added command overview with examples Enabled search functionality Updated navigation structure Commit: 1228633 Note: T021 (DocGenerator automation) deferred - command docs created manually Test Results Build Test ✅ docfx build docfx.json Status: Build succeeded with warnings Output: 107 HTML files generated Warnings: 18 (invalid file links - non-critical) Errors: 0 Generated Documentation ✅ ✅ Homepage (index.html) ✅ Installation guide (docs/installation.html) ✅ Quick start guide (docs/guides/quickstart.html) ✅ Command reference (docs/commands/index.html) ✅ create command (docs/commands/create.html) ✅ list command (docs/commands/list.html) ✅ API reference (api/) Deployment Readiness Prerequisites Met ✅ [x] Documentation builds without errors [x] All MVP user stories completed [x] GitHub Actions workflow configured [x] Version management system implemented [x] Search functionality enabled Deployment Strategy Automatic deployment on release: Create and publish a new release on GitHub GitHub Actions workflow triggers automatically Documentation builds with version number Deploys to GitHub Pages at https://<username>.github.io/wt/ Manual Test Deployment To test locally: # Build documentation docfx build docfx.json # Serve locally docfx serve _site Then open: http://localhost:8080 Success Criteria Met ✅ SC-001: New users can install the tool within 5 minutes ✅ SC-002: Users can find command documentation within 30 seconds ✅ SC-003: Documentation publishes automatically (workflow ready) Next Steps Immediate Create Pull Request to merge 001-github-pages-docs into main Create Release (e.g., v0.1.0) to trigger documentation deployment Verify documentation is published to GitHub Pages Future Enhancements (Separate Branches) Phase 5: Version switching UI (13 tasks) - Branch: 002-version-switcher Phase 6: API reference generation (8 tasks) - Branch: 003-api-docs Phase 7: Contributing guide (9 tasks) - Branch: 004-contributing Phase 8: Quality polish (10 tasks) - Branch: 005-docs-polish Known Issues T021 Pending: DocGenerator automation not fully implemented Impact: Low - Command docs can be maintained manually Workaround: Update markdown files directly in docs/commands/ Future: Complete automation in separate branch Build Warnings: 18 invalid file link warnings Impact: None - links work correctly Cause: DocFX strict checking of ~/ prefixed links Action: Can be resolved in Phase 8 (polish) Files Changed Total: 4 commits, 16 files added/modified Added Files .github/workflows/release.yml (enhanced with docs build job) .github/scripts/update-version-manifest.py docs/installation.md docs/guides/quickstart.md docs/commands/index.md docs/commands/create.md docs/commands/list.md Tools/DocGenerator/DocGenerator/ (project) Modified Files wt.cli/wt.cli.csproj docfx.json index.md docs/toc.yml specs/001-github-pages-docs/tasks.md Removed Files .github/workflows/docs.yml (merged into release.yml) Recommendations ✅ Ready to merge - MVP objectives achieved \uD83D\uDD04 Create release after merge to trigger first deployment \uD83D\uDCCB Create follow-up branches for Phase 5-8 before merging (to preserve work) \uD83E\uDDEA Test deployment by creating a release and verifying GitHub Pages Team Notes Branch will be auto-deleted after PR merge Phase 5+ should be implemented in separate feature branches Each phase is independently deployable Documentation can be incrementally improved Ready for Pull Request: ✅ YES Deployment Method: Automatic on release Estimated Deployment Time: 5-10 minutes (GitHub Actions)"
  },
  "specs/001-github-pages-docs/adr/001-consolidate-docs-workflow-into-release.html": {
    "href": "specs/001-github-pages-docs/adr/001-consolidate-docs-workflow-into-release.html",
    "title": "ADR 001: Consolidate Documentation Workflow into Release Pipeline | wt",
    "summary": "ADR 001: Consolidate Documentation Workflow into Release Pipeline Status: Accepted Date: 2026-01-16 Deciders: Development Team Related Issues: Bug fix for documentation not deploying on release Context The original design specified a separate .github/workflows/docs.yml workflow triggered by release.published events. However, this approach encountered a fundamental GitHub Actions limitation: GitHub Actions Security Constraint: When a workflow uses GITHUB_TOKEN to create a release (via softprops/action-gh-release), the release creation does NOT trigger other workflows to prevent recursive workflow execution. Impact: Documentation would never be built and deployed automatically after release creation, defeating the purpose of automated documentation publishing (FR-001). Decision We decided to consolidate the documentation build and deployment into the release workflow (.github/workflows/release.yml) as a dependent job named build-and-deploy-docs. Implementation # In .github/workflows/release.yml build-and-deploy-docs: name: Build and Deploy Documentation needs: [calculate-version, create-release] runs-on: ubuntu-latest steps: # ... documentation build steps Key Changes: Removed separate .github/workflows/docs.yml workflow Added build-and-deploy-docs job to release.yml Job depends on create-release job completion Version obtained from needs.calculate-version.outputs.version instead of github.event.release.tag_name Added caching for NuGet and DocFX to improve performance Updated actions to latest versions (checkout@v6, setup-dotnet@v5, cache@v5, gh-pages@v4) Alternatives Considered 1. Use Personal Access Token (PAT) instead of GITHUB_TOKEN Pros: Would allow separate workflow trigger Maintains original design separation Cons: Requires PAT with write permissions (security concern) PAT management overhead (rotation, expiration) Violates principle of least privilege Not suitable for open source projects (requires organization/user PAT) Rejected: Security and maintenance concerns outweigh architectural purity. 2. Use workflow_run trigger on: workflow_run: workflows: [\"Release to GitHub\"] types: [completed] Pros: Maintains workflow separation Uses GITHUB_TOKEN Cons: Introduces delay (wait for release workflow completion) More complex error handling (need to check workflow_run conclusion) Harder to debug (two separate workflow runs) Version information harder to pass between workflows Rejected: Added complexity without clear benefit. 3. Use repository_dispatch custom event Pros: Maximum flexibility Can pass custom payloads Cons: Requires additional API calls in release workflow More code to maintain Overkill for simple use case Rejected: Unnecessary complexity. Consequences Positive Works correctly: Documentation automatically deploys after release Simpler architecture: Single workflow, easier to understand and debug Better performance: Shared caching between release and docs jobs Consistent versioning: Version calculated once, used by both release and docs Atomic operation: Release and docs deployment happen in same workflow run No secrets required: Uses GITHUB_TOKEN throughout Negative Tighter coupling: Documentation deployment is now part of release workflow Cannot manually trigger docs rebuild: Would need to trigger entire release workflow or add separate docs-only workflow for maintenance Longer workflow time: Release workflow now includes documentation build time (adds ~3-5 minutes) All-or-nothing: If docs build fails, entire release workflow fails (can be mitigated with continue-on-error) Mitigation Strategies For the negative consequences: Manual docs rebuild: Can add a separate docs-manual.yml workflow with workflow_dispatch trigger for emergency documentation updates without creating a release Workflow time: Mitigated through caching (NuGet, DocFX) Build failures: Documentation build is final step, so release artifacts are already created and published before docs build Compliance This decision aligns with project constitution principles: III. Clean & Secure Code: Reduces complexity by consolidating workflows V. Minimal Dependencies: No additional dependencies or secrets required VI. Evidence-Based Development: Based on empirical testing of GitHub Actions behavior Notes This ADR should be referenced in specification contracts to explain the architectural decision Future work: Consider adding separate docs-manual.yml for emergency updates Monitor workflow execution time; if documentation build becomes bottleneck, revisit separation strategy with PAT approach References GitHub Actions Documentation: Triggering a workflow from a workflow Original spec: specs/001-github-pages-docs/spec.md Implementation: .github/workflows/release.yml Bug report: Documentation not deploying on release"
  },
  "specs/001-github-pages-docs/checklists/requirements.html": {
    "href": "specs/001-github-pages-docs/checklists/requirements.html",
    "title": "Specification Quality Checklist: GitHub Pages Documentation Publishing | wt",
    "summary": "Specification Quality Checklist: GitHub Pages Documentation Publishing Purpose: Validate specification completeness and quality before proceeding to planning Created: 2026-01-15 Feature: spec.md Content Quality [x] No implementation details (languages, frameworks, APIs) [x] Focused on user value and business needs [x] Written for non-technical stakeholders [x] All mandatory sections completed Requirement Completeness [x] No [NEEDS CLARIFICATION] markers remain [x] Requirements are testable and unambiguous [x] Success criteria are measurable [x] Success criteria are technology-agnostic (no implementation details) [x] All acceptance scenarios are defined [x] Edge cases are identified [x] Scope is clearly bounded [x] Dependencies and assumptions identified Feature Readiness [x] All functional requirements have clear acceptance criteria [x] User scenarios cover primary flows [x] Feature meets measurable outcomes defined in Success Criteria [x] No implementation details leak into specification Notes All checklist items have been validated and passed: Content Quality: The specification describes WHAT users need (documentation, installation guides, command references) and WHY (enable adoption, provide reference, support contributions) without specifying HOW to implement (no mention of static site generators, build tools, or specific technologies). Requirement Completeness: All 15 functional requirements are testable and unambiguous. No [NEEDS CLARIFICATION] markers present. Success criteria use measurable metrics (5 minutes for installation, 90% findability within 30 seconds, 10 minutes for auto-publish, 95% success rate for dev setup, 2-second load time) and are technology-agnostic (focused on user outcomes, not system internals). Feature Readiness: Each of the 5 prioritized user stories has clear acceptance scenarios with Given-When-Then format. Stories are independently testable and span the complete feature scope from installation to API reference to contribution. Edge cases identify potential issues with version handling, JavaScript availability, and documentation availability."
  },
  "specs/001-github-pages-docs/contracts/docfx-config-contract.html": {
    "href": "specs/001-github-pages-docs/contracts/docfx-config-contract.html",
    "title": "DocFX Configuration Contract | wt",
    "summary": "DocFX Configuration Contract File: docfx.json Purpose: Defines the contract for DocFX configuration to generate documentation from .NET projects and markdown files. Schema Reference { \"$schema\": \"https://raw.githubusercontent.com/dotnet/docfx/main/schemas/docfx.schema.json\" } Contract: MUST reference official DocFX v2 schema for validation. Metadata Section Purpose Extracts API documentation from .NET projects using Roslyn. Contract { \"metadata\": [ { \"src\": [ { \"src\": \"./wt.cli\", \"files\": [\"**/*.csproj\"] } ], \"output\": \"api\", \"shouldSkipMarkdeep\": false, \"properties\": { \"TargetFramework\": \"net10.0\" } } ] } Field Type Required Validation Purpose src[].src string Yes MUST be valid directory path Source project directory src[].files array Yes MUST match at least one .csproj file Project files to process output string Yes MUST be api Output directory for generated API docs shouldSkipMarkdeep boolean No Default: false Enable Markdeep rendering properties.TargetFramework string Yes MUST match project's <TargetFramework> Framework version for API extraction Validation Rules: src directory MUST exist relative to docfx.json At least one .csproj file MUST be found .csproj MUST have <GenerateDocumentationFile>true</GenerateDocumentationFile> Build MUST succeed in Release configuration API extraction MUST NOT fail on missing XML docs (warnings OK if not using --warningsAsErrors) Build Section Content Subsection Purpose: Defines documentation source files to include. Contract: { \"build\": { \"content\": [ { \"files\": [\"**/*.{md,yml}\"], \"exclude\": [ \"_site/**\", \"obj/**\", \"bin/**\", \"specs/**\", \".specify/**\", \"Tools/**\", \"coverage/**\" ] } ] } } Field Type Required Validation Purpose files array Yes MUST include markdown and/or YAML Content file patterns exclude array Yes MUST exclude build artifacts Directories to ignore Include Patterns: **/*.md - All markdown files (recursive) **/*.yml - YAML TOC and metadata files Exclude Patterns (REQUIRED): _site/** - DocFX output directory obj/**, bin/** - .NET build artifacts specs/** - Feature specifications (not user docs) .specify/** - Spec Kit internal files Tools/** - Build tools source code coverage/** - Test coverage reports Validation Rules: At least one markdown file MUST be found Excluded directories MUST NOT be scanned Invalid markdown syntax MUST cause build failure with --warningsAsErrors Resource Subsection Purpose: Defines static assets (images, CSS, JS) to copy. Contract: { \"build\": { \"resource\": [ { \"files\": [\"images/**\", \"assets/**\", \"*.png\", \"*.jpg\"] } ] } } Field Type Required Validation Purpose files array Yes Valid glob patterns Asset file patterns Include Patterns: images/** - Image directory (if exists) assets/** - General assets directory (if exists) *.png, *.jpg - Root-level images Validation Rules: Resources MUST be copied to output without modification Missing resources MUST NOT cause build failure (warning only) Binary files MUST be copied as-is Output and Template Purpose: Defines output directory and DocFX themes. Contract: { \"build\": { \"output\": \"_site\", \"template\": [\"default\", \"modern\"] } } Field Type Required Validation Purpose output string Yes MUST be valid directory name Output directory for generated site template array Yes MUST include at least one valid template DocFX themes to apply Template Options: default - Classic DocFX template modern - Modern, responsive template Custom templates can be added to templates/ directory Validation Rules: Output directory MUST be writable Templates MUST exist in DocFX installation or local templates/ directory Multiple templates are merged (modern overrides default) Global Metadata Purpose: Site-wide metadata injected into all pages. Contract: { \"build\": { \"globalMetadata\": { \"_appName\": \"wt\", \"_appTitle\": \"wt - Git Worktree Manager\", \"_appFooter\": \"Copyright © 2026 Kuju63. Licensed under MIT.\", \"_enableSearch\": true, \"_enableNewTab\": true, \"_gitHub\": { \"repo\": \"kuju63/wt\", \"branch\": \"main\" }, \"_gitContribute\": { \"repo\": \"kuju63/wt\", \"branch\": \"main\", \"path\": \"docs\" } } } } Field Type Required Validation Purpose _appName string Yes Non-empty Short application name _appTitle string Yes Non-empty Full application title for <title> _appFooter string No - Footer text on all pages _enableSearch boolean Yes MUST be true Enable client-side search _enableNewTab boolean No Default: false Open external links in new tab _gitHub.repo string Yes Format: owner/repo GitHub repository _gitHub.branch string Yes Valid branch name Default branch for links _gitContribute.repo string Yes Format: owner/repo Same as _gitHub.repo _gitContribute.branch string Yes Valid branch name Branch for \"Edit this page\" links _gitContribute.path string Yes Valid directory path Documentation source directory Validation Rules: All required fields MUST be present GitHub repo links MUST be valid format \"Edit this page\" links MUST point to correct documentation source Sitemap Configuration Purpose: SEO optimization via XML sitemap generation. Contract: { \"build\": { \"sitemap\": { \"baseUrl\": \"https://kuju63.github.io/wt/\", \"priority\": 1.0, \"changefreq\": \"weekly\" } } } Field Type Required Validation Purpose baseUrl string Yes MUST be valid HTTPS URL with trailing / Site base URL for sitemap priority number No Range: 0.0 - 1.0 Page priority for search engines changefreq string No Valid values: always, hourly, daily, weekly, monthly, yearly, never Expected update frequency Validation Rules: baseUrl MUST end with / baseUrl MUST use HTTPS protocol Sitemap MUST be generated at _site/sitemap.xml Cross-Reference Configuration Purpose: Enable linking to external API documentation. Contract: { \"build\": { \"xref\": [ \"https://learn.microsoft.com/en-us/dotnet/api\" ] } } Field Type Required Validation Purpose xref array No Valid URLs External API reference URLs Validation Rules: URLs MUST be accessible during build Cross-references to .NET types (e.g., System.String) automatically link to Microsoft Docs Failed xref lookups produce warnings (not errors) Complete Example Configuration { \"$schema\": \"https://raw.githubusercontent.com/dotnet/docfx/main/schemas/docfx.schema.json\", \"metadata\": [ { \"src\": [ { \"src\": \"./wt.cli\", \"files\": [\"**/*.csproj\"] } ], \"output\": \"api\", \"shouldSkipMarkdeep\": false, \"properties\": { \"TargetFramework\": \"net10.0\" } } ], \"build\": { \"content\": [ { \"files\": [\"**/*.{md,yml}\"], \"exclude\": [ \"_site/**\", \"obj/**\", \"bin/**\", \"specs/**\", \".specify/**\", \"Tools/**\", \"coverage/**\" ] } ], \"resource\": [ { \"files\": [\"images/**\", \"assets/**\", \"*.png\", \"*.jpg\"] } ], \"output\": \"_site\", \"template\": [\"default\", \"modern\"], \"globalMetadata\": { \"_appName\": \"wt\", \"_appTitle\": \"wt - Git Worktree Manager\", \"_appFooter\": \"Copyright © 2026 Kuju63. Licensed under MIT.\", \"_enableSearch\": true, \"_enableNewTab\": true, \"_gitHub\": { \"repo\": \"kuju63/wt\", \"branch\": \"main\" }, \"_gitContribute\": { \"repo\": \"kuju63/wt\", \"branch\": \"main\", \"path\": \"docs\" } }, \"sitemap\": { \"baseUrl\": \"https://kuju63.github.io/wt/\", \"priority\": 1.0, \"changefreq\": \"weekly\" }, \"xref\": [ \"https://learn.microsoft.com/en-us/dotnet/api\" ] } } Build Command Contract Standard Build docfx build docfx.json Output: Generates site in _site/ directory Warnings are logged but don't fail build Strict Build (Required for CI/CD) docfx build docfx.json --warningsAsErrors Output: Warnings cause build failure (exit code 1) Enforces documentation quality Versioned Build (For Deployment) docfx build docfx.json --warningsAsErrors -o _output/v1.2 Output: Generates site in custom output directory Used for version-specific documentation Validation Checklist Pre-Build Validation ✅ docfx.json is valid JSON ✅ Schema validation passes ✅ src directory exists ✅ At least one .csproj found ✅ .csproj has XML documentation enabled ✅ All required metadata fields present Build Validation ✅ .NET project builds successfully ✅ XML documentation generated ✅ Markdown files found ✅ No broken internal links ✅ TOC files (toc.yml) valid ✅ Templates applied successfully Post-Build Validation ✅ _site/ directory created ✅ _site/index.html exists ✅ _site/api/ directory exists (if API docs enabled) ✅ _site/sitemap.xml exists ✅ Search index (index.json) generated Common Issues and Solutions Issue Cause Solution \"Could not find file\" error Invalid src path Verify path relative to docfx.json No API documentation generated XML docs not enabled Add <GenerateDocumentationFile>true</GenerateDocumentationFile> to .csproj Broken link warnings Invalid markdown links Check [text](path) syntax and file existence Template not found Custom template missing Ensure template exists in templates/ or use built-in Cross-reference failures External xref URL down Check network connectivity, verify URL Version Compatibility DocFX Version .NET Version Status Notes 2.78.4 .NET 10.0 ✅ Supported Current version with Roslyn 4.13.0 2.77.x .NET 10.0 ⚠️ Partial May lack .NET 10 features 2.70.x .NET 10.0 ❌ Not supported Use 2.78.4+ Contract: MUST use DocFX 2.78.4 or later for .NET 10 support. Next: quickstart.md - Quick start guide for implementing the feature"
  },
  "specs/001-github-pages-docs/contracts/github-workflow-contract.html": {
    "href": "specs/001-github-pages-docs/contracts/github-workflow-contract.html",
    "title": "Documentation Deployment Workflow Contract | wt",
    "summary": "Documentation Deployment Workflow Contract File: .github/workflows/release.yml (build-and-deploy-docs job) Purpose: Defines the contract for the GitHub Actions workflow job that builds and deploys documentation to GitHub Pages as part of the release pipeline. Architecture Decision: See ADR 001: Consolidate Documentation Workflow into Release Pipeline for rationale behind integrating documentation build into release workflow instead of separate docs.yml. Workflow Inputs Trigger Events # Part of release.yml workflow needs: [calculate-version, create-release] Contract: MUST trigger after successful release creation Version is obtained from needs.calculate-version.outputs.version Integrated into release pipeline (no separate workflow trigger needed) Workflow Outputs Deployment URL outputs: page_url: description: \"URL of deployed documentation\" value: ${{ jobs.build-and-deploy.outputs.page_url }} Contract: MUST output the final GitHub Pages URL Format: https://{username}.github.io/{repo}/v{major}.{minor}/ Workflow Steps Contract Step 1: Extract Version Input: Version from needs.calculate-version.outputs.version (e.g., v0.1.0, v1.2.3) Output: Minor version string (e.g., v0.1, v1.2) Contract: # MUST extract minor version from calculated version - name: Extract version id: version run: | TAG_NAME=\"${{ needs.calculate-version.outputs.version }}\" # Extract major.minor from tag (e.g., v1.2.3 -> v1.2) VERSION=$(echo $TAG_NAME | grep -oE 'v?[0-9]+\\.[0-9]+') echo \"version=$VERSION\" >> $GITHUB_OUTPUT echo \"Extracted version: $VERSION\" Validation: Input version MUST match: v\\d+\\.\\d+\\.\\d+ (semantic versioning) Output MUST match: v\\d+\\.\\d+ MUST fail if version format is invalid Input Version Expected Output Rationale v0.1.0 v0.1 Initial release v0.10.5 v0.10 Pre-1.0 with higher minor v1.2.3 v1.2 Standard semantic version v10.15.20 v10.15 Large version numbers Step 2: Generate Command Documentation Input: CLI command definitions from wt.cli Output: Markdown files in docs/commands/ Contract: - name: Generate command documentation run: dotnet run --project Tools/DocGenerator/DocGenerator -- --output docs/commands Validation: MUST generate one .md file per command in docs/commands/ MUST exit with code 0 on success MUST exit with non-zero if generation fails Step 3: Build Documentation Input: Markdown files, docfx.json, XML docs from wt.cli Output: Static HTML site in _site/{version}/ Contract: - name: Build documentation run: | docfx metadata docfx build --output _site/${{ steps.version.outputs.version }} Validation: MUST generate API metadata from XML comments MUST output to version-specific directory MUST generate HTML/CSS/JS files MUST exit with code 0 on success Note: Link validation and --warningsAsErrors flag are deferred to Phase 8 (Polish & Cross-Cutting Concerns) as quality improvements, not MVP requirements. Step 4: Update Version Manifest Input: New version from previous step Output: Updated versions.json in _site/ Contract: - name: Update version manifest run: | python3 .github/scripts/update-version-manifest.py _site/versions.json ${{ steps.version.outputs.version }} cp _site/versions.json _site/${{ steps.version.outputs.version }}/versions.json Validation: MUST add new version to manifest MUST mark new version as isLatest: true MUST remove isLatest from all other versions MUST sort versions by version string (descending) MUST automatically generate publishedDate with UTC timestamp MUST be idempotent (re-running updates, doesn't duplicate) MUST exit with code 0 on success Python Script Contract (.github/scripts/update-version-manifest.py): # MUST accept positional arguments: <manifest_path> <version> # Usage: update-version-manifest.py <manifest_path> <version> # MUST read existing manifest from path (or create empty if missing) # MUST update/add version entry with auto-generated publishedDate # MUST write valid JSON output to same path # MUST exit 0 on success, non-zero on error Step 5: Deploy to GitHub Pages Input: Built site in _site/ Output: Deployed documentation on GitHub Pages Contract: - name: Deploy to GitHub Pages uses: peaceiris/actions-gh-pages@v4 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./_site keep_files: true Validation: MUST deploy entire _site directory MUST preserve existing version directories (keep_files: true) MUST use GITHUB_TOKEN for authentication MUST exit with code 0 on successful deployment Note: The peaceiris/actions-gh-pages action handles manifest fetching internally through keep_files: true, eliminating the need for explicit gh-pages branch fetching. --no-warnings _output/${{ steps.version.outputs.minor }}/ **Note**: The peaceiris/actions-gh-pages action handles manifest fetching internally through keep_files: true, eliminating the need for explicit gh-pages branch fetching. ## Error Handling | Error Condition | Required Behavior | Exit Code | |-----------------|-------------------|-----------| | Invalid version tag format | Fail with clear error message | 1 | | Version extraction fails | Stop workflow immediately | 1 | | Command doc generation fails | Stop workflow, show error | 1 | | DocFX metadata generation fails | Stop workflow, show error | 1 | | DocFX build fails | Stop workflow, show build errors | 1 | | Version manifest update fails | Stop workflow, show Python error | 1 | | GitHub Pages deployment fails | Handled by peaceiris action (auto-retry) | 1 | **Note**: Link validation and `--warningsAsErrors` are deferred to Phase 8 as quality improvements. ## Performance Requirements | Metric | Target | Maximum | Success Criteria | |--------|--------|---------|------------------| | Total workflow duration | <8 minutes | 10 minutes | SC-003 compliance | | Command doc generation | <30 seconds | 1 minute | - | | DocFX metadata + build | <3 minutes | 5 minutes | Combined step | | Manifest update | <10 seconds | 30 seconds | - | | Deployment time | <1 minute | 2 minutes | - | **Note**: Performance targets reflect integrated workflow within release pipeline. Caching (NuGet, DocFX) improves performance significantly. ## Security Requirements 1. **Authentication**: - MUST use OIDC token authentication - MUST NOT use long-lived Personal Access Tokens (PAT) 2. **Permissions**: - MUST use principle of least privilege - Required: `contents: write`, `pages: write`, `id-token: write` - MUST NOT request additional permissions 3. **Secrets**: - MUST NOT expose secrets in workflow logs - MUST NOT log version manifest content (may contain dates/metadata) 4. **Input Validation**: - Python script MUST NOT execute arbitrary code from JSON - Version string MUST be validated before use in paths ## Dependencies ### External Actions ```yaml - actions/checkout@v6 - actions/setup-dotnet@v5 - actions/cache@v5 - peaceiris/actions-gh-pages@v4 Contract: MUST pin to specific major versions (e.g., @v6, not @v6.1.0) MUST NOT use @main or @latest MUST update via Renovate (configured in repository) External Tools Tool Version Installation Method docfx 2.78.4 (exact) dotnet tool install --global docfx --version 2.78.4 python3 3.x Pre-installed on ubuntu-latest Contract: DocFX version MUST be pinned via DOCFX_VERSION environment variable Python 3 MUST be available Link validation tools deferred to Phase 8 Concurrency Control concurrency: group: pages cancel-in-progress: false Contract: MUST use group: pages to prevent concurrent deploys MUST set cancel-in-progress: false to allow queuing Multiple releases MUST queue (not run in parallel) In-progress deployments MUST complete before next starts Environment Configuration Required Environment environment: name: github-pages url: ${{ steps.deployment.outputs.page_url }} Setup Steps: Repository Settings → Environments → New environment Name: github-pages Optional: Add protection rules (approval, wait timer) Contract: Environment MUST exist before first workflow run Environment MUST have Pages deployment permissions Environment URL is automatically set by deploy-pages action Required Permissions permissions: contents: write # Fetch gh-pages branch pages: write # Deploy to GitHub Pages id-token: write # OIDC authentication Backward Compatibility First Release: Workflow MUST create gh-pages branch if it doesn't exist Existing Versions: Workflow MUST preserve existing version directories (v1.0/, v1.1/, etc.) Manifest Format: Adding fields OK, removing fields NOT OK URL Structure: Version URLs MUST remain stable (SC-006: 2+ years) Testing Contract Pre-Deployment Validation Checklist ✅ Version extraction produces valid v{major}.{minor} format ✅ Command documentation generated for all commands ✅ API build succeeds in Release configuration ✅ DocFX build succeeds with --warningsAsErrors ✅ Link validation passes (zero broken links) ✅ Version manifest is valid JSON Post-Deployment Verification Checklist ✅ Deployed URL returns HTTP 200 ✅ Version manifest loads successfully ✅ New version appears in version switcher dropdown ✅ Version switcher navigation works ✅ Internal links between pages work ✅ API reference pages load correctly Example Workflow Execution Scenario: Release v0.2.5 1. Release published: v0.2.5 2. Extract version: v0.2 3. Generate command docs: docs/commands/*.md created 4. Build API: wt.xml generated 5. Build DocFX: _output/v0.2/ created with HTML 6. Fetch manifest: Found with [v0.1] 7. Update manifest: Add v0.2, mark as latest 8. Validate links: All OK (0 broken) 9. Deploy: https://username.github.io/wt/v0.2/ 10. Output: page_url = https://username.github.io/wt/v0.2/ Scenario: First Release v0.1.0 1. Release published: v0.1.0 2. Extract version: v0.1 3. Generate command docs: docs/commands/*.md created 4. Build API: wt.xml generated 5. Build DocFX: _output/v0.1/ created 6. Fetch manifest: None found, create empty {\"versions\":[]} 7. Update manifest: Add v0.1 (first entry, marked latest) 8. Validate links: All OK 9. Deploy: Create gh-pages branch, deploy v0.1/ 10. Output: page_url = https://username.github.io/wt/v0.1/ Next: docfx-config-contract.md - Contract for DocFX configuration"
  },
  "specs/001-github-pages-docs/data-model.html": {
    "href": "specs/001-github-pages-docs/data-model.html",
    "title": "Data Model: GitHub Pages Documentation Publishing | wt",
    "summary": "Data Model: GitHub Pages Documentation Publishing Feature: 001-github-pages-docs Date: 2026-01-15 Phase: Phase 1 - Design This document defines the key entities, their attributes, relationships, and validation rules for the GitHub Pages documentation publishing feature. Entities 1. Documentation Version Represents a specific minor version of the documentation (e.g., v1.0, v1.1, v2.0). Attribute Type Required Description Validation Rules label string Yes Display name in version switcher (e.g., \"v1.0 (latest)\") Must match pattern: v\\d+\\.\\d+( \\(latest\\))? path string Yes URL path segment for this version Must match pattern: v\\d+\\.\\d+ released datetime Yes ISO 8601 timestamp of release Must be valid ISO 8601 format isLatest boolean Yes Whether this is the latest version Only one version can have isLatest: true Relationships: Has many: Documentation Pages Has many: Command Documentation Pages Has one: API Reference Section State Transitions: [New Release] → Version Created (isLatest=true) ↓ All other versions: isLatest → false ↓ Version Published to GitHub Pages Business Rules: Exactly one version must be marked as isLatest: true at all times Version path must be unique across all versions Versions are immutable once published (no content changes to deployed versions) Minor version level only (patch versions share documentation: v1.0.0, v1.0.1, v1.0.2 → all use v1.0) Example: { \"label\": \"v1.2 (latest)\", \"path\": \"v1.2\", \"released\": \"2026-01-15T10:30:00Z\", \"isLatest\": true } 2. Version Manifest Aggregates all available documentation versions for the version switcher UI. Attribute Type Required Description Validation Rules versions array Yes List of Documentation Version objects Must contain at least 1 version Relationships: Contains many: Documentation Versions (aggregation) State Transitions: [First Release] → Empty manifest → First version added ↓ [New Release] → Fetch existing → Update with new version → Deploy Business Rules: Stored at GitHub Pages root: /version-manifest.json Copied to each version directory for redundancy Automatically updated on every release Sorted by release date (newest first) Idempotent updates (re-running same version updates timestamp, doesn't duplicate) Example: { \"versions\": [ { \"label\": \"v1.1 (latest)\", \"path\": \"v1.1\", \"released\": \"2026-01-15T10:30:00Z\", \"isLatest\": true }, { \"label\": \"v1.0\", \"path\": \"v1.0\", \"released\": \"2026-01-01T14:20:00Z\", \"isLatest\": false } ] } 3. Command Documentation Page Represents documentation for a single CLI command. Attribute Type Required Description Validation Rules commandName string Yes Name of the command (e.g., \"create\") Must match existing CLI command description string Yes Command purpose and overview Non-empty, extracted from System.CommandLine usage string Yes Syntax pattern Format: wt {commandName} [options] options array No List of command options Each option must have aliases, description examples array Yes Usage examples At least 1 example required filePath string Yes Markdown file location Format: docs/commands/{commandName}.md Relationships: Belongs to: Documentation Version Generated from: CLI Command Definition (wt.cli RootCommand) State Transitions: [CLI Code Change] → DocGenerator extracts metadata → Markdown generated → DocFX builds → HTML deployed Business Rules: Auto-generated from System.CommandLine definitions (no manual editing) One markdown file per command Must exist for every command in wt.cli RootCommand.Subcommands Regenerated on every documentation build Examples are manually curated in DocGenerator code Example: # wt create Create a new Git worktree with optional editor integration. ## Usage ```bash wt create [options] <branch-name> Options --path, -p Custom path for the worktree directory. Type: string --editor, -e Editor to open after creation (vscode, vim, emacs). Type: string Examples Create worktree with default path wt create feature-login Create with custom path wt create feature-login --path /tmp/wt-login --- ### 4. API Reference Section Generated documentation for all public APIs in wt.cli project. **Attributes**: | Attribute | Type | Required | Description | Validation Rules | |-----------|------|----------|-------------|-----------------| | `namespace` | string | Yes | .NET namespace (e.g., \"Kuju63.WorkTree.CommandLine\") | Valid .NET namespace | | `classes` | array | Yes | Public classes with XML docs | Auto-generated by DocFX | | `interfaces` | array | Yes | Public interfaces with XML docs | Auto-generated by DocFX | | `outputPath` | string | Yes | Generated files location | `api/` directory | **Relationships**: - Belongs to: Documentation Version - Generated from: wt.cli.csproj XML documentation **State Transitions**: [Build wt.cli] → Generate XML docs → DocFX metadata extraction → API HTML generation → Deployment **Business Rules**: - 100% auto-generated from XML documentation comments (per SC-007) - Requires `<GenerateDocumentationFile>true</GenerateDocumentationFile>` in .csproj - Only public types and members are documented - Cross-references to .NET framework via xref configuration - Must build successfully for Release configuration **Example Structure**: api/ ├── Kuju63.WorkTree.CommandLine.html ├── Kuju63.WorkTree.CommandLine.Commands.html ├── Kuju63.WorkTree.CommandLine.Commands.CreateCommand.html └── toc.yml --- ### 5. Installation Guide Platform-specific instructions for installing the self-contained native binary. **Attributes**: | Attribute | Type | Required | Description | Validation Rules | |-----------|------|----------|-------------|-----------------| | `platforms` | array | Yes | Supported platforms (Windows, macOS, Linux) | Must cover: win-x64, linux-x64, linux-arm, osx-arm64 | | `downloadLinks` | array | Yes | Links to GitHub release assets per platform | Must reference actual release artifacts | | `installationSteps` | array | Yes | Step-by-step instructions per platform | At least 2 steps per platform (download + install) | | `verificationCommand` | string | Yes | Command to verify installation | Must be: `wt --version` or `wt --help` | | `filePath` | string | Yes | Markdown file location | `docs/installation.md` | **Relationships**: - Belongs to: Documentation Version - Referenced by: Homepage (primary entry point per SC-001) **State Transitions**: [Manual Creation] → Version-specific review → Committed to repository → Built by DocFX **Business Rules**: - **NO .NET SDK required** - binary is self-contained native application - **NO Git required for installation** - only needed for actual worktree operations - Manually authored markdown file - Must be complete before v1.0 release - Updated when installation process changes - Platform-specific sections clearly marked with OS names - Must include troubleshooting section for common issues **Example Sections**: ```markdown # Installation ## System Requirements - **Windows**: Windows 10 or later (x64) - **macOS**: macOS 11 or later (ARM64/Apple Silicon) - **Linux**: x64 or ARM architecture **Note**: No .NET SDK or Git installation required for the `wt` tool itself. Git is only needed when you actually use worktrees. ## Download Download the appropriate binary for your platform from the [latest release](https://github.com/kuju63/wt/releases/latest): - **Windows**: `wt-win-x64.zip` - **macOS**: `wt-osx-arm64.tar.gz` - **Linux (x64)**: `wt-linux-x64.tar.gz` - **Linux (ARM)**: `wt-linux-arm.tar.gz` ## Windows Installation 1. Download `wt-win-x64.zip` from releases 2. Extract to `C:\\Program Files\\wt\\` (or any preferred location) 3. Add to PATH: ```powershell setx PATH \"%PATH%;C:\\Program Files\\wt\" Restart terminal Verify installation: wt --version macOS Installation Download wt-osx-arm64.tar.gz Extract and move to /usr/local/bin: tar -xzf wt-osx-arm64.tar.gz sudo mv wt /usr/local/bin/ sudo chmod +x /usr/local/bin/wt Verify installation: wt --version Linux Installation Download the appropriate archive for your architecture Extract and install: tar -xzf wt-linux-x64.tar.gz sudo mv wt /usr/local/bin/ sudo chmod +x /usr/local/bin/wt Verify installation: wt --version Troubleshooting Command not found Ensure the wt binary is in your PATH On Windows, restart your terminal after updating PATH Permission denied (macOS/Linux) Run: sudo chmod +x /usr/local/bin/wt Git not found Install Git separately: git --version to check Only required when actually using worktree commands --- ### 6. Contribution Guide Guidelines for contributing code, documentation, or bug reports to the project. **Attributes**: | Attribute | Type | Required | Description | Validation Rules | |-----------|------|----------|-------------|-----------------| | `developmentSetup` | section | Yes | Environment setup instructions | Must include .NET SDK requirement (for development only) | | `codingStandards` | section | Yes | Reference to constitution principles | Must link to constitution.md | | `pullRequestProcess` | section | Yes | PR submission guidelines | Step-by-step process | | `issueTemplates` | section | Yes | Bug report and feature request formats | Link to GitHub issue templates | | `filePath` | string | Yes | Markdown file location | `docs/contributing.md` | **Relationships**: - Belongs to: Documentation Version - References: Project Constitution (.specify/memory/constitution.md) **State Transitions**: [Manual Creation] → Constitution alignment check → Committed → Built by DocFX **Business Rules**: - Must align with Constitution principles (especially III, V, VI) - Must reference TDD workflow (Constitution VI) - Must include code of conduct link - **Clearly distinguish**: User installation (no .NET) vs. Developer setup (.NET SDK required) - Language: Primarily Japanese with English technical terms **Example Sections**: ```markdown # Contributing to wt ## Development Environment Setup **Note**: Unlike user installation, development requires the .NET SDK. ### Prerequisites for Development - .NET 10.0 SDK or later - Git 2.5 or later - Your preferred editor (VS Code, Rider, Visual Studio) ### Setup Steps 1. Clone repository: `git clone https://github.com/kuju63/wt.git` 2. Restore dependencies: `dotnet restore` 3. Build: `dotnet build` 4. Run tests: `dotnet test` 5. Run locally: `dotnet run --project wt.cli -- create test-branch` ## Coding Standards This project follows the principles defined in our [Constitution](../.specify/memory/constitution.md): - **TDD (Test-Driven Development)** required for all features - **Minimal dependencies** - justify each new package - **Clean and secure code** - pass all static analysis ## Pull Request Process 1. Create feature branch from main 2. Write tests first (TDD) 3. Implement feature 4. Ensure all tests pass: `dotnet test` 5. Update documentation if needed 6. Submit PR with clear description ## Reporting Issues Use GitHub issue templates: - Bug Report: Include `wt --version` output and repro steps - Feature Request: Describe use case and proposed solution Entity Relationship Diagram ┌─────────────────────────┐ │ Version Manifest │ │ (version-manifest.json)│ └────────┬────────────────┘ │ contains * ▼ ┌─────────────────────────┐ │ Documentation Version │ ◄─┐ │ (v1.0/, v1.1/, ...) │ │ └────────┬────────────────┘ │ │ has * │ belongs to ├────────────────────┼─────────────┐ │ │ │ ▼ │ │ ┌─────────────────────────┐ │ │ │ Command Documentation │ │ │ │ (commands/*.md) │──┘ │ └─────────────────────────┘ │ │ ┌─────────────────────────────────┤ │ │ ▼ │ ┌─────────────────────────┐ │ │ API Reference │ │ │ (api/*) │────────────────┘ └─────────────────────────┘ ┌─────────────────────────────────┤ │ │ ▼ │ ┌─────────────────────────┐ │ │ Installation Guide │ │ │ (docs/installation.md) │────────────────┘ └─────────────────────────┘ ┌─────────────────────────────────┘ │ ▼ ┌─────────────────────────┐ │ Contribution Guide │ │ (docs/contributing.md) │ └─────────────────────────┘ Data Flow Documentation Build Flow 1. Release Published (GitHub Event) ↓ 2. Extract Version (v1.2.3 → v1.2) ↓ 3. Generate Command Docs (Tools/DocGenerator) ↓ 4. Build API Docs (wt.cli XML → DocFX metadata) ↓ 5. Build Static Site (DocFX → HTML/CSS/JS) ↓ 6. Fetch Existing Manifest (gh-pages branch) ↓ 7. Update Manifest (Python script) ↓ 8. Validate Links (LinkChecker) ↓ 9. Deploy to GitHub Pages (v1.2/ directory + manifest) Version Switcher Flow 1. User loads documentation page ↓ 2. JavaScript fetches /version-manifest.json ↓ 3. Populate dropdown with versions ↓ 4. Detect current version from URL (/v1.2/...) ↓ 5. Pre-select in dropdown ↓ 6. User selects different version ↓ 7. Extract path without version (e.g., /installation.html) ↓ 8. Navigate to /v1.1/installation.html Validation Rules Summary Entity Key Validation Error Handling Documentation Version Only one isLatest: true Python script enforces, removes from others Version Manifest At least 1 version Build fails if empty after update Command Documentation Must exist for all CLI commands DocGenerator throws if command missing API Reference XML docs must build successfully dotnet build fails → deployment stops Installation Guide No .NET/Git prerequisites mentioned for users Manual PR review verification Contribution Guide .NET SDK required for developers only Manual PR review verification Storage and Persistence Entity Storage Location Format Persistence Strategy Version Manifest /version-manifest.json on gh-pages JSON Updated on every release, versioned in git history Documentation Version /v{major}.{minor}/ directory Static HTML/CSS/JS Immutable once published, kept for 2+ years (SC-006) Command Docs docs/commands/*.md (source) Markdown → HTML Auto-generated, committed to main branch API Reference api/ directory (generated) HTML Auto-generated, not committed (build artifact) Installation Guide docs/installation.md (source) Markdown → HTML Manually authored, committed to main branch Contribution Guide docs/contributing.md (source) Markdown → HTML Manually authored, committed to main branch Platform-Specific Binary Mapping Platform Runtime Identifier Release Asset Name Installation Path Windows x64 win-x64 wt-win-x64.zip C:\\Program Files\\wt\\ (or user choice) macOS ARM64 osx-arm64 wt-osx-arm64.tar.gz /usr/local/bin/ Linux x64 linux-x64 wt-linux-x64.tar.gz /usr/local/bin/ Linux ARM linux-arm wt-linux-arm.tar.gz /usr/local/bin/ Key Point: All binaries are self-contained with PublishSingleFile=true and SelfContained=true. No runtime dependencies required for end users. Future Considerations Automatic Update Mechanism (Not in Current Scope) Self-update command: wt update Check for new versions on startup? Auto-download and replace binary? Package Manager Distribution (Not in Current Scope) Windows: winget install wt macOS: brew install wt Linux: apt install wt / snap install wt Deprecation Strategy (Not in Current Scope) When to remove old versions from GitHub Pages? Archive location for deprecated versions? User notification for deprecated versions? Next Steps: Create contracts/ directory with schema definitions for GitHub Actions workflow and DocFX configuration."
  },
  "specs/001-github-pages-docs/plan.html": {
    "href": "specs/001-github-pages-docs/plan.html",
    "title": "Implementation Plan: GitHub Pages Documentation Publishing | wt",
    "summary": "Implementation Plan: GitHub Pages Documentation Publishing Branch: 001-github-pages-docs | Date: 2026-01-15 | Spec: spec.md Input: Feature specification from /specs/001-github-pages-docs/spec.md Note: This template is filled in by the /speckit.plan command. See .specify/templates/commands/plan.md for the execution workflow. Summary Automate the publishing of comprehensive documentation to GitHub Pages synchronized with binary releases. The documentation includes Installation Guide, Command Reference, API Reference, and Contribution Guide with version-specific access at the minor version level (v1.0, v1.1, etc.). The system will use DocFX (already configured) to generate static documentation from markdown files and XML documentation comments, deployed via GitHub Actions to GitHub Pages whenever a new release is created. Technical Context Language/Version: C# / .NET 10.0 Primary Dependencies: DocFX 2.78.4 (documentation generator, .NET global tool) System.CommandLine 2.0.2 (for CLI command documentation extraction) GitHub Actions (for CI/CD automation) GitHub Pages (for hosting) Storage: Static files (markdown, generated HTML/CSS/JS) Testing: DocFX build validation with --warningsAsErrors flag LinkChecker for link validation Target Platform: GitHub Pages static hosting (cross-platform access via web browser) Project Type: Single project with documentation output (static site generator workflow) Performance Goals: Documentation site loads within 2 seconds on standard broadband (per SC-007) Build and publish within 10 minutes of release (per SC-003) Constraints: Version-specific URLs must remain stable for 2+ years (architectural constraint via GitHub Pages) Must maintain documentation for each minor version independently (per FR-011) No backend/database - pure static site architecture Scale/Scope: Initial: 5-10 documentation pages per version API Reference: Generated from all public APIs in wt.cli project Estimated versions to support simultaneously: 3-5 minor versions Documentation format: Markdown source → DocFX → Static HTML Constitution Check GATE: Must pass before Phase 0 research. Re-check after Phase 1 design. Initial Check (Pre-Phase 0) I. Developer Usability (CLI優先) ✅ PASS - Documentation enhances CLI usability by providing comprehensive command reference and examples. This feature supports the CLI-first approach rather than replacing it. II. Cross-Platform (クロスプラットフォーム対応) ✅ PASS - GitHub Pages documentation is accessible from any platform via web browser. DocFX-generated sites are pure HTML/CSS/JS with no platform dependencies. III. Clean & Secure Code (クリーンでセキュアなコード) ✅ PASS - Static documentation poses minimal security risk. No secrets will be embedded in documentation. GitHub Actions workflow will use repository secrets for deployment tokens. All generated content is public-facing and contains no sensitive information. IV. Documentation Clarity (ドキュメントの明瞭性) ✅ PASS - This feature directly implements this principle. Documentation will be primarily in Japanese (as specified in constitution) with technical terms in English. Technical decisions about documentation architecture will be recorded as ADRs. V. Minimal Dependencies (最小限の依存関係) ⚠️ REQUIRES JUSTIFICATION - Adding DocFX as a documentation dependency. Justification: DocFX is specifically designed for .NET projects and can generate API documentation from XML comments. Alternatives like Sphinx (Python-focused), MkDocs (lacks API generation for .NET), or custom solution (high maintenance burden) are less suitable. Risk Mitigation: DocFX is maintained by Microsoft/.NET Foundation, reducing supply chain risk. We will pin specific versions and monitor for vulnerabilities. VI. Comprehensive Testing (テストの充実と自動化) ✅ PASS (RESOLVED) - Testing strategy defined in research.md: Layer 1: DocFX build-time validation with --warningsAsErrors Layer 2: LinkChecker for link validation No xUnit tests required for static documentation content Command documentation generation is part of build pipeline (fails if commands missing) VII. Quantitative Thresholds (閾値) ✅ PASS - Documentation build workflow is automation code, not production code. Standard code quality thresholds apply to any custom scripts. Documentation content itself follows clarity and completeness metrics defined in success criteria (SC-001 through SC-007). Post-Design Re-Evaluation (After Phase 1) I. Developer Usability (CLI優先) ✅ CONFIRMED - Design maintains CLI-first focus: Command documentation auto-generated from CLI definitions No separate documentation maintenance burden Users access docs via web (universal accessibility) II. Cross-Platform (クロスプラットフォーム対応) ✅ CONFIRMED - Implementation is platform-agnostic: GitHub Pages works on all browsers No platform-specific deployment requirements DocFX builds on ubuntu-latest runner (Linux) III. Clean & Secure Code (クリーンでセキュアなコード) ✅ CONFIRMED - Security measures implemented: OIDC authentication (no long-lived tokens) Minimal permissions (contents: write, pages: write, id-token: write) Python manifest script validates JSON without arbitrary code execution No secrets exposed in logs or deployed content IV. Documentation Clarity (ドキュメントの明瞭性) ✅ CONFIRMED - Documentation structure supports clarity: Installation guide explains no .NET/Git required for end users Contribution guide clarifies .NET SDK required for developers only Clear separation of user vs. developer documentation Version-specific documentation prevents confusion V. Minimal Dependencies (最小限の依存関係) ✅ JUSTIFIED - Dependency analysis post-design: DocFX 2.78.4: Pinned version, Microsoft/.NET Foundation maintained LinkChecker: Build-time only, not runtime dependency Python 3: Pre-installed on GitHub runners, no additional installation System.CommandLine: Already used in wt.cli, no new dependency Total new dependencies: 1 (DocFX) + 1 build-time (LinkChecker) Risk level: LOW - Both are well-maintained tools with established ecosystems VI. Comprehensive Testing (テストの充実と自動化) ✅ CONFIRMED - Two-layer testing strategy validated: Build validation catches markdown errors, broken internal links Link validation catches broken external links, missing resources Command documentation generation failures caught in build pipeline Manual testing not required due to automation No TDD required: Documentation is build artifact, not executable code VII. Quantitative Thresholds (閾値) ✅ CONFIRMED - Custom scripts meet quality standards: Tools/DocGenerator/Program.cs: Will follow standard C# code quality rules .github/scripts/update-version-manifest.py: Simple script (<100 LOC), single responsibility GitHub Actions YAML: Declarative configuration, no complex logic All scripts subject to PR review and linting Final Verdict ✅ ALL GATES PASSED Justifications Accepted: DocFX dependency justified due to .NET-specific API documentation generation needs No xUnit tests for static documentation content (validated through build process) Action Items for Implementation: Pin DocFX version to 2.78.4 in workflow Ensure Python manifest script has input validation Add linting for Python script (optional: pylint or black) Document dependency justification in ADR (if constitutional amendment process requires) Ready to proceed to Phase 2 (Task Generation) Project Structure Documentation (this feature) specs/005-github-pages-docs/ ├── plan.md # This file (/speckit.plan command output) ├── research.md # Phase 0 output (/speckit.plan command) ├── data-model.md # Phase 1 output (/speckit.plan command) ├── quickstart.md # Phase 1 output (/speckit.plan command) ├── contracts/ # Phase 1 output (/speckit.plan command) │ ├── github-workflow-schema.yml # GitHub Actions workflow contract │ └── docfx-config-schema.json # DocFX configuration schema └── tasks.md # Phase 2 output (/speckit.tasks command - NOT created by /speckit.plan) Source Code (repository root) wt/ (repository root) ├── .github/ │ └── workflows/ │ ├── release.yml # [MODIFY] Add docs deployment step │ └── docs.yml # [NEW] Dedicated docs build/deploy workflow ├── docs/ # [EXISTING] Documentation source │ ├── index.md # [MODIFY] Enhanced homepage │ ├── installation.md # [NEW] Installation guide │ ├── commands/ # [NEW] Command reference section │ │ ├── index.md # Command overview │ │ ├── create.md # wt create documentation │ │ └── list.md # wt list documentation │ ├── api/ # [AUTO-GENERATED] API reference │ ├── contributing.md # [NEW] Contribution guide │ ├── guides/ # [EXISTING] Extended with new content │ │ └── quickstart.md # [NEW] Quick start guide │ ├── ja/ # [EXISTING] Japanese versions │ │ ├── index.md │ │ ├── installation.md │ │ └── ... │ └── toc.yml # [MODIFY] Table of contents ├── wt.cli/ │ └── wt.cli.csproj # [VERIFY] XML documentation enabled ├── docfx.json # [EXISTING] DocFX configuration ├── index.md # [EXISTING] Root index └── toc.yml # [EXISTING] Root ToC Build Output Structure: _site/ # DocFX build output ├── v1.0/ # Version-specific docs │ ├── index.html │ ├── installation.html │ ├── commands/ │ ├── api/ │ └── ... ├── v1.1/ # Next version │ └── ... └── index.html # Latest version redirect Structure Decision: Using single project structure with DocFX documentation generator. The existing docs/ directory structure is preserved and extended. DocFX generates static HTML into _site/ directory which is deployed to GitHub Pages. Version-specific documentation is organized by creating separate build outputs for each minor version (v1.0/, v1.1/, etc.) within the GitHub Pages branch (gh-pages). Complexity Tracking Violation Why Needed Simpler Alternative Rejected Because Adding DocFX dependency DocFX provides .NET-native API documentation generation from XML comments and markdown processing with versioning support MkDocs: Cannot generate .NET API docs from XML; Sphinx: Python-focused, poor .NET integration; Custom HTML: High maintenance burden and no API extraction capability Implementation Summary Artifacts Generated (Phase 1 Complete) ✅ Research Phase (Phase 0): research.md - Comprehensive research on DocFX, testing strategies, version switching, and automation ✅ Design Phase (Phase 1): data-model.md - Entity definitions and relationships for documentation system contracts/github-workflow-contract.md - GitHub Actions workflow specification contracts/docfx-config-contract.md - DocFX configuration specification quickstart.md - Step-by-step implementation guide (4-6 hours estimated) ✅ Agent Context: AGENTS.md - Updated with documentation automation guidance Key Decisions DocFX 2.78.4: Selected for .NET 10 support and native API documentation generation Command Automation: System.CommandLine HelpBuilder for programmatic documentation export Testing Strategy: Two-layer approach (build validation + link checking) Version Management: Python script auto-updates manifest per release No xUnit Tests: Static documentation validated through build process, not unit tests Dependencies Added Dependency Version Type Justification DocFX 2.78.4 Build tool .NET-native API doc generation, Microsoft/.NET Foundation maintained LinkChecker latest Build tool Link validation in CI/CD pipeline Python 3 3.x Runtime Pre-installed on GitHub runners, manifest management Architecture Highlights Versioned Structure: /v{major}.{minor}/ directories for each version Version Switcher: JavaScript-based UI with version-manifest.json backend Automated Pipeline: Release trigger → Doc generation → Build → Validate → Deploy Zero Manual Maintenance: Command docs auto-generated from CLI code Success Criteria Mapping Requirement Implementation Status FR-001 (Auto-publish on release) GitHub Actions workflow triggered on release.published ✅ Designed FR-002 (Installation guide) docs/installation.md with platform-specific instructions ✅ Designed FR-003 (Command reference) Auto-generated from System.CommandLine via Tools/DocGenerator ✅ Designed FR-006 (Version switching) JavaScript switcher + version-manifest.json ✅ Designed SC-003 (10 min publish) Estimated 5-8 min workflow duration ✅ Designed SC-007 (2 sec load time) Static HTML, no backend, CDN via GitHub Pages ✅ Designed Ready for Phase 2 All Phase 1 deliverables complete. Proceeding to Phase 2 (Task Generation) is approved. Branch: 001-github-pages-docs Next Command: /speckit.tasks to generate implementation tasks from this plan Plan Status: ✅ Complete Last Updated: 2026-01-16 Reviewed By: AI Planning Agent Approval: Ready for implementation"
  },
  "specs/001-github-pages-docs/quickstart.html": {
    "href": "specs/001-github-pages-docs/quickstart.html",
    "title": "Quick Start: GitHub Pages Documentation Publishing | wt",
    "summary": "Quick Start: GitHub Pages Documentation Publishing Feature: 001-github-pages-docs Audience: Developers implementing this feature Est. Time: 4-6 hours for initial setup This guide provides step-by-step instructions to implement automated documentation publishing to GitHub Pages. Prerequisites Repository with .NET 10.0 project (wt.cli) GitHub repository with Actions enabled Existing docfx.json configuration Git branching strategy established Implementation Phases Phase 1: Enable XML Documentation (15 minutes) Step 1.1: Update .csproj Edit wt.cli/wt.cli.csproj: <PropertyGroup> <!-- Existing properties --> <TargetFramework>net10.0</TargetFramework> <!-- Add XML documentation generation --> <GenerateDocumentationFile>true</GenerateDocumentationFile> <DocumentationFile>bin\\$(Configuration)\\$(TargetFramework)\\wt.xml</DocumentationFile> <!-- Optional: Suppress missing XML comment warnings during development --> <NoWarn>$(NoWarn);1591</NoWarn> </PropertyGroup> Step 1.2: Add XML Documentation Comments Add XML comments to public APIs: /// <summary> /// Creates a new Git worktree for the specified branch. /// </summary> /// <param name=\"branchName\">Name of the branch to create worktree for.</param> /// <param name=\"path\">Optional custom path for the worktree directory.</param> /// <returns>Exit code: 0 for success, 1 for failure.</returns> public static int CreateWorktree(string branchName, string? path = null) { // Implementation } Step 1.3: Verify Build cd wt.cli dotnet build --configuration Release # Verify wt.xml is generated in bin/Release/net10.0/ ls bin/Release/net10.0/wt.xml Expected Output: XML file with API documentation exists. Phase 2: Create Command Documentation Generator (1-2 hours) Step 2.1: Create Project Structure mkdir -p Tools/DocGenerator cd Tools/DocGenerator dotnet new console dotnet add package System.CommandLine --version 2.0.2 Step 2.2: Implement Generator Create Tools/DocGenerator/Program.cs: using System; using System.CommandLine; using System.CommandLine.Help; using System.CommandLine.IO; using System.IO; using System.Text; class MarkdownConsole : IConsole { private readonly StringWriter _out = new StringWriter(); public string GetOutput() => _out.ToString(); public IStandardStreamWriter Out => StandardStreamWriter.Create(_out); public bool IsOutputRedirected => false; public IStandardStreamWriter Error => Out; public bool IsErrorRedirected => false; public bool IsInputRedirected => false; } class Program { static int Main(string[] args) { if (args.Length == 0) { Console.WriteLine(\"Usage: DocGenerator <output-directory>\"); return 1; } var outputDir = args[0]; var commandsDir = Path.Combine(outputDir, \"commands\"); Directory.CreateDirectory(commandsDir); // Create RootCommand with same structure as wt.cli var rootCommand = BuildCliStructure(); // Generate documentation GenerateCommandDocs(rootCommand, outputDir); Console.WriteLine($\"✅ Generated documentation for {rootCommand.Subcommands.Count} commands\"); return 0; } static RootCommand BuildCliStructure() { // TODO: Import actual command structure from wt.cli // For now, create example structure var rootCommand = new RootCommand(\"Git worktree manager\"); var createCommand = new Command(\"create\", \"Create a new worktree\"); createCommand.AddOption(new Option<string>(\"--path\", \"Custom path for worktree\")); createCommand.AddOption(new Option<string>(\"--editor\", \"Editor to open\")); rootCommand.AddSubcommand(createCommand); var listCommand = new Command(\"list\", \"List all worktrees\"); listCommand.AddOption(new Option<bool>(\"--json\", \"Output in JSON format\")); rootCommand.AddSubcommand(listCommand); return rootCommand; } static void GenerateCommandDocs(RootCommand root, string outputDir) { var overview = new StringBuilder(); overview.AppendLine(\"# Command Reference\"); overview.AppendLine(); overview.AppendLine(\"Complete reference for all `wt` commands.\"); overview.AppendLine(); foreach (var command in root.Subcommands) { var markdown = ConvertToMarkdown(command); var fileName = $\"{command.Name}.md\"; File.WriteAllText(Path.Combine(outputDir, \"commands\", fileName), markdown); overview.AppendLine($\"- [`wt {command.Name}`](commands/{command.Name}.md) - {command.Description}\"); } File.WriteAllText(Path.Combine(outputDir, \"command-reference.md\"), overview.ToString()); } static string ConvertToMarkdown(Command command) { var md = new StringBuilder(); md.AppendLine($\"# wt {command.Name}\"); md.AppendLine(); md.AppendLine(command.Description); md.AppendLine(); md.AppendLine(\"## Usage\"); md.AppendLine(\"```bash\"); md.AppendLine($\"wt {command.Name} [options]\"); md.AppendLine(\"```\"); md.AppendLine(); if (command.Options.Any()) { md.AppendLine(\"## Options\"); md.AppendLine(); foreach (var option in command.Options) { md.AppendLine($\"### `{string.Join(\", \", option.Aliases)}`\"); md.AppendLine(); md.AppendLine(option.Description ?? \"\"); md.AppendLine(); } } return md.ToString(); } } Step 2.3: Test Locally cd Tools/DocGenerator dotnet run -- ../../docs # Verify generated files ls ../../docs/commands/ cat ../../docs/command-reference.md Expected Output: Markdown files created for each command. Phase 3: Create Version Manifest Script (30 minutes) Step 3.1: Create Python Script Create .github/scripts/update-version-manifest.py: #!/usr/bin/env python3 \"\"\"Update version manifest JSON file with new documentation version.\"\"\" import json import argparse import sys def update_manifest(input_file, output_file, new_version, release_date): \"\"\"Update manifest with new version, marking it as latest.\"\"\" try: with open(input_file, 'r') as f: manifest = json.load(f) except FileNotFoundError: manifest = {'versions': []} # Remove \"latest\" from all versions for v in manifest['versions']: v['isLatest'] = False v['label'] = v['label'].replace(' (latest)', '') # Check if version exists existing = next((v for v in manifest['versions'] if v['path'] == new_version), None) if existing: existing['released'] = release_date existing['isLatest'] = True existing['label'] = f\"{new_version} (latest)\" print(f\"✅ Updated existing version: {new_version}\") else: manifest['versions'].insert(0, { 'label': f\"{new_version} (latest)\", 'path': new_version, 'released': release_date, 'isLatest': True }) print(f\"✅ Added new version: {new_version}\") # Sort by date manifest['versions'].sort(key=lambda v: v['released'], reverse=True) # Write updated manifest with open(output_file, 'w') as f: json.dump(manifest, f, indent=2, ensure_ascii=False) print(f\" Total versions: {len(manifest['versions'])}\") return 0 if __name__ == '__main__': parser = argparse.ArgumentParser() parser.add_argument('--version', required=True) parser.add_argument('--date', required=True) parser.add_argument('--input', default='version-manifest.json') parser.add_argument('--output', default='version-manifest.json') args = parser.parse_args() sys.exit(update_manifest(args.input, args.output, args.version, args.date)) Step 3.2: Make Executable chmod +x .github/scripts/update-version-manifest.py Step 3.3: Test Locally python3 .github/scripts/update-version-manifest.py \\ --version \"v0.1\" \\ --date \"2026-01-15T10:00:00Z\" cat version-manifest.json Expected Output: Valid JSON with version entry. Phase 4: Create GitHub Actions Workflow (1 hour) Step 4.1: Create Workflow File Create .github/workflows/docs.yml: name: Deploy Documentation on: release: types: [published] workflow_dispatch: inputs: version: description: 'Manual version override (e.g., v0.1)' required: false type: string permissions: contents: write pages: write id-token: write concurrency: group: pages cancel-in-progress: false jobs: build-and-deploy: name: Build and Deploy Documentation runs-on: ubuntu-latest environment: name: github-pages url: ${{ steps.deployment.outputs.page_url }} steps: - name: Checkout repository uses: actions/checkout@v4 - name: Setup .NET uses: actions/setup-dotnet@v5 with: dotnet-version: '10.0.x' - name: Install DocFX run: dotnet tool install --global docfx --version 2.78.4 - name: Generate command documentation run: | cd Tools/DocGenerator dotnet run -- ../../docs - name: Build API documentation run: | cd wt.cli dotnet build --configuration Release - name: Extract version id: version run: | if [ -n \"${{ github.event.inputs.version }}\" ]; then VERSION=\"${{ github.event.inputs.version }}\" else TAG=\"${{ github.event.release.tag_name }}\" VERSION=$(echo $TAG | sed -E 's/^v([0-9]+)\\.([0-9]+)\\.[0-9]+$/v\\1.\\2/') fi echo \"minor=$VERSION\" >> $GITHUB_OUTPUT echo \"Building documentation for version: $VERSION\" - name: Build versioned documentation run: | mkdir -p _output/${{ steps.version.outputs.minor }} docfx build docfx.json --warningsAsErrors -o _output/${{ steps.version.outputs.minor }} - name: Fetch existing version manifest run: | git fetch origin gh-pages:gh-pages 2>/dev/null || true if git show gh-pages:version-manifest.json > version-manifest.json 2>/dev/null; then echo \"✅ Existing manifest found\" else echo '{\"versions\":[]}' > version-manifest.json echo \"✅ Created new manifest\" fi - name: Update version manifest run: | RELEASE_DATE=\"${{ github.event.release.published_at || github.event.head_commit.timestamp }}\" python3 .github/scripts/update-version-manifest.py \\ --version \"${{ steps.version.outputs.minor }}\" \\ --date \"$RELEASE_DATE\" cp version-manifest.json _output/ cp version-manifest.json _output/${{ steps.version.outputs.minor }}/ - name: Validate documentation links run: | pip install linkchecker linkchecker --check-extern --ignore-url=\"localhost\" --no-warnings \\ _output/${{ steps.version.outputs.minor }}/ - name: Setup GitHub Pages uses: actions/configure-pages@v4 - name: Upload artifact uses: actions/upload-pages-artifact@v3 with: path: '_output' - name: Deploy to GitHub Pages id: deployment uses: actions/deploy-pages@v4 Step 4.2: Configure GitHub Pages Go to repository Settings → Pages Source: Select \"GitHub Actions\" Save Step 4.3: Create Environment Go to Settings → Environments Click \"New environment\" Name: github-pages Click \"Configure environment\" (Optional) Add protection rules Phase 5: Create Version Switcher UI (30-45 minutes) Step 5.1: Create Custom Template Directory mkdir -p templates/partials Step 5.2: Create Navbar Override Create templates/partials/navbar.tmpl.partial: <!-- Existing navbar content --> <nav class=\"navbar navbar-inverse navbar-fixed-top\" id=\"navbar\"> <div class=\"container\"> <!-- Brand and toggle --> <div class=\"navbar-header\"> <button type=\"button\" class=\"navbar-toggle collapsed\" data-toggle=\"collapse\" data-target=\"#navbar-collapse\"> <span class=\"sr-only\">Toggle navigation</span> <span class=\"icon-bar\"></span> <span class=\"icon-bar\"></span> <span class=\"icon-bar\"></span> </button> <a class=\"navbar-brand\" href=\"{{_rel}}index.html\"> <img id=\"logo\" class=\"svg\" src=\"{{_rel}}logo.svg\" alt=\"{{_appName}}\"> </a> </div> <!-- Navbar collapse --> <div class=\"collapse navbar-collapse\" id=\"navbar-collapse\"> <form class=\"navbar-form navbar-right\" role=\"search\" id=\"search\"> <div class=\"form-group\"> <input type=\"text\" class=\"form-control\" id=\"search-query\" placeholder=\"Search\" autocomplete=\"off\"> </div> </form> <!-- Add version switcher --> <div class=\"navbar-form navbar-right\"> <div class=\"form-group\"> <label for=\"version-switcher\" style=\"color: #fff; margin-right: 5px;\">Version:</label> <select id=\"version-switcher\" class=\"form-control\" style=\"display: inline-block; width: auto;\"> <option>Loading...</option> </select> </div> </div> </div> </div> </nav> <script> (function() { function switchVersion(targetVersion) { const currentPath = window.location.pathname; const pathWithoutVersion = currentPath.replace(/\\/v\\d+\\.\\d+\\//, '/'); window.location.href = `/${targetVersion}${pathWithoutVersion}`; } fetch('/version-manifest.json') .then(res => res.json()) .then(data => { const selector = document.getElementById('version-switcher'); selector.innerHTML = ''; selector.onchange = function() { switchVersion(this.value); }; data.versions.forEach(v => { const option = document.createElement('option'); option.value = v.path; option.textContent = v.label; if (window.location.pathname.includes(`/${v.path}/`)) { option.selected = true; } selector.appendChild(option); }); }) .catch(err => { console.error('Failed to load versions:', err); document.getElementById('version-switcher').parentElement.parentElement.style.display = 'none'; }); })(); </script> Step 5.3: Update docfx.json Template Configuration Edit docfx.json: { \"build\": { \"template\": [\"default\", \"modern\", \"templates\"] } } Phase 6: Update Documentation Content (1-2 hours) Step 6.1: Create Installation Guide Create docs/installation.md: # Installation ## System Requirements - **Windows**: Windows 10 or later (x64) - **macOS**: macOS 11 or later (ARM64/Apple Silicon) - **Linux**: x64 or ARM architecture **Note**: No .NET SDK or Git installation required for the `wt` tool itself. ## Download Download from [latest release](https://github.com/kuju63/wt/releases/latest): - **Windows**: `wt-win-x64.zip` - **macOS**: `wt-osx-arm64.tar.gz` - **Linux (x64)**: `wt-linux-x64.tar.gz` ## Windows Installation 1. Download `wt-win-x64.zip` 2. Extract to `C:\\Program Files\\wt\\` 3. Add to PATH: ```powershell setx PATH \"%PATH%;C:\\Program Files\\wt\" Verify: wt --version macOS Installation Download wt-osx-arm64.tar.gz Extract and install: tar -xzf wt-osx-arm64.tar.gz sudo mv wt /usr/local/bin/ sudo chmod +x /usr/local/bin/wt Verify: wt --version Linux Installation Download appropriate archive Extract and install: tar -xzf wt-linux-x64.tar.gz sudo mv wt /usr/local/bin/ sudo chmod +x /usr/local/bin/wt Verify: wt --version #### Step 6.2: Create Contribution Guide Create `docs/contributing.md`: ```markdown # Contributing to wt ## Development Environment Setup **Prerequisites for Development**: - .NET 10.0 SDK or later - Git 2.5 or later ### Setup Steps 1. Clone: `git clone https://github.com/kuju63/wt.git` 2. Restore: `dotnet restore` 3. Build: `dotnet build` 4. Test: `dotnet test` ## Coding Standards See [Constitution](../.specify/memory/constitution.md): - TDD required - Minimal dependencies - Clean and secure code ## Pull Request Process 1. Create feature branch 2. Write tests first 3. Implement feature 4. Ensure tests pass 5. Submit PR Step 6.3: Update docs/toc.yml Edit docs/toc.yml: - name: Home href: index.md - name: Installation href: installation.md - name: Command Reference href: command-reference.md - name: API Reference href: ../api/ - name: Contributing href: contributing.md Phase 7: Testing and Verification (30-45 minutes) Step 7.1: Local Build Test # Generate command docs cd Tools/DocGenerator dotnet run -- ../../docs cd ../.. # Build API docs cd wt.cli dotnet build --configuration Release cd .. # Build DocFX docfx build docfx.json # Check output ls _site/ open _site/index.html # or xdg-open on Linux Step 7.2: Commit and Push git checkout -b 001-github-pages-docs git add . git commit -m \"feat: add GitHub Pages documentation publishing\" git push origin 001-github-pages-docs Step 7.3: Create PR and Merge Create pull request Review changes Merge to main Step 7.4: Create Release Go to Releases → Draft a new release Tag: v0.1.0 Title: v0.1.0 - Initial Release Publish release Watch Actions tab for workflow execution Step 7.5: Verify Deployment After workflow completes: Visit https://{username}.github.io/wt/v0.1/ Check version switcher loads Test navigation between pages Verify API reference exists Test search functionality Troubleshooting Issue: XML Documentation Not Generated Solution: Verify <GenerateDocumentationFile>true</GenerateDocumentationFile> in .csproj Issue: DocFX Build Fails with \"File not found\" Solution: Check paths in docfx.json are relative to the config file location Issue: Version Switcher Not Showing Solution: Check browser console for errors, verify /version-manifest.json is accessible Issue: Link Validation Fails Solution: Fix broken links in markdown files, ensure all referenced files exist Issue: GitHub Pages Deployment Permission Denied Solution: Verify github-pages environment exists and has correct permissions Success Checklist ✅ XML documentation enabled and building ✅ Command documentation generator working ✅ Version manifest script tested ✅ GitHub Actions workflow created ✅ Version switcher UI implemented ✅ Installation guide written ✅ Contribution guide written ✅ Local DocFX build succeeds ✅ First release published ✅ Documentation deployed to GitHub Pages ✅ Version switcher functional ✅ All links working ✅ Search functional Next Steps After successful first release: Monitor Analytics: Track documentation usage Gather Feedback: From users on documentation clarity Iterate: Improve based on feedback Document Process: Update this quickstart based on experience Estimated Total Time: 4-6 hours for full implementation"
  },
  "specs/001-github-pages-docs/research.html": {
    "href": "specs/001-github-pages-docs/research.html",
    "title": "Research: GitHub Pages Documentation Publishing | wt",
    "summary": "Research: GitHub Pages Documentation Publishing Feature: 001-github-pages-docs Date: 2026-01-15 Status: Complete This document consolidates research findings to resolve all \"NEEDS CLARIFICATION\" items from the Technical Context and Constitution Check sections of the implementation plan. Research Areas 1. DocFX Version and Installation Decision: Use DocFX v2.78.4 (latest stable) as .NET global tool Rationale: DocFX 2.78.4 is the current production release maintained by Microsoft/.NET Foundation Includes native support for .NET 10 (via Roslyn 4.13.0 update) Global tool installation integrates seamlessly with .NET 10.0 SDK already in use Supports modern template system with \"default\" and \"modern\" themes Native support for C# XML documentation extraction Performance improvements: cached MarkdownPipeline, reused YamlDeserializer instances Installation Method: dotnet tool install --global docfx --version 2.78.4 Alternatives Considered: Container-based (Docker): More complex CI/CD setup, unnecessary overhead for simple documentation build npm-based tools (MkDocs, Docusaurus): Cannot generate .NET API documentation from XML comments Sphinx: Python-focused, poor .NET integration, requires additional plugins Implementation Requirements: Add <GenerateDocumentationFile>true</GenerateDocumentationFile> to wt.cli.csproj Pin DocFX version 2.78.4 in GitHub Actions workflow to prevent unexpected breaking changes Configure docfx.json to output XML documentation from wt.cli project 2. Automatic Command List Generation Decision: Programmatic export of System.CommandLine help text using HelpBuilder and custom IConsole Rationale: System.CommandLine (already used in wt.cli) provides rich command metadata Automatic generation ensures documentation stays synchronized with actual CLI implementation Prevents manual maintenance burden and documentation drift Supports requirement FR-012 (Command Reference as man page equivalent) Implementation Architecture: Step 1: Create Documentation Generator Tool // Tools/DocGenerator/Program.cs using System.CommandLine; using System.CommandLine.Help; using System.CommandLine.IO; using System.Text; class MarkdownConsole : IConsole { private readonly StringWriter _out = new StringWriter(); public string GetOutput() => _out.ToString(); public IStandardStreamWriter Out => StandardStreamWriter.Create(_out); public bool IsOutputRedirected => false; public IStandardStreamWriter Error => Out; public bool IsErrorRedirected => false; public bool IsInputRedirected => false; } class CommandDocGenerator { public static void GenerateCommandDocs(RootCommand rootCommand, string outputDir) { // Ensure commands directory exists var commandsDir = Path.Combine(outputDir, \"commands\"); Directory.CreateDirectory(commandsDir); // Generate overview page var overview = new StringBuilder(); overview.AppendLine(\"# Command Reference\"); overview.AppendLine(); overview.AppendLine(\"Complete reference for all `wt` commands.\"); overview.AppendLine(); // Generate individual command pages foreach (var command in rootCommand.Subcommands) { var markdown = ConvertCommandToMarkdown(command); var fileName = $\"{command.Name}.md\"; File.WriteAllText(Path.Combine(commandsDir, fileName), markdown); overview.AppendLine($\"- [`wt {command.Name}`](commands/{command.Name}.md) - {command.Description}\"); } File.WriteAllText(Path.Combine(outputDir, \"command-reference.md\"), overview.ToString()); Console.WriteLine($\"✅ Generated documentation for {rootCommand.Subcommands.Count} commands\"); } private static string ConvertCommandToMarkdown(Command command) { var md = new StringBuilder(); // Title and description md.AppendLine($\"# wt {command.Name}\"); md.AppendLine(); md.AppendLine(command.Description); md.AppendLine(); // Usage section md.AppendLine(\"## Usage\"); md.AppendLine(); md.AppendLine(\"```bash\"); md.AppendLine($\"wt {command.Name} [options]\"); md.AppendLine(\"```\"); md.AppendLine(); // Options section if (command.Options.Any()) { md.AppendLine(\"## Options\"); md.AppendLine(); foreach (var option in command.Options) { md.AppendLine($\"### `{string.Join(\", \", option.Aliases)}`\"); md.AppendLine(); md.AppendLine(option.Description); md.AppendLine(); if (option.ArgumentHelpName != null) { md.AppendLine($\"**Type:** `{option.ArgumentHelpName}`\"); md.AppendLine(); } if (option.IsRequired) { md.AppendLine(\"**Required:** Yes\"); md.AppendLine(); } } } // Examples section md.AppendLine(\"## Examples\"); md.AppendLine(); AddExamplesForCommand(md, command.Name); return md.ToString(); } private static void AddExamplesForCommand(StringBuilder md, string commandName) { // Define examples per command var examples = commandName switch { \"create\" => new[] { (\"Create worktree with default path\", \"wt create feature-login\"), (\"Create with custom path\", \"wt create feature-login --path /tmp/wt-login\"), (\"Create and open in VS Code\", \"wt create feature-login --editor vscode\") }, \"list\" => new[] { (\"List all worktrees\", \"wt list\"), (\"List in JSON format\", \"wt list --json\") }, _ => Array.Empty<(string, string)>() }; foreach (var (description, command) in examples) { md.AppendLine($\"### {description}\"); md.AppendLine(); md.AppendLine(\"```bash\"); md.AppendLine(command); md.AppendLine(\"```\"); md.AppendLine(); } } } // Entry point class Program { static void Main(string[] args) { if (args.Length == 0) { Console.WriteLine(\"Usage: DocGenerator <output-directory>\"); return; } var outputDir = args[0]; // Import CLI command structure (same as main application) var rootCommand = new RootCommand(\"Git worktree manager\"); // ... add all subcommands exactly as defined in wt.cli ... CommandDocGenerator.GenerateCommandDocs(rootCommand, outputDir); } } Step 2: Integrate into Build Pipeline # .github/workflows/docs.yml - name: Generate command documentation run: | cd Tools/DocGenerator dotnet run -- ../../docs - name: Build DocFX documentation run: docfx build docfx.json Benefits: ✅ Zero manual maintenance: CLI changes automatically reflected in docs ✅ Consistency guaranteed: Documentation matches implementation ✅ Type safety: Compilation errors prevent doc/code mismatch ✅ Rich metadata: Full access to System.CommandLine attributes Alternatives Considered: Manual markdown files: High maintenance, prone to drift Scraping --help output: Loses structured metadata Third-party tools: No existing System.CommandLine integration 3. Documentation Testing Strategy Decision: Two-layer testing approach with build-time and link validation Rationale: Catches documentation errors early in deployment pipeline No additional test project complexity required Focuses on critical failure modes (broken links, build errors) Testing Layers: Layer 1: Build-Time Validation Tool: DocFX's built-in --warningsAsErrors flag Validates: Markdown syntax errors YAML structure issues Internal file reference failures Missing cross-references Execution: During DocFX build step in deployment workflow Implementation: docfx build docfx.json --warningsAsErrors Failure Examples: Invalid markdown syntax → Build fails Broken internal links (e.g., [text](missing-file.md)) → Build fails YAML TOC errors → Build fails Missing API XML documentation → Warning promoted to error Layer 2: Link Validation Tool: LinkChecker (Python-based) Validates: All internal links between pages Links to API reference pages External links (optional - can filter noisy domains) Image resources Execution: After successful DocFX build, before deployment Implementation: - name: Validate documentation links run: | pip install linkchecker linkchecker \\ --check-extern \\ --ignore-url=\"localhost\" \\ --no-warnings \\ _output/${{ steps.version.outputs.minor }}/ Failure Examples: Broken link to command page → Validation fails Missing image file → Validation fails Dead external link → Validation fails (configurable) Benefits: ✅ Fast feedback: Errors caught in deployment pipeline ✅ No code changes: No need to modify test project ✅ Comprehensive: Covers critical documentation quality issues ✅ Simple: Two tools, clear responsibilities Alternatives Considered: Manual testing: Does not scale, violates Constitution VI xUnit content tests: Adds unnecessary complexity for static content Full E2E browser testing: Overkill for static documentation Third-party SaaS: External dependency, security concerns 4. Version Switcher Implementation Decision: Custom JavaScript version switcher with separate build outputs per minor version Rationale: DocFX does not provide native version switching Separate builds ensure complete isolation between versions JavaScript provides seamless UX without server-side logic Matches requirements FR-006 (switch between versions) and FR-014 (minor version level) Architecture: GitHub Pages Structure: https://username.github.io/wt/ ├── index.html # Redirect to latest version ├── v1.0/ # Complete site for v1.0.x │ ├── index.html │ ├── installation.html │ ├── commands/ │ ├── api/ │ └── ... ├── v1.1/ # Complete site for v1.1.x │ └── ... └── version-manifest.json # Auto-generated list of all versions Implementation Components: 1. Version Switcher UI (Custom DocFX Template) Modify DocFX template to inject version selector in navigation bar: <!-- templates/partials/navbar.tmpl.partial --> <nav class=\"navbar\"> <!-- Existing navbar content --> <div class=\"version-selector\"> <label for=\"version-switcher\">Version:</label> <select id=\"version-switcher\" onchange=\"switchVersion(this.value)\"> <option>Loading...</option> </select> </div> </nav> <script> function switchVersion(targetVersion) { // Extract current path without version prefix const currentPath = window.location.pathname; const pathWithoutVersion = currentPath.replace(/\\/v\\d+\\.\\d+\\//, '/'); // Navigate to same page in selected version window.location.href = `/${targetVersion}${pathWithoutVersion}`; } // Load available versions from manifest fetch('/version-manifest.json') .then(res => res.json()) .then(data => { const selector = document.getElementById('version-switcher'); selector.innerHTML = ''; // Clear loading text data.versions.forEach(v => { const option = document.createElement('option'); option.value = v.path; option.textContent = v.label; // Pre-select current version based on URL if (window.location.pathname.includes(`/${v.path}/`)) { option.selected = true; } selector.appendChild(option); }); }) .catch(err => { console.error('Failed to load versions:', err); document.querySelector('.version-selector').style.display = 'none'; }); </script> 2. Version Manifest Format { \"versions\": [ { \"label\": \"v1.1 (latest)\", \"path\": \"v1.1\", \"released\": \"2026-01-15\", \"isLatest\": true }, { \"label\": \"v1.0\", \"path\": \"v1.0\", \"released\": \"2026-01-01\", \"isLatest\": false } ] } Edge Case Handling: Non-existent page in version: 404 page shows link to that version's homepage JavaScript disabled: Users can manually edit URL (version visible in path) Bookmark stability: URLs never change (meets SC-006: 2+ years stability) SEO optimization: Each version independently crawlable; <link rel=\"canonical\"> points to latest First-time visitors: Auto-redirect from root to latest version Alternatives Considered: Single site with conditional content: Complex, risk of version bleed, poor SEO Git branches per version: Manual backporting required, consistency issues Third-party hosting (ReadTheDocs): External dependency, migration effort, less control 5. Version Manifest Automation Decision: Automatic generation/update on every GitHub release Rationale: Fully automated - no manual JSON editing required Idempotent - safe to re-run for same version Persisted in gh-pages branch, versioned history Synchronizes with binary releases (requirement FR-001) Automation Workflow: Step 1: Fetch Existing Manifest - name: Fetch existing version manifest run: | # Attempt to fetch gh-pages branch (may not exist on first release) git fetch origin gh-pages:gh-pages 2>/dev/null || true # Extract existing manifest or create empty structure if git show gh-pages:version-manifest.json > version-manifest.json 2>/dev/null; then echo \"✅ Found existing manifest with $(jq '.versions | length' version-manifest.json) versions\" else echo '{\"versions\":[]}' > version-manifest.json echo \"✅ Created new manifest (first release)\" fi Step 2: Update Manifest with New Version - name: Update version manifest run: | VERSION=\"${{ steps.version.outputs.minor }}\" # e.g., v1.2 RELEASE_DATE=\"${{ github.event.release.published_at }}\" python3 .github/scripts/update-version-manifest.py \\ --version \"$VERSION\" \\ --date \"$RELEASE_DATE\" \\ --input version-manifest.json \\ --output version-manifest.json Step 3: Include in Deployment - name: Copy manifest to deployment output run: | # Root-level manifest (accessed by all versions) cp version-manifest.json _output/version-manifest.json # Version-specific copy (redundancy/fallback) cp version-manifest.json _output/${{ steps.version.outputs.minor }}/version-manifest.json Python Script (.github/scripts/update-version-manifest.py): #!/usr/bin/env python3 \"\"\" Update version manifest JSON file with new documentation version. Automatically marks new version as \"latest\" and updates labels. \"\"\" import json import argparse import sys def update_manifest(input_file, output_file, new_version, release_date): \"\"\"Update manifest with new version, marking it as latest.\"\"\" # Read existing manifest try: with open(input_file, 'r') as f: manifest = json.load(f) except FileNotFoundError: manifest = {'versions': []} # Remove \"latest\" designation from all existing versions for v in manifest['versions']: v['isLatest'] = False v['label'] = v['label'].replace(' (latest)', '') # Check if this version already exists (re-release scenario) existing = next((v for v in manifest['versions'] if v['path'] == new_version), None) if existing: # Update existing version existing['released'] = release_date existing['isLatest'] = True existing['label'] = f\"{new_version} (latest)\" print(f\"✅ Updated existing version: {new_version}\") else: # Add new version at the beginning of the list manifest['versions'].insert(0, { 'label': f\"{new_version} (latest)\", 'path': new_version, 'released': release_date, 'isLatest': True }) print(f\"✅ Added new version: {new_version}\") # Sort versions by release date (newest first) manifest['versions'].sort(key=lambda v: v['released'], reverse=True) # Write updated manifest with open(output_file, 'w') as f: json.dump(manifest, f, indent=2, ensure_ascii=False) print(f\" Total versions in manifest: {len(manifest['versions'])}\") return 0 if __name__ == '__main__': parser = argparse.ArgumentParser(description='Update version manifest') parser.add_argument('--version', required=True, help='Version to add (e.g., v1.2)') parser.add_argument('--date', required=True, help='Release date (ISO 8601 format)') parser.add_argument('--input', default='version-manifest.json', help='Input manifest file') parser.add_argument('--output', default='version-manifest.json', help='Output manifest file') args = parser.parse_args() sys.exit(update_manifest(args.input, args.output, args.version, args.date)) Behavior: First release: Creates new manifest with single version Subsequent releases: Adds new version, marks as latest Re-release: Updates existing version's date Idempotent: Running twice produces same result Benefits: ✅ Zero manual intervention required ✅ Automatic on every GitHub release ✅ Idempotent and safe to re-run ✅ Versioned history in gh-pages branch ✅ Simple Python script (no external dependencies) Result After Deployment: https://username.github.io/wt/ ├── version-manifest.json ← Updated with new version ├── v1.0/ │ ├── (documentation...) │ └── version-manifest.json ← Same content (for redundancy) └── v1.1/ ├── (documentation...) └── version-manifest.json ← Same content 6. GitHub Pages Deployment Pattern Decision: GitHub Actions with actions/deploy-pages@v4 Complete Deployment Workflow: name: Deploy Documentation on: release: types: [published] workflow_dispatch: inputs: version: description: 'Manual version override (e.g., v1.2)' required: false permissions: contents: write pages: write id-token: write concurrency: group: pages cancel-in-progress: false jobs: build-and-deploy: name: Build and Deploy Documentation runs-on: ubuntu-latest environment: name: github-pages url: ${{ steps.deployment.outputs.page_url }} steps: - name: Checkout repository uses: actions/checkout@v4 - name: Setup .NET uses: actions/setup-dotnet@v5 with: dotnet-version: '10.0.x' - name: Install DocFX run: dotnet tool install --global docfx --version 2.78.4 - name: Generate command documentation run: | cd Tools/DocGenerator dotnet run -- ../../docs cd ../.. - name: Build API documentation run: | cd wt.cli dotnet build --configuration Release cd .. - name: Extract version id: version run: | if [ -n \"${{ github.event.inputs.version }}\" ]; then VERSION=\"${{ github.event.inputs.version }}\" else TAG=\"${{ github.event.release.tag_name }}\" VERSION=$(echo $TAG | sed -E 's/v([0-9]+\\.[0-9]+).*/v\\1/') fi echo \"minor=$VERSION\" >> $GITHUB_OUTPUT echo \"Building documentation for version: $VERSION\" - name: Build versioned documentation run: | mkdir -p _output/${{ steps.version.outputs.minor }} docfx build docfx.json --warningsAsErrors -o _output/${{ steps.version.outputs.minor }} - name: Fetch existing version manifest run: | git fetch origin gh-pages:gh-pages 2>/dev/null || true if git show gh-pages:version-manifest.json > version-manifest.json 2>/dev/null; then echo \"✅ Existing manifest found\" else echo '{\"versions\":[]}' > version-manifest.json echo \"✅ Created new manifest\" fi - name: Update version manifest run: | RELEASE_DATE=\"${{ github.event.release.published_at || github.event.head_commit.timestamp }}\" python3 .github/scripts/update-version-manifest.py \\ --version \"${{ steps.version.outputs.minor }}\" \\ --date \"$RELEASE_DATE\" cp version-manifest.json _output/ cp version-manifest.json _output/${{ steps.version.outputs.minor }}/ - name: Validate documentation links run: | pip install linkchecker linkchecker --check-extern --ignore-url=\"localhost\" --no-warnings \\ _output/${{ steps.version.outputs.minor }}/ - name: Setup GitHub Pages uses: actions/configure-pages@v4 - name: Upload artifact uses: actions/upload-pages-artifact@v3 with: path: '_output' - name: Deploy to GitHub Pages id: deployment uses: actions/deploy-pages@v4 Key Features: ✅ Automatic trigger: Runs on every GitHub release publication (FR-001) ✅ Command generation: Automatically generates command documentation ✅ Version extraction: Extracts minor version from git tag (v1.2.3 → v1.2) ✅ Build validation: Treats warnings as errors (quality gate) ✅ Link validation: Checks all internal/external links ✅ Manifest update: Automatically updates version manifest ✅ OIDC authentication: No long-lived PAT tokens required ✅ Concurrent-safe: Prevents deployment race conditions Configuration Requirements: Enable GitHub Pages: Repository Settings → Pages → Source: \"GitHub Actions\" Create environment: Add \"github-pages\" environment in repository settings Add script: Create .github/scripts/update-version-manifest.py (from section 5) Create tool: Implement Tools/DocGenerator/ (from section 2) Performance: Estimated build time: 5-8 minutes Meets SC-003: Documentation published within 10 minutes of release Alternatives Considered: Manual deployment: No automation, violates FR-001 Third-party hosting (Netlify, Vercel): External dependency, cost Azure Static Web Apps: Requires Azure account, overkill for docs gh-pages branch push: More complex, no built-in OIDC, manual artifact management 7. DocFX Configuration Best Practices Enhanced docfx.json: { \"$schema\": \"https://raw.githubusercontent.com/dotnet/docfx/main/schemas/docfx.schema.json\", \"metadata\": [ { \"src\": [ { \"src\": \"./wt.cli\", \"files\": [\"**/*.csproj\"] } ], \"output\": \"api\", \"shouldSkipMarkdeep\": false, \"properties\": { \"TargetFramework\": \"net10.0\" } } ], \"build\": { \"content\": [ { \"files\": [\"**/*.{md,yml}\"], \"exclude\": [ \"_site/**\", \"obj/**\", \"bin/**\", \"specs/**\", \".specify/**\", \"Tools/**\", \"coverage/**\" ] } ], \"resource\": [ { \"files\": [\"images/**\", \"assets/**\", \"*.png\", \"*.jpg\"] } ], \"output\": \"_site\", \"template\": [\"default\", \"modern\"], \"globalMetadata\": { \"_appName\": \"wt\", \"_appTitle\": \"wt - Git Worktree Manager\", \"_appFooter\": \"Copyright © 2026 Kuju63. Licensed under MIT.\", \"_enableSearch\": true, \"_enableNewTab\": true, \"_gitHub\": { \"repo\": \"kuju63/wt\", \"branch\": \"main\" }, \"_gitContribute\": { \"repo\": \"kuju63/wt\", \"branch\": \"main\", \"path\": \"docs\" } }, \"sitemap\": { \"baseUrl\": \"https://kuju63.github.io/wt/\", \"priority\": 1.0, \"changefreq\": \"weekly\" }, \"xref\": [ \"https://learn.microsoft.com/en-us/dotnet/api\" ] } } Key Configuration Elements: xref: Cross-references to .NET framework documentation (System.CommandLine types link to Microsoft docs) sitemap: SEO optimization for search engine indexing _gitContribute: Enables \"Edit this page\" links for community contributions excludes: Prevents build errors from non-documentation directories template: Uses both \"default\" and \"modern\" for best compatibility and aesthetics Summary of Resolved Clarifications Original Question Resolution DocFX version? v2.78.4 (latest stable), installed as .NET global tool Command list automation? System.CommandLine HelpBuilder + custom IConsole, auto-generated markdown Version manifest automation? Python script in GitHub Actions, updated per release automatically Documentation testing? Two-layer: DocFX build validation + LinkChecker Version switcher? Custom JavaScript with version-manifest.json, separate builds per version Deployment pattern? GitHub Actions deploy-pages@v4, triggered on release publication Implementation Readiness All \"NEEDS CLARIFICATION\" items from plan.md have been resolved: ✅ DocFX version: v2.78.4 with .NET 10 support via Roslyn 4.13.0 ✅ Command automation: System.CommandLine programmatic export architecture defined ✅ Version manifest: Fully automated Python script, runs on every release ✅ Testing: Two-layer strategy (build validation + link checking) ✅ Version switcher: JavaScript + manifest.json with custom template override ✅ Deployment: Complete GitHub Actions workflow with validation gates New Components Required Tools/DocGenerator/ - .NET console app for command documentation generation .github/scripts/update-version-manifest.py - Python script for version manifest updates .github/workflows/docs.yml - Documentation deployment workflow templates/partials/navbar.tmpl.partial - Custom DocFX template for version switcher UI wt.cli/wt.cli.csproj - Add <GenerateDocumentationFile>true</GenerateDocumentationFile> Testing Strategy Summary Layer Tool What It Validates When It Runs Build Validation DocFX --warningsAsErrors Markdown syntax, YAML structure, internal refs During build step Link Validation LinkChecker Internal/external links, images After build, before deploy Intentionally excluded: Content completeness tests (xUnit) - not needed, adds unnecessary complexity Next Phase: Proceed to Phase 1 (Design & Contracts) to generate data-model.md, contracts/, and quickstart.md."
  },
  "specs/001-github-pages-docs/spec.html": {
    "href": "specs/001-github-pages-docs/spec.html",
    "title": "Feature Specification: GitHub Pages Documentation Publishing | wt",
    "summary": "Feature Specification: GitHub Pages Documentation Publishing Feature Branch: 001-github-pages-docs Created: 2026-01-15 Status: Draft Input: User description: \"バイナリのリリースと同時にドキュメントをGitHub Pagesに公開する。ドキュメントにはInstllation Guideやコマンドの一覧、Contribution方法などを用意する。また、今後のためにAPI一覧も用意する。ドキュメントはマイナーバージョンレベルで切り替えて表示することができるようにする必要がある。利用者が最初にアクセスするTopページであり、簡単にアプリをインストール、利用できるようにするためのガイドの役割となる。また、利用者がコマンドの詳細を知るためのmanページのような役割を持たせたい。\" User Scenarios & Testing (mandatory) User Story 1 - Quick Start Installation (Priority: P1) A new user visits the documentation site to install the tool and start using it immediately. They need clear, step-by-step installation instructions and basic usage examples to get started within minutes. Why this priority: This is the primary entry point for all users. Without clear installation guidance, users cannot adopt the tool, making this the highest-value feature. Independent Test: Can be fully tested by a new user following the installation guide from start to finish and successfully executing their first command. Delivers immediate value by enabling tool adoption. Acceptance Scenarios: Given a user visits the documentation homepage, When they navigate to the Installation Guide, Then they see platform-specific installation instructions (Windows, macOS, Linux) Given a user completes the installation steps, When they run the verification command shown in the guide, Then they confirm the tool is properly installed Given a user has installed the tool, When they follow the \"First Steps\" section, Then they successfully execute their first basic command User Story 2 - Command Reference Lookup (Priority: P1) An existing user needs to find detailed information about a specific command, including its parameters, options, and usage examples. They want to quickly search or browse command documentation like a man page. Why this priority: This is the core reference functionality that users will access repeatedly. Without comprehensive command documentation, users cannot effectively use the tool beyond basic operations. Independent Test: Can be fully tested by a user searching for any command and finding complete documentation with examples. Delivers continuous value for all user skill levels. Acceptance Scenarios: Given a user is on the documentation site, When they navigate to the Command Reference section, Then they see a complete list of available commands organized by category Given a user selects a specific command, When they view its documentation page, Then they see command syntax, parameter descriptions, options, and practical examples Given a user wants to find a command quickly, When they use the search functionality, Then they get relevant command documentation results User Story 3 - Version-Specific Documentation Access (Priority: P2) A user working with a specific version of the tool needs to view documentation that matches their installed version. They need to switch between different minor versions to see relevant features and commands. Why this priority: This ensures users see accurate documentation for their version, preventing confusion from features that don't exist in their installation. Critical for maintaining user trust but secondary to having basic documentation available. Independent Test: Can be fully tested by a user selecting different version numbers from a version switcher and seeing the documentation update accordingly. Delivers value for users on different version tracks. Acceptance Scenarios: Given a user is viewing documentation, When they access the version selector, Then they see a list of available minor versions (e.g., v1.0, v1.1, v2.0) Given a user selects a different minor version, When the page reloads, Then they see documentation specific to that version with URL reflecting the version number Given a user visits the documentation without specifying a version, When they land on the homepage, Then they automatically see the latest stable version with an indicator showing which version they're viewing User Story 4 - API Reference for Developers (Priority: P2) A developer integrating with or extending the tool needs to access comprehensive API documentation. They want to understand available interfaces, classes, methods, and integration patterns. Why this priority: Essential for developers building extensions or integrations, but represents a smaller subset of users compared to general tool users. Secondary to end-user documentation. Independent Test: Can be fully tested by a developer finding a specific API class or method and successfully integrating it into their code. Delivers value for the developer ecosystem. Acceptance Scenarios: Given a developer visits the documentation, When they navigate to the API Reference section, Then they see organized API documentation with namespaces, classes, and methods Given a developer is viewing an API class, When they read the documentation, Then they see method signatures, parameter types, return values, and usage examples Given a developer wants to understand integration patterns, When they view the API overview, Then they see common integration scenarios with code samples User Story 5 - Contributing to the Project (Priority: P3) A contributor wants to help improve the tool by submitting code, documentation, or bug reports. They need clear guidelines on development setup, coding standards, and the contribution process. Why this priority: Important for building a contributor community and long-term project health, but not essential for basic tool usage. Lower priority than user-facing documentation. Independent Test: Can be fully tested by a new contributor following the guide to set up their development environment and submit their first contribution. Delivers value for project sustainability. Acceptance Scenarios: Given a potential contributor visits the documentation, When they navigate to the Contribution Guide, Then they see instructions for development environment setup, coding standards, and pull request process Given a contributor follows the setup instructions, When they complete the steps, Then they have a working development environment and can run tests Given a contributor wants to report a bug, When they view the contribution guidelines, Then they see templates and instructions for submitting issues Edge Cases What happens when a user tries to access documentation for a version that doesn't exist (e.g., future version, typo)? How does the site handle users with JavaScript disabled when using version switcher? What happens when API documentation is not yet available for the latest version? How does the system handle documentation for pre-release or beta versions? What happens when a user bookmarks a version-specific page and that version is later deprecated? How does search handle queries across multiple versions of documentation? Requirements (mandatory) Functional Requirements FR-001: System MUST publish documentation to GitHub Pages automatically when a new binary release is created FR-002: Documentation MUST include an Installation Guide with platform-specific instructions (Windows, macOS, Linux) FR-003: Documentation MUST include a comprehensive Command Reference listing all available commands with syntax, parameters, and examples FR-004: Documentation MUST include a Contribution Guide with development setup instructions and contribution process FR-005: Documentation MUST include an API Reference section with comprehensive interface and class documentation FR-006: Users MUST be able to switch between different minor versions of documentation (e.g., v1.0, v1.1, v2.0) FR-007: Documentation MUST display the current version being viewed prominently on every page FR-008: Users MUST be able to search for commands and topics across the documentation FR-009: Documentation homepage MUST serve as the primary entry point with clear navigation to all major sections FR-010: Documentation MUST display the latest stable version by default when accessed without version specification FR-011: System MUST maintain documentation for each minor version independently (e.g., separate documentation sets for 1.0.x, 1.1.x, 2.0.x) FR-012: Command Reference MUST function as a man page equivalent with detailed parameter descriptions and usage examples FR-013: Documentation MUST be accessible from a dedicated GitHub Pages URL FR-014: System MUST handle documentation versioning at minor version level only (patch versions share documentation) FR-015: API Reference MUST be generated from source code documentation comments Key Entities Documentation Version: Represents a specific minor version of documentation (e.g., 1.0, 1.1), containing all pages and content for that version Installation Guide: Platform-specific installation instructions including prerequisites, installation steps, and verification procedures Command Reference: Comprehensive list of commands with detailed information including syntax, parameters, options, examples, and related commands API Documentation: Generated documentation for public interfaces, classes, methods, and properties with type information and usage examples Contribution Guide: Instructions for contributors including development environment setup, coding standards, testing requirements, and pull request process Success Criteria (mandatory) Measurable Outcomes SC-001: New users can complete installation and execute their first command within 5 minutes of visiting the documentation SC-002: 90% of users can find command documentation they need within 30 seconds using search or navigation SC-003: Documentation is automatically published within 10 minutes of a new binary release being created SC-004: Users viewing documentation for version X.Y see content that accurately reflects features available in that version SC-005: Contributors can set up a working development environment by following the Contribution Guide with 95% success rate SC-006: API Reference coverage includes 100% of public interfaces and classes SC-007: Documentation site loads and displays content within 2 seconds for users on standard broadband connections"
  },
  "specs/001-github-pages-docs/tasks.html": {
    "href": "specs/001-github-pages-docs/tasks.html",
    "title": "Tasks: GitHub Pages Documentation Publishing | wt",
    "summary": "Tasks: GitHub Pages Documentation Publishing Input: Design documents from /specs/001-github-pages-docs/ Prerequisites: plan.md, spec.md, research.md, data-model.md, contracts/, quickstart.md Tests: No xUnit tests required - documentation validated through build process (DocFX + LinkChecker) Organization: Tasks are grouped by user story to enable independent implementation and testing of each story. Format: [ID] [P?] [Story] Description [P]: Can run in parallel (different files, no dependencies) [Story]: Which user story this task belongs to (e.g., US1, US2, US3) Include exact file paths in descriptions Path Conventions Project follows single repository structure: Documentation source: docs/ CLI project: wt.cli/ Tools: Tools/DocGenerator/ GitHub Actions: .github/workflows/ Build output: _site/ (not committed) Phase 1: Setup (Shared Infrastructure) Purpose: Enable XML documentation and DocFX configuration [x] T001 Enable XML documentation generation in wt.cli/wt.cli.csproj (add GenerateDocumentationFile and DocumentationFile properties) [x] T002 [P] Verify docfx.json configuration exists and includes API metadata generation settings [x] T003 [P] Create Tools/DocGenerator/ directory and initialize console project with System.CommandLine package Checkpoint: XML docs enabled, DocFX configured, DocGenerator project initialized Phase 2: Foundational (Blocking Prerequisites) Purpose: Core documentation infrastructure that MUST be complete before ANY user story can be implemented ⚠️ CRITICAL: No user story work can begin until this phase is complete [x] T004 Implement command documentation generator in Tools/DocGenerator/Program.cs with MarkdownConsole and CommandDocGenerator classes [x] T005 Add ConvertCommandToMarkdown method to Tools/DocGenerator/Program.cs for System.CommandLine help text extraction [x] T006 [P] Integrate documentation build into .github/workflows/release.yml as build-and-deploy-docs job (runs after create-release job completes) [x] T007 [P] Add DocFX installation with caching to .github/workflows/release.yml (dotnet tool install docfx --version ${{ env.DOCFX_VERSION }} --global) [x] T008 Add version extraction logic to .github/workflows/release.yml (extract minor version from needs.calculate-version.outputs.version) [x] T009 Create .github/scripts/update-version-manifest.py with positional arguments <manifest_path> and automatic publishedDate generation [x] T010 [P] Configure GitHub Pages deployment in .github/workflows/release.yml using peaceiris/actions-gh-pages@v4 with keep_files: true [x] T011 Add XML documentation comments to all public classes, methods, and properties in wt.cli/ (per FR-015 and SC-006) Implementation Note: Originally designed as separate .github/workflows/docs.yml triggered by release.published event, but consolidated into release.yml to avoid GitHub Actions limitation where GITHUB_TOKEN cannot trigger other workflows. This ensures documentation is automatically built and deployed as part of the release process. Checkpoint: Foundation ready - documentation can be generated and deployed automatically Phase 3: User Story 1 - Quick Start Installation (Priority: P1) \uD83C\uDFAF MVP Goal: New users can install the tool and start using it within 5 minutes (SC-001) Independent Test: A new user follows docs/installation.md from start to finish, installs the binary, and successfully runs wt --version Implementation for User Story 1 [x] T012 [US1] Create docs/installation.md with system requirements section (Windows 10+, macOS 11+, Linux x64/ARM) [x] T013 [US1] Add download section to docs/installation.md with links to release assets for all platforms (wt-win-x64.zip, wt-osx-arm64.tar.gz, wt-linux-x64.tar.gz, wt-linux-arm.tar.gz) [x] T014 [P] [US1] Add Windows installation instructions to docs/installation.md (extract, move to Program Files, add to PATH, verify) [x] T015 [P] [US1] Add macOS installation instructions to docs/installation.md (extract, move to /usr/local/bin, chmod +x, verify) [x] T016 [P] [US1] Add Linux installation instructions to docs/installation.md (extract, move to /usr/local/bin, chmod +x, verify) [x] T017 [US1] Add troubleshooting section to docs/installation.md (command not found, permission denied, Git not found) [x] T018 [US1] Create docs/guides/quickstart.md with first steps tutorial (create first worktree, basic commands) [x] T019 [US1] Update docs/index.md homepage with prominent Installation Guide link and Quick Start call-to-action [x] T020 [US1] Update docs/toc.yml to include installation and quickstart in navigation structure Checkpoint: Installation documentation complete - users can install and verify the tool independently Phase 4: User Story 2 - Command Reference Lookup (Priority: P1) Goal: Users can find detailed command documentation within 30 seconds (SC-002) Independent Test: A user navigates to Command Reference, searches for a command, and finds complete syntax, parameters, and examples Implementation for User Story 2 [x] T021 [US2] Run Tools/DocGenerator to generate command documentation markdown files in docs/commands/ directory (auto-generated from System.CommandLine definitions) [x] T022 [US2] Create docs/commands/index.md with command overview and category organization [x] T023 [P] [US2] Add command examples to docs/commands/create.md for 'create' command (default path, custom path, editor integration) [x] T024 [P] [US2] Add command examples to docs/commands/list.md for 'list' command (all worktrees, filtered by branch) [x] T025 [P] [US2] Add command examples for remaining commands (manual documentation created) [x] T026 [US2] Update docs/toc.yml to include commands section with auto-generated command list [x] T027 [US2] Add search functionality configuration to docfx.json (enable DocFX search plugin) [x] T028 [US2] Update index.md to include Command Reference section link with search call-to-action [x] T029 [US2] Add DocGenerator execution step to .github/workflows/release.yml before DocFX build (dotnet run --project Tools/DocGenerator -- --output docs/) Checkpoint: Command reference complete - all commands documented with examples and searchable Phase 5: User Story 3 - Version-Specific Documentation Access (Priority: P2) Goal: Users can switch between minor versions to see accurate documentation for their installed version (SC-004, FR-006, FR-007) Independent Test: A user selects a different version from the version switcher, the page reloads showing that version's documentation with updated URL Implementation for User Story 3 [ ] T030 [US3] Create version-switcher.js JavaScript module with version manifest fetching and dropdown population logic [ ] T031 [US3] Add version detection logic to version-switcher.js (extract version from URL path /v{major}.{minor}/) [ ] T032 [US3] Add version navigation logic to version-switcher.js (preserve current page path when switching versions) [ ] T033 [US3] Create version-switcher.css stylesheet with dropdown styling and current version indicator [ ] T034 [US3] Add version switcher HTML to docfx.json template overrides (inject into page header) [ ] T035 [US3] Update .github/scripts/update-version-manifest.py to handle first release case (peaceiris action handles existing manifest fetching) [ ] T036 [US3] Add new version entry logic to .github/scripts/update-version-manifest.py (update isLatest flags, add new version, sort by version) [ ] T037 [US3] Add manifest validation to .github/scripts/update-version-manifest.py (ensure one isLatest, valid JSON schema) [x] T038 [US3] Add version-specific directory structure to .github/workflows/release.yml (build to _site/v{major}.{minor}/) [x] T039 [US3] Add manifest update step to .github/workflows/release.yml (python .github/scripts/update-version-manifest.py) [x] T040 [US3] Add manifest deployment step to .github/workflows/release.yml (copy to root and version directory) [ ] T041 [US3] [FR-010] Create redirect page at root (_site/index.html) to automatically redirect to latest version from versions.json [ ] T042 [US3] Add version indicator to page footer in docfx.json template (display current version on every page per FR-007) Checkpoint: Version switching functional - users can access documentation for any published minor version Phase 6: User Story 4 - API Reference for Developers (Priority: P2) Goal: Developers can find comprehensive API documentation for all public interfaces (SC-006, FR-005, FR-015) Independent Test: A developer navigates to API Reference, finds a specific class, sees method signatures with XML comments, and successfully integrates it Implementation for User Story 4 [ ] T043 [US4] Verify wt.cli.csproj has NoWarn configuration to suppress 1591 warnings during development [ ] T044 [US4] Configure docfx.json metadata section to extract API documentation from wt.cli XML output [ ] T045 [US4] Add API reference section to docs/toc.yml with automatic API navigation structure [ ] T046 [US4] Create docs/api/index.md overview page with API integration patterns and examples [ ] T047 [US4] Add xref configuration to docfx.json for .NET framework cross-references [ ] T048 [US4] Add DocFX metadata generation step to .github/workflows/release.yml (docfx metadata) [ ] T049 [US4] Add API documentation build step to .github/workflows/release.yml (docfx build with API metadata) [ ] T050 [US4] Update docs/index.md to include API Reference section link for developers Checkpoint: API documentation complete - 100% of public APIs documented and accessible Phase 7: User Story 5 - Contributing to the Project (Priority: P3) Goal: Contributors can set up development environment with 95% success rate (SC-005, FR-004) Independent Test: A new contributor follows docs/contributing.md, sets up environment, runs tests, and submits a PR Implementation for User Story 5 [ ] T051 [US5] Create docs/contributing.md with development environment setup section (prerequisites: .NET 10 SDK, Git) [ ] T052 [US5] Add setup steps to docs/contributing.md (clone, dotnet restore, dotnet build, dotnet test, dotnet run) [ ] T053 [US5] Add coding standards section to docs/contributing.md with link to .specify/memory/constitution.md [ ] T054 [US5] Add TDD workflow section to docs/contributing.md (write tests first, implement, refactor) [ ] T055 [US5] Add pull request process to docs/contributing.md (create branch, write tests, implement, submit PR) [ ] T056 [US5] Add issue reporting section to docs/contributing.md (bug report template, feature request template) [ ] T057 [US5] Add note distinguishing user installation (no .NET) vs developer setup (.NET SDK required) [ ] T058 [US5] Update docs/toc.yml to include contributing guide in navigation [ ] T059 [US5] Update docs/index.md to include Contributing section link Checkpoint: Contribution guide complete - new contributors can set up and contribute successfully Phase 8: Polish & Cross-Cutting Concerns Purpose: Quality improvements and validation [ ] T060 [P] Add LinkChecker step to .github/workflows/release.yml for link validation (check internal and external links) [ ] T061 [P] Add DocFX build validation with --warningsAsErrors flag to .github/workflows/release.yml [ ] T062 [P] Create docs/ja/ directory with Japanese translations for key documentation pages (installation, command overview) [ ] T063 [P] Add CODE_OF_CONDUCT.md link to docs/contributing.md [ ] T064 Add performance optimization to docfx.json (enable caching, optimize asset loading per SC-007) [ ] T065 Add 404 error page to docs/404.md with navigation back to latest version [ ] T066 Test complete workflow end-to-end with mock release event [ ] T067 Validate documentation loads within 2 seconds on standard broadband (SC-007) [ ] T068 Verify all edge cases from spec.md (non-existent version, JavaScript disabled, deprecated versions) [ ] T069 Run quickstart.md validation to ensure 4-6 hour implementation estimate is accurate Dependencies & Execution Order Phase Dependencies Setup (Phase 1): No dependencies - can start immediately Foundational (Phase 2): Depends on Setup completion - BLOCKS all user stories User Stories (Phase 3-7): All depend on Foundational phase completion User stories can proceed in parallel if team capacity allows Or sequentially in priority order: US1 → US2 → US3 → US4 → US5 Polish (Phase 8): Depends on desired user stories being complete User Story Dependencies User Story 1 (P1): Can start after Foundational (Phase 2) - Independent User Story 2 (P1): Can start after Foundational (Phase 2) - Independent User Story 3 (P2): Can start after Foundational (Phase 2) - Enhances US1 and US2 but independently testable User Story 4 (P2): Can start after Foundational (Phase 2) - Independent User Story 5 (P3): Can start after Foundational (Phase 2) - Independent Within Each User Story Tasks should be completed in order unless marked [P] User story is complete when checkpoint criteria is met Each story delivers value independently Parallel Opportunities Phase 1: T002, T003 can run in parallel Phase 2: T006, T007, T010 can run in parallel Phase 3 (US1): T014, T015, T016 can run in parallel (different platform sections) Phase 4 (US2): T023, T024, T025 can run in parallel (different command examples) Phase 8: T060, T061, T062, T063 can run in parallel Once Foundational phase completes: All 5 user stories can be worked on in parallel by different team members Each story is independently completable and testable Parallel Example: User Story 1 (Installation Guide) # Launch all platform-specific sections together: Task T014: \"Add Windows installation instructions to docs/installation.md\" Task T015: \"Add macOS installation instructions to docs/installation.md\" Task T016: \"Add Linux installation instructions to docs/installation.md\" # These can be written simultaneously by different team members # Each section is independent and targets different file regions Parallel Example: User Story 2 (Command Reference) # Launch all command example tasks together: Task T023: \"Add command examples for 'create' command\" Task T024: \"Add command examples for 'list' command\" Task T025: \"Add command examples for remaining commands\" # All modify Tools/DocGenerator/Program.cs but in different methods # Can be developed in parallel with good coordination Implementation Strategy MVP First (User Stories 1 & 2 Only) Complete Phase 1: Setup (T001-T003) Complete Phase 2: Foundational (T004-T011) - CRITICAL BLOCKER Complete Phase 3: User Story 1 (T012-T020) - Installation Guide Complete Phase 4: User Story 2 (T021-T029) - Command Reference STOP and VALIDATE: Test installation and command lookup independently Deploy to GitHub Pages and validate with real users This is the minimum viable documentation (SC-001, SC-002 met) Incremental Delivery Foundation (Phases 1-2) → Documentation infrastructure ready MVP (Phases 3-4) → Installation + Commands → Deploy (satisfies P1 requirements) Enhanced (+Phase 5) → Add version switching → Deploy (satisfies FR-006, FR-007) Developer Support (+Phase 6) → Add API docs → Deploy (satisfies FR-005, SC-006) Community (+Phase 7) → Add contribution guide → Deploy (satisfies FR-004, SC-005) Polish (Phase 8) → Quality improvements → Final deployment Parallel Team Strategy With multiple developers: Team completes Setup + Foundational together (critical path) Once Foundational is done (after T011): Developer A: User Story 1 (Installation Guide) Developer B: User Story 2 (Command Reference) Developer C: User Story 3 (Version Switching) Developer D: User Story 4 (API Reference) Developer E: User Story 5 (Contribution Guide) Stories complete independently and integrate via GitHub Pages deployment Single Developer Strategy Follow sequential priority order: Setup → Foundational → US1 → US2 → US3 → US4 → US5 → Polish Deploy after US1+US2 for early user feedback Deploy again after each additional story Estimated total time: 4-6 hours for US1+US2, +1-2 hours per additional story Notes No xUnit tests: Documentation validated through DocFX build and LinkChecker Auto-generation: Command docs and API docs generated automatically (T004-T005, T021, T048-T049) Version management: Python script handles manifest updates (T009, T035-T037) Deployment: GitHub Actions orchestrates entire workflow (T006-T010, T029, T038-T041, T048-T049, T060-T061) Constitution compliance: All gates passed (see plan.md Constitution Check section) Performance: Static site architecture ensures SC-007 (2-second load time) Coverage: API docs cover 100% public APIs per SC-006 Automation: Documentation publishes within 10 minutes per SC-003 Total Tasks: 69 tasks organized into 8 phases (5 user stories + setup/foundational/polish) MVP Scope: Phases 1-4 (32 tasks) deliver minimum viable documentation Full Scope: All 8 phases (69 tasks) deliver complete documentation system Estimated Time: MVP (US1+US2): 4-6 hours Enhanced (+US3): +1-2 hours Developer (+US4): +1 hour Community (+US5): +1 hour Polish: +1 hour Total: 8-11 hours for complete feature Parallel Opportunities: 15+ tasks can run in parallel, reducing total time by 30-40% with multiple developers"
  },
  "specs/002-list-worktree-branches/checklists/requirements.html": {
    "href": "specs/002-list-worktree-branches/checklists/requirements.html",
    "title": "Specification Quality Checklist: List Worktree and Branch Information | wt",
    "summary": "Specification Quality Checklist: List Worktree and Branch Information Purpose: Validate specification completeness and quality before proceeding to planning Created: 2026-01-04 Feature: spec.md Content Quality [x] No implementation details (languages, frameworks, APIs) [x] Focused on user value and business needs [x] Written for non-technical stakeholders [x] All mandatory sections completed Requirement Completeness [x] No [NEEDS CLARIFICATION] markers remain [x] Requirements are testable and unambiguous [x] Success criteria are measurable [x] Success criteria are technology-agnostic (no implementation details) [x] All acceptance scenarios are defined [x] Edge cases are identified [x] Scope is clearly bounded [x] Dependencies and assumptions identified Feature Readiness [x] All functional requirements have clear acceptance criteria [x] User scenarios cover primary flows [x] Feature meets measurable outcomes defined in Success Criteria [x] No implementation details leak into specification Notes All items are complete. Specification is ready for /speckit.clarify or /speckit.plan"
  },
  "specs/002-list-worktree-branches/contracts/cli-interface.html": {
    "href": "specs/002-list-worktree-branches/contracts/cli-interface.html",
    "title": "CLI Interface Contract: Worktree List コマンド | wt",
    "summary": "CLI Interface Contract: Worktree List コマンド Phase: 1 - Design & Contracts Date: 2026-01-04 Feature: spec.md | plan.md Purpose このドキュメントは、worktree一覧表示コマンドのCLIインターフェース契約を定義します。コマンド構文、引数、オプション、出力形式、エラーコード、動作仕様を明確にします。 Command Structure Base Command wt list Aliases 将来的に以下のエイリアスを検討（初期実装では未サポート）: wt ls Arguments Positional Arguments なし。このコマンドは引数を取りません。 Options --format, -f 説明: 出力フォーマットを指定します（将来の拡張、P3） 型: string デフォルト: table 許可値: table, json, csv（初期実装ではtableのみサポート） 例: wt list --format table wt list -f json # 将来の実装 --verbose, -v 説明: 詳細情報を表示します（将来の拡張） 型: flag（boolean） デフォルト: false 例: wt list --verbose wt list -v 詳細モードでは以下の追加情報を表示: 完全なコミットハッシュ（40文字） 最終更新日時 ブランチのアップストリーム情報 注意: 初期実装（P1、P2）では未サポート Output Formats Table Format (デフォルト) ┌─────────────────────────────────┬──────────────────┬──────────┐ │ Path │ Branch │ Status │ ├─────────────────────────────────┼──────────────────┼──────────┤ │ /Users/dev/project/wt │ main │ active │ │ /Users/dev/project/feature-wt │ feature-branch │ active │ │ /Users/dev/project/hotfix-wt │ abc1234 (detached)│ active │ └─────────────────────────────────┴──────────────────┴──────────┘ 列の説明: Column Description Example Path Worktreeの絶対パス /Users/dev/project/wt Branch ブランチ名またはdetached HEAD main, abc1234 (detached) Status worktreeの状態 active, missing テーブル仕様: ヘッダー行: 列名を表示 罫線: Unicode Box Drawing文字（┌─┬─┐ ├─┼─┤ └─┴─┘ │） 列幅: 内容に応じて動的に調整（最小幅: ヘッダー幅） 配置: すべて左揃え ソート: 作成日時の新しい順（最新のworktreeが最初） Worktree Not Found Case worktreeが1つも存在しない場合: No worktrees found in this repository. Warning Messages ディスク上に存在しないworktreeがある場合（FR-008）: Warning: Worktree at '/Users/dev/project/missing-wt' does not exist on disk ┌─────────────────────────────────┬──────────────────┬──────────┐ │ Path │ Branch │ Status │ ├─────────────────────────────────┼──────────────────┼──────────┤ │ /Users/dev/project/wt │ main │ active │ │ /Users/dev/project/feature-wt │ feature-branch │ active │ └─────────────────────────────────┴──────────────────┴──────────┘ 警告メッセージは標準エラー出力（stderr）に出力し、テーブルは標準出力（stdout）に出力します。 Exit Codes Code Condition Description 0 Success コマンドが正常に完了 1 Git not found Gitが実行できない（git worktreeコマンド未対応含む） 2 Not a git repository 現在のディレクトリがGitリポジトリではない 10 Git command failed git worktree listの実行が失敗 99 Unexpected error 予期しないエラー 重要: 警告（存在しないworktree）が発生してもexit code 0を返します。 Error Messages Git Not Found Error: Git command not found. Please ensure Git is installed and available in PATH. Exit code: 1 Not a Git Repository Error: Not a git repository. Please run this command from within a git repository. Exit code: 2 Git Command Failed Error: Failed to list worktrees. Git output: fatal: this operation must be run in a work tree Run with --verbose for more details. Exit code: 10 Behavior Specifications Pre-conditions コマンドはGitリポジトリ内で実行される必要がある Git 2.5以上がインストールされている必要がある git worktree listコマンドが使用可能である必要がある Execution Flow 1. カレントディレクトリがGitリポジトリか確認 ├─ No → Error (exit code 2) └─ Yes → 次へ 2. `git worktree list --porcelain` を実行 ├─ 失敗 → Error (exit code 10) └─ 成功 → 次へ 3. ポーセラン出力をパース ├─ worktreeなし → \"No worktrees found\" メッセージ (exit code 0) └─ worktreeあり → 次へ 4. 各worktreeの情報を収集 ├─ パス、ブランチ、detached状態、コミットハッシュ ├─ 作成日時 (.git/worktrees/<name>/gitdir のタイムスタンプ) └─ 存在確認 (Directory.Exists) 5. 作成日時の降順でソート 6. テーブル整形 └─ 列幅を動的計算 7. 出力 ├─ 警告メッセージ (stderr) - 存在しないworktreeがある場合 └─ テーブル (stdout) 8. Exit (code 0) Post-conditions 標準出力にテーブルが表示される 警告がある場合、標準エラー出力に警告が表示される 正常終了時のexit codeは0 Examples 基本的な使用例 $ wt list ┌─────────────────────────────────┬──────────────────┬──────────┐ │ Path │ Branch │ Status │ ├─────────────────────────────────┼──────────────────┼──────────┤ │ /Users/dev/project/main-wt │ main │ active │ │ /Users/dev/project/feature-wt │ feature-new │ active │ └─────────────────────────────────┴──────────────────┴──────────┘ Detached HEAD状態を含む例 $ wt list ┌─────────────────────────────────┬────────────────────┬──────────┐ │ Path │ Branch │ Status │ ├─────────────────────────────────┼────────────────────┼──────────┤ │ /Users/dev/project/main-wt │ main │ active │ │ /Users/dev/project/hotfix-wt │ abc1234 (detached) │ active │ └─────────────────────────────────┴────────────────────┴──────────┘ 存在しないworktreeがある例 $ wt list Warning: Worktree at '/Users/dev/project/deleted-wt' does not exist on disk ┌─────────────────────────────────┬──────────────────┬──────────┐ │ Path │ Branch │ Status │ ├─────────────────────────────────┼──────────────────┼──────────┤ │ /Users/dev/project/main-wt │ main │ active │ │ /Users/dev/project/feature-wt │ feature-new │ active │ └─────────────────────────────────┴──────────────────┴──────────┘ $ echo $? 0 Worktreeが存在しない例 $ wt list No worktrees found in this repository. $ echo $? 0 エラー例: Gitリポジトリではない $ cd /tmp $ wt list Error: Not a git repository. Please run this command from within a git repository. $ echo $? 2 Implementation Notes System.CommandLine統合 var listCommand = new Command(\"list\", \"List all worktrees with their branches\"); // 将来のオプション（初期実装では未使用） var formatOption = new Option<string>( aliases: new[] { \"--format\", \"-f\" }, getDefaultValue: () => \"table\", description: \"Output format (table, json, csv)\"); listCommand.AddOption(formatOption); listCommand.SetHandler(async (format) => { // ハンドラー実装 var service = GetWorktreeService(); var worktrees = await service.ListWorktreesAsync(); var formatter = new TableFormatter(); var output = formatter.Format(worktrees); Console.WriteLine(output); }, formatOption); テーブル整形 Formatters/TableFormatter.csクラスが以下の責務を持ちます: namespace Kuju63.WorkTree.CommandLine.Formatters; public class TableFormatter { public string Format(IEnumerable<WorktreeInfo> worktrees) { // 1. 列幅の計算 // 2. ヘッダー行の生成 // 3. 罫線の生成 // 4. データ行の生成 // 5. 結合して返す } private int CalculateColumnWidth(string header, IEnumerable<string> values) { // ヘッダーとすべての値の最大幅を返す } private string GenerateSeparator(int[] columnWidths, string left, string mid, string right) { // 罫線を生成（┌─┬─┐ 等） } } Testing Strategy ユニットテスト コマンドハンドラーのテスト（モックサービス使用） TableFormatterの各メソッドのテスト エラーケースのテスト（Git未検出、非リポジトリ等） 統合テスト 実際のGitリポジトリでのエンドツーエンドテスト 複数worktreeのシナリオテスト Detached HEAD状態のテスト 存在しないworktreeの警告テスト 契約テスト 出力形式の正確性検証（テーブル罫線、列配置等） Exit codeの検証 エラーメッセージの検証 Compliance このCLI契約は以下の仕様要件を満たしています: FR-001: すべてのアクティブなworktreeのリストを表示 FR-002: 各worktreeの現在のブランチを表示 FR-003: テーブル形式で出力を表示 FR-004: Detached HEAD状態を処理 FR-005: worktreeパスとブランチ情報を表示 FR-006: コマンドラインインターフェースから呼び出し可能 FR-007: 作成日時順（新しい順）でソート FR-008: 存在しないworktreeに対して警告を表示し、処理を継続 Future Extensions (P3) JSON Format (将来) $ wt list --format json [ { \"path\": \"/Users/dev/project/main-wt\", \"branch\": \"main\", \"is_detached\": false, \"commit_hash\": \"abc1234567890abcdef1234567890abcdef1234\", \"created_at\": \"2026-01-04T10:30:00+09:00\", \"exists\": true } ] CSV Format (将来) $ wt list --format csv Path,Branch,Status,Created At /Users/dev/project/main-wt,main,active,2026-01-04T10:30:00+09:00 /Users/dev/project/feature-wt,feature-new,active,2026-01-04T11:00:00+09:00 Summary CLI Interface契約は以下の点で明確に定義されています: コマンド構文: シンプルで覚えやすい 出力形式: テーブル形式で視覚的に明確 エラーハンドリング: 適切なexit codeと明確なエラーメッセージ 拡張性: 将来のフォーマット追加に対応可能 互換性: System.CommandLineの標準パターンに準拠 この契約に基づいて、実装とテストを進めることができます。"
  },
  "specs/002-list-worktree-branches/data-model.html": {
    "href": "specs/002-list-worktree-branches/data-model.html",
    "title": "Data Model: Worktreeとブランチ情報 | wt",
    "summary": "Data Model: Worktreeとブランチ情報 Phase: 1 - Design & Contracts Date: 2026-01-04 Feature: spec.md | plan.md | research.md Purpose このドキュメントは、worktreeとブランチ一覧表示機能のデータモデルを定義します。仕様書（spec.md）の主要エンティティを具体的なC#クラスとして設計し、プロパティ、バリデーションルール、関係性を明確にします。 Core Entities WorktreeInfo worktreeインスタンスの情報を表現するモデル。 namespace Kuju63.WorkTree.CommandLine.Models { /// <summary> /// Git worktreeの情報を表現します。 /// </summary> public class WorktreeInfo { /// <summary> /// Worktreeのファイルシステム上のパス /// </summary> /// <remarks> /// 絶対パスである必要があります。 /// 存在しないパスの場合でも格納可能（警告表示用）。 /// </remarks> public required string Path { get; init; } /// <summary> /// チェックアウトされているブランチ名 /// </summary> /// <remarks> /// Detached HEAD状態の場合は短縮コミットハッシュを含む。 /// 例: \"main\", \"feature/new-feature\", \"abc1234\" /// </remarks> public required string Branch { get; init; } /// <summary> /// Detached HEAD状態かどうか /// </summary> public bool IsDetached { get; init; } /// <summary> /// 現在のHEADのコミットハッシュ（完全形） /// </summary> /// <remarks> /// 40文字の16進数文字列。 /// 短縮形が必要な場合はSubstring(0, 7)を使用。 /// </remarks> public required string CommitHash { get; init; } /// <summary> /// Worktreeの作成日時 /// </summary> /// <remarks> /// ローカルタイムゾーン。 /// .git/worktrees/<name>/gitdirファイルの作成日時から取得。 /// </remarks> public DateTime CreatedAt { get; init; } /// <summary> /// Worktreeがファイルシステム上に存在するか /// </summary> /// <remarks> /// Directory.Exists()の結果をキャッシュ。 /// falseの場合、警告メッセージを表示する必要がある。 /// </remarks> public bool Exists { get; init; } /// <summary> /// 表示用のブランチ文字列を取得します /// </summary> /// <returns> /// 通常のブランチ: ブランチ名 /// Detached HEAD: \"abc1234 (detached)\" /// </returns> public string GetDisplayBranch() { if (IsDetached) { var shortHash = CommitHash.Length >= 7 ? CommitHash.Substring(0, 7) : CommitHash; return $\"{shortHash} (detached)\"; } return Branch; } /// <summary> /// 表示用のステータス文字列を取得します /// </summary> /// <returns> /// 存在する: \"active\" /// 存在しない: \"missing\" /// </returns> public string GetDisplayStatus() { return Exists ? \"active\" : \"missing\"; } } } BranchInfo ブランチ参照の情報を表現するモデル（将来の拡張用）。 namespace Kuju63.WorkTree.CommandLine.Models { /// <summary> /// Gitブランチの情報を表現します。 /// </summary> /// <remarks> /// 現在のフェーズでは使用しませんが、将来の拡張（ブランチ一覧表示等）のために定義します。 /// </remarks> public class BranchInfo { /// <summary> /// ブランチ名（refs/heads/を除いた形式） /// </summary> /// <example>main, feature/new-feature</example> public required string Name { get; init; } /// <summary> /// ブランチのHEADコミットハッシュ /// </summary> public required string CommitHash { get; init; } /// <summary> /// いずれかのworktreeでチェックアウトされているか /// </summary> public bool IsCheckedOut { get; init; } /// <summary> /// チェックアウトしているworktreeのパス（複数の場合は最初の1つ） /// </summary> /// <remarks> /// IsCheckedOut=trueの場合のみ有効。 /// nullの場合、どのworktreeでもチェックアウトされていない。 /// </remarks> public string? WorktreePath { get; init; } } } Validation Rules WorktreeInfo Validation Property Rule Error Message Path 必須、空文字列不可 \"Worktree path is required\" Path 絶対パスであること \"Worktree path must be absolute\" Branch 必須、空文字列不可 \"Branch name is required\" Branch 有効なGit参照名 \"Invalid branch name format\" CommitHash 必須、40文字の16進数 \"Invalid commit hash format\" CreatedAt DateTime.MinValue以外 \"Invalid creation date\" 実装例: public static class WorktreeInfoValidator { public static ValidationResult Validate(WorktreeInfo info) { var errors = new List<string>(); if (string.IsNullOrWhiteSpace(info.Path)) errors.Add(\"Worktree path is required\"); else if (!System.IO.Path.IsPathRooted(info.Path)) errors.Add(\"Worktree path must be absolute\"); if (string.IsNullOrWhiteSpace(info.Branch)) errors.Add(\"Branch name is required\"); if (string.IsNullOrWhiteSpace(info.CommitHash) || !IsValidCommitHash(info.CommitHash)) errors.Add(\"Invalid commit hash format\"); if (info.CreatedAt == DateTime.MinValue) errors.Add(\"Invalid creation date\"); return errors.Count == 0 ? ValidationResult.Success() : ValidationResult.Failure(errors); } private static bool IsValidCommitHash(string hash) { return hash.Length == 40 && hash.All(c => char.IsDigit(c) || (c >= 'a' && c <= 'f')); } } Entity Relationships WorktreeInfo (1) --- (0..1) BranchInfo │ │ 集約: Worktreeは単一のブランチまたはdetached HEADを持つ │ 方向: WorktreeInfo.Branch → BranchInfo.Name │ └─ IsDetached=false の場合のみBranchInfoと関連 注意: 現在の実装（Phase 1）では、BranchInfoは使用せず、WorktreeInfoのみを使用します。将来、ブランチ一覧機能を追加する際にBranchInfoを活用します。 State Transitions WorktreeInfoには明示的な状態遷移はありませんが、以下のような不変の状態があります： [Created] ─┬─> [Exists=true, IsDetached=false] 通常のブランチ ├─> [Exists=true, IsDetached=true] Detached HEAD ├─> [Exists=false, IsDetached=false] 削除された（ブランチ） └─> [Exists=false, IsDetached=true] 削除された（Detached） すべてのWorktreeInfoインスタンスは不変（immutable）です。状態変更は新しいインスタンスの生成により行います。 Data Flow 1. GitService.ListWorktreesAsync() ↓ git worktree list --porcelain 実行 ↓ ポーセラン出力をパース ↓ 2. WorktreeInfo インスタンス生成 ├─ Path: ポーセラン出力の\"worktree\"行から取得 ├─ Branch: \"branch\"行から取得（detachedの場合は\"HEAD\"行から） ├─ IsDetached: \"detached\"行の有無で判定 ├─ CommitHash: \"HEAD\"行から取得 ├─ CreatedAt: .git/worktrees/<name>/gitdirのファイルタイムスタンプ └─ Exists: Directory.Exists(Path)の結果 ↓ 3. ソート: CreatedAt降順 ↓ 4. TableFormatter.Format(worktrees) ↓ テーブル文字列生成 ↓ 5. Console出力 Persistence このモデルはメモリ上のみに存在し、永続化は行いません。すべての情報はGitリポジトリとファイルシステムから動的に取得します。 Serialization 将来の拡張（P3: 代替出力フォーマット）のために、JSON シリアライゼーションをサポートする設計にします。 // System.Text.Json 互換 [JsonPropertyName(\"path\")] public required string Path { get; init; } [JsonPropertyName(\"branch\")] public required string Branch { get; init; } [JsonPropertyName(\"is_detached\")] public bool IsDetached { get; init; } [JsonPropertyName(\"commit_hash\")] public required string CommitHash { get; init; } [JsonPropertyName(\"created_at\")] public DateTime CreatedAt { get; init; } [JsonPropertyName(\"exists\")] public bool Exists { get; init; } JSON出力例: [ { \"path\": \"/Users/dev/project/wt\", \"branch\": \"main\", \"is_detached\": false, \"commit_hash\": \"abc1234567890abcdef1234567890abcdef1234\", \"created_at\": \"2026-01-04T10:30:00+09:00\", \"exists\": true }, { \"path\": \"/Users/dev/project/feature-wt\", \"branch\": \"feature-branch\", \"is_detached\": false, \"commit_hash\": \"def5678901234567890abcdef1234567890abcde\", \"created_at\": \"2026-01-04T11:00:00+09:00\", \"exists\": true } ] Testing Considerations ユニットテスト GetDisplayBranch()メソッドのテスト: 通常のブランチ名が正しく返される Detached HEADの場合、短縮ハッシュ + \"(detached)\"が返される コミットハッシュが7文字未満の場合でも動作する GetDisplayStatus()メソッドのテスト: Exists=trueの場合 \"active\" Exists=falseの場合 \"missing\" バリデーションのテスト: 各プロパティのバリデーションルールが正しく機能する 複数のエラーが同時に検出される 統合テスト Gitリポジトリから実際にWorktreeInfoを生成するテスト 存在しないworktreeの検出テスト Detached HEAD状態のworktreeの処理テスト Summary データモデルは以下の原則に従って設計されています： 不変性: すべてのプロパティはinit-onlyで不変 明示性: 各プロパティの用途と制約が明確 拡張性: 将来の機能追加（JSON出力、ブランチ一覧）に対応可能 テスト可能性: バリデーションとビジネスロジックが分離 型安全性: required修飾子とnull許容型で安全性を確保 次のステップ: contracts/cli-interface.mdでCLIインターフェース仕様を定義します。"
  },
  "specs/002-list-worktree-branches/plan.html": {
    "href": "specs/002-list-worktree-branches/plan.html",
    "title": "Implementation Plan: Worktreeとブランチ情報の一覧表示 | wt",
    "summary": "Implementation Plan: Worktreeとブランチ情報の一覧表示 Branch: 002-list-worktree-branches | Date: 2026-01-04 | Spec: spec.md Input: Feature specification from /specs/002-list-worktree-branches/spec.md Note: This template is filled in by the /speckit.plan command. See .specify/templates/commands/plan.md for the execution workflow. Summary Git worktreeとブランチの一覧を表示するCLIコマンドを開発します。開発者はwt listコマンドを実行することで、すべてのworktreeとその各worktreeでチェックアウトされているブランチをテーブル形式で確認できます。出力には、worktreeのパス、ブランチ名、ステータス（通常/detached HEAD）が含まれます。これにより、複数のworktreeを使用した並列作業時に、どのworktreeでどのブランチを作業しているかを一目で把握できます。 Technical Approach: 既存のC# .NET 10 CLIツール（wt.cli）に新しいlistコマンドを追加。git worktree listコマンドの出力を解析し、各worktreeのブランチ情報を取得してテーブル形式で整形します。作成日時順ソートのために、Gitの内部情報またはファイルシステムのメタデータを活用します。 Technical Context Language/Version: C# .NET 10 (既存プロジェクトwt.cliに統合) Primary Dependencies: System.CommandLine 2.0.1 (CLIフレームワーク) System.IO.Abstractions 22.1.0 (パス操作の抽象化) System.Text.Json または Newtonsoft.Json (将来の代替フォーマット対応用) Storage: N/A (ファイルシステムとGitの内部情報のみ使用) Testing: xUnit, Shouldly, Moq (既存プロジェクトで使用中) Target Platform: Windows, macOS, Linux (クロスプラットフォーム) Project Type: single (CLIツール - 既存プロジェクトに機能追加) Performance Goals: git worktree list実行から表示完了まで 3秒以内 10個のworktreeで1秒以内にテーブル表示 メモリ使用量 < 50MB（既存の軽量性を維持） Constraints: Git 2.5以上が必要（git worktree サポート） クロスプラットフォーム対応必須（憲章 II） 外部依存関係は最小限（憲章 V） TDDアプローチ必須（憲章 VI） P3（代替出力フォーマット）は初期リリースで未実装 Scale/Scope: 単一ユーザー・単一リポジトリでの使用 想定worktree数: 通常1-10個、最大100個 同時実行想定なし（ローカルCLI） Constitution Check GATE: Must pass before Phase 0 research. Re-check after Phase 1 design. Principle Requirement Status Notes I. Developer Usability CLI優先、明瞭な操作 ✅ PASS シンプルなコマンド構文、テーブル形式の読みやすい出力（FR-003） I. Developer Usability エラーメッセージに解決策 ✅ PASS 存在しないworktreeに対する明確な警告メッセージ（FR-008） II. Cross-Platform Windows/macOS/Linux対応 ✅ PASS .NET 10のクロスプラットフォーム対応、System.IO.Abstractionsでパス抽象化 II. Cross-Platform OS固有機能に非依存 ✅ PASS Gitコマンド実行のみ、プラットフォーム固有処理なし III. Clean & Secure セキュアなコード ✅ PASS 機密情報なし、Git出力の安全な解析 III. Clean & Secure 静的解析 ✅ PASS .NETの標準アナライザー使用、既存プロジェクトの品質基準を継承 IV. Documentation 日本語ドキュメント優先 ✅ PASS 仕様書とガイドは日本語で作成 IV. Documentation ADRで技術決定記録 ✅ PASS テーブル表示ライブラリ選定等の技術決定をADRとして記録予定 V. Minimal Dependencies 最小限の依存 ✅ PASS 新規依存関係なし、既存の依存関係（System.CommandLine等）のみ使用 V. Minimal Dependencies 標準ライブラリ優先 ✅ PASS テーブル整形は標準ライブラリで実装可能、必要に応じて軽量ライブラリを検討 VI. Testing TDD必須 ✅ PASS xUnit + Shouldly + Moq でテスト先行開発 VI. Testing CI/CDでテスト自動化 ✅ PASS 既存のCI/CDパイプラインで自動テスト実行 Overall Status: ✅ PASS - All gates passed. Justifications: なし - 違反なし。既存の憲章準拠プロジェクトに機能追加するため、すべての原則を自然に満たします。 Project Structure Documentation (this feature) specs/002-list-worktree-branches/ ├── spec.md # 機能仕様書（完成） ├── plan.md # This file (実装計画書) ├── research.md # Phase 0 output (/speckit.plan command) ├── data-model.md # Phase 1 output (/speckit.plan command) ├── quickstart.md # Phase 1 output (/speckit.plan command) ├── contracts/ # Phase 1 output (/speckit.plan command) │ └── cli-interface.md # CLIコマンドインターフェース仕様 └── tasks.md # Phase 2 output (/speckit.tasks command - NOT created by /speckit.plan) Source Code (repository root) wt.cli/ # 既存CLIプロジェクト ├── Program.cs # エントリーポイント（既存） ├── Commands/ │ ├── Worktree/ # worktreeコマンドグループ（既存） │ │ └── CreateCommand.cs # 既存: 'create' コマンド │ └── ListCommand.cs # 新規: 'list' コマンド ├── Services/ │ ├── Git/ │ │ ├── IGitService.cs # 既存: Gitサービスインターフェース │ │ └── GitService.cs # 拡張: worktree情報取得メソッド追加 │ └── Worktree/ │ ├── IWorktreeService.cs # 既存: Worktreeサービスインターフェース │ └── WorktreeService.cs # 拡張: list機能追加 ├── Models/ │ ├── WorktreeInfo.cs # 新規: Worktree情報モデル │ └── BranchInfo.cs # 新規: ブランチ情報モデル └── Formatters/ ├── IOutputFormatter.cs # 新規: フォーマッターインターフェース（将来の拡張用） └── TableFormatter.cs # 新規: テーブル整形実装 wt.tests/ # 既存テストプロジェクト ├── Commands/ │ └── ListCommandTests.cs # 新規: ListCommandのテスト ├── Services/ │ ├── Git/ │ │ └── GitServiceTests.cs # 拡張: worktree情報取得のテスト追加 │ └── Worktree/ │ └── WorktreeServiceTests.cs # 拡張: list機能のテスト追加 └── Formatters/ └── TableFormatterTests.cs # 新規: テーブル整形のテスト Structure Decision: 既存の単一プロジェクト構造（wt.cli）に機能を追加します。worktreeコマンドグループに新しいListCommandを追加し、既存のGitServiceとWorktreeServiceを拡張してworktree一覧取得機能を実装します。テーブル整形用の新しいユーティリティクラスを追加します。 Complexity Tracking Fill ONLY if Constitution Check has violations that must be justified N/A - すべての憲章チェックが合格しており、違反はありません。 Violation Why Needed Simpler Alternative Rejected Because [e.g., 4th project] [current need] [why 3 projects insufficient] Phase Summary Phase 0: Research ✅ Complete すべての技術的不明点を解決しました： git worktree list --porcelainの出力形式とパース方法 Worktree作成日時の取得方法（.git/worktrees/<name>/gitdirのタイムスタンプ） テーブル整形アプローチ（カスタムTableFormatter実装、依存関係ゼロ） Detached HEAD表示方法（短縮コミットハッシュ + \"(detached)\"） エラーハンドリング（存在しないworktreeの警告表示） 詳細: research.md Phase 1: Design & Contracts ✅ Complete 以下のドキュメントを作成しました： data-model.md: WorktreeInfo、BranchInfoモデルの詳細設計 不変（immutable）な設計 バリデーションルール 表示用メソッド（GetDisplayBranch、GetDisplayStatus） contracts/cli-interface.md: CLIコマンド仕様 コマンド構文: wt worktree list テーブル形式の出力仕様 Exit code定義 エラーメッセージ仕様 quickstart.md: 開発者向けクイックスタートガイド TDDサイクルの実践手順 Phase 1〜6の実装ステップ テストファーストアプローチ Agent Context更新: GitHub Copilot用のコンテキストファイル更新完了 Constitution Re-check ✅ Passed Phase 1設計完了後の再チェック結果: Principle Status Notes I. Developer Usability ✅ PASS テーブル形式の明確な出力、エラーメッセージも明確 II. Cross-Platform ✅ PASS .NET 10のクロスプラットフォーム対応を活用 III. Clean & Secure ✅ PASS 入力バリデーション、安全なGit出力パース IV. Documentation ✅ PASS すべてのドキュメントを日本語で作成完了 V. Minimal Dependencies ✅ PASS 新規依存関係なし、カスタムTableFormatter実装 VI. Testing ✅ PASS TDDアプローチ、quickstart.mdに詳細な手順 Overall: ✅ PASS - All principles maintained after design phase. Next Steps Phase 2: Task Breakdown - /speckit.tasksコマンドを実行 実装フェーズに進むために、以下のタスク分解が必要です： WorktreeInfoモデルの実装とテスト BranchInfoモデルの実装（将来用） GitService.ListWorktreesAsync()の実装とテスト TableFormatterの実装とテスト ListCommandの実装とテスト Program.csへの統合 統合テストの実装 ドキュメント更新 詳細なタスク分解はtasks.mdに記載されます（/speckit.tasksコマンドで生成）。 Artifacts Generated Artifact Path Status 実装計画書 plan.md ✅ Complete リサーチドキュメント research.md ✅ Complete データモデル data-model.md ✅ Complete CLI契約 contracts/cli-interface.md ✅ Complete クイックスタート quickstart.md ✅ Complete タスクリスト tasks.md ⏳ Pending /speckit.tasks Plan Status: ✅ COMPLETE - Ready for task breakdown and implementation. Branch: 002-list-worktree-branches Date: 2026-01-04 Next Command: /speckit.tasks | [e.g., Repository pattern] | [specific problem] | [why direct DB access insufficient] |"
  },
  "specs/002-list-worktree-branches/quickstart.html": {
    "href": "specs/002-list-worktree-branches/quickstart.html",
    "title": "Quickstart: Worktree List 機能の実装 | wt",
    "summary": "Quickstart: Worktree List 機能の実装 Phase: 1 - Design & Contracts Date: 2026-01-04 Feature: spec.md | plan.md Purpose このクイックスタートガイドは、worktree一覧表示機能を実装する開発者向けの実践的な手順を提供します。TDDアプローチに従い、テストファーストで実装を進めます。 Prerequisites .NET 10 SDK がインストールされていること Git 2.5以上がインストールされていること 既存プロジェクト（wt.cli、wt.tests）がビルド可能であること IDE（Visual Studio Code、Visual Studio、Rider等）がセットアップされていること Development Workflow このプロジェクトは TDD（テスト駆動開発） を採用しています。以下のサイクルに従ってください： Red → Green → Refactor 1. Red: テストを書き、失敗を確認 2. Green: テストをパスする最小限の実装 3. Refactor: コード品質を向上（テストは常にパス） Phase 1: モデルクラスの実装 Step 1.1: WorktreeInfoモデルのテスト作成（Red） wt.tests/Models/WorktreeInfoTests.csを作成: using Shouldly; using Kuju63.WorkTree.CommandLine.Models; using Xunit; namespace Kuju63.WorkTree.Tests.Models; public class WorktreeInfoTests { [Fact] public void GetDisplayBranch_NormalBranch_ReturnsBranchName() { // Arrange var worktree = new WorktreeInfo { Path = \"/path/to/worktree\", Branch = \"main\", IsDetached = false, CommitHash = \"abc1234567890abcdef1234567890abcdef1234\", CreatedAt = DateTime.Now, Exists = true }; // Act var result = worktree.GetDisplayBranch(); // Assert result.ShouldBe(\"main\"); } [Fact] public void GetDisplayBranch_DetachedHead_ReturnsShortHashWithLabel() { // Arrange var worktree = new WorktreeInfo { Path = \"/path/to/worktree\", Branch = \"abc1234567890abcdef1234567890abcdef1234\", IsDetached = true, CommitHash = \"abc1234567890abcdef1234567890abcdef1234\", CreatedAt = DateTime.Now, Exists = true }; // Act var result = worktree.GetDisplayBranch(); // Assert result.ShouldBe(\"abc1234 (detached)\"); } [Fact] public void GetDisplayStatus_ExistingWorktree_ReturnsActive() { // Arrange var worktree = new WorktreeInfo { Path = \"/path/to/worktree\", Branch = \"main\", IsDetached = false, CommitHash = \"abc1234567890abcdef1234567890abcdef1234\", CreatedAt = DateTime.Now, Exists = true }; // Act var result = worktree.GetDisplayStatus(); // Assert result.ShouldBe(\"active\"); } [Fact] public void GetDisplayStatus_MissingWorktree_ReturnsMissing() { // Arrange var worktree = new WorktreeInfo { Path = \"/path/to/worktree\", Branch = \"main\", IsDetached = false, CommitHash = \"abc1234567890abcdef1234567890abcdef1234\", CreatedAt = DateTime.Now, Exists = false }; // Act var result = worktree.GetDisplayStatus(); // Assert result.ShouldBe(\"missing\"); } } テスト実行: dotnet test → 失敗を確認（RedフェーズOK） Step 1.2: WorktreeInfoモデルの実装（Green） wt.cli/Models/WorktreeInfo.csを作成: namespace Kuju63.WorkTree.CommandLine.Models; /// <summary> /// Git worktreeの情報を表現します。 /// </summary> public class WorktreeInfo { public required string Path { get; init; } public required string Branch { get; init; } public bool IsDetached { get; init; } public required string CommitHash { get; init; } public DateTime CreatedAt { get; init; } public bool Exists { get; init; } public string GetDisplayBranch() { if (IsDetached) { var shortHash = CommitHash.Length >= 7 ? CommitHash.Substring(0, 7) : CommitHash; return $\"{shortHash} (detached)\"; } return Branch; } public string GetDisplayStatus() { return Exists ? \"active\" : \"missing\"; } } テスト実行: dotnet test → 成功を確認（GreenフェーズOK） Step 1.3: リファクタリング（Refactor） コードスタイルの確認 XMLドキュメントコメントの追加 必要に応じてヘルパーメソッドの抽出 テスト実行: dotnet test → 成功を維持 Phase 2: GitServiceの拡張 Step 2.1: GitServiceのテスト追加（Red） wt.tests/Services/Git/GitServiceTests.csに追加: [Fact] public async Task ListWorktreesAsync_MultipleWorktrees_ReturnsAllWorktrees() { // Arrange var mockProcessRunner = new Mock<IProcessRunner>(); mockProcessRunner .Setup(x => x.RunAsync(\"git\", \"worktree list --porcelain\", It.IsAny<string>())) .ReturnsAsync(new ProcessResult { ExitCode = 0, Output = @\"worktree /path/to/main HEAD abc1234567890abcdef1234567890abcdef1234 branch refs/heads/main worktree /path/to/feature HEAD def5678901234567890abcdef1234567890abcde branch refs/heads/feature-branch \", Error = string.Empty }); var service = new GitService(mockProcessRunner.Object); // Act var result = await service.ListWorktreesAsync(); // Assert result.Count().ShouldBe(2); result.First().Path.ShouldBe(\"/path/to/main\"); result.First().Branch.ShouldBe(\"main\"); } テスト実行: dotnet test → 失敗を確認 Step 2.2: GitServiceの実装（Green） wt.cli/Services/Git/IGitService.csにメソッド追加: Task<IEnumerable<WorktreeInfo>> ListWorktreesAsync(); wt.cli/Services/Git/GitService.csに実装: public async Task<IEnumerable<WorktreeInfo>> ListWorktreesAsync() { var result = await _processRunner.RunAsync( \"git\", \"worktree list --porcelain\", _repositoryPath); if (result.ExitCode != 0) { throw new GitException($\"Failed to list worktrees: {result.Error}\"); } return ParseWorktreePorcelain(result.Output); } private IEnumerable<WorktreeInfo> ParseWorktreePorcelain(string output) { var worktrees = new List<WorktreeInfo>(); var lines = output.Split('\\n', StringSplitOptions.RemoveEmptyEntries); string? currentPath = null; string? currentHead = null; string? currentBranch = null; bool isDetached = false; foreach (var line in lines) { if (line.StartsWith(\"worktree \")) { // 前のworktreeを保存 if (currentPath != null && currentHead != null) { worktrees.Add(CreateWorktreeInfo( currentPath, currentHead, currentBranch, isDetached)); } // 新しいworktree開始 currentPath = line.Substring(9).Trim(); currentHead = null; currentBranch = null; isDetached = false; } else if (line.StartsWith(\"HEAD \")) { currentHead = line.Substring(5).Trim(); } else if (line.StartsWith(\"branch \")) { var branchRef = line.Substring(7).Trim(); currentBranch = branchRef.Replace(\"refs/heads/\", \"\"); } else if (line == \"detached\") { isDetached = true; } } // 最後のworktreeを保存 if (currentPath != null && currentHead != null) { worktrees.Add(CreateWorktreeInfo( currentPath, currentHead, currentBranch, isDetached)); } return worktrees; } private WorktreeInfo CreateWorktreeInfo( string path, string commitHash, string? branch, bool isDetached) { var createdAt = GetWorktreeCreationTime(path); var exists = Directory.Exists(path); return new WorktreeInfo { Path = path, Branch = branch ?? commitHash.Substring(0, Math.Min(7, commitHash.Length)), IsDetached = isDetached, CommitHash = commitHash, CreatedAt = createdAt, Exists = exists }; } private DateTime GetWorktreeCreationTime(string worktreePath) { try { // .git/worktrees/<name>/gitdir のタイムスタンプを取得 var repoPath = FindGitDirectory(); var worktreeName = Path.GetFileName(worktreePath); var gitdirPath = Path.Combine(repoPath, \"worktrees\", worktreeName, \"gitdir\"); if (File.Exists(gitdirPath)) { return File.GetCreationTime(gitdirPath); } } catch { // エラー時はデフォルト値 } return DateTime.MinValue; } テスト実行: dotnet test → 成功を確認 Phase 3: TableFormatterの実装 Step 3.1: TableFormatterのテスト作成（Red） wt.tests/Formatters/TableFormatterTests.csを作成: [Fact] public void Format_MultipleWorktrees_ReturnsFormattedTable() { // Arrange var worktrees = new List<WorktreeInfo> { new WorktreeInfo { Path = \"/path/to/main\", Branch = \"main\", IsDetached = false, CommitHash = \"abc1234567890abcdef1234567890abcdef1234\", CreatedAt = DateTime.Now, Exists = true }, new WorktreeInfo { Path = \"/path/to/feature\", Branch = \"feature\", IsDetached = false, CommitHash = \"def5678901234567890abcdef1234567890abcde\", CreatedAt = DateTime.Now.AddMinutes(-10), Exists = true } }; var formatter = new TableFormatter(); // Act var result = formatter.Format(worktrees); // Assert result.ShouldContain(\"Path\"); result.ShouldContain(\"Branch\"); result.ShouldContain(\"Status\"); result.ShouldContain(\"/path/to/main\"); result.ShouldContain(\"/path/to/feature\"); result.ShouldContain(\"main\"); result.ShouldContain(\"feature\"); } テスト実行: dotnet test → 失敗を確認 Step 3.2: TableFormatterの実装（Green） wt.cli/Formatters/TableFormatter.csを作成: namespace Kuju63.WorkTree.CommandLine.Formatters; public class TableFormatter { public string Format(IEnumerable<WorktreeInfo> worktrees) { var list = worktrees.ToList(); if (!list.Any()) { return \"No worktrees found in this repository.\"; } // 列データを準備 var paths = list.Select(w => w.Path).ToList(); var branches = list.Select(w => w.GetDisplayBranch()).ToList(); var statuses = list.Select(w => w.GetDisplayStatus()).ToList(); // 列幅を計算 var pathWidth = CalculateColumnWidth(\"Path\", paths); var branchWidth = CalculateColumnWidth(\"Branch\", branches); var statusWidth = CalculateColumnWidth(\"Status\", statuses); var widths = new[] { pathWidth, branchWidth, statusWidth }; // テーブルを構築 var sb = new StringBuilder(); sb.AppendLine(GenerateSeparator(widths, \"┌\", \"┬\", \"┐\")); sb.AppendLine(GenerateRow(new[] { \"Path\", \"Branch\", \"Status\" }, widths)); sb.AppendLine(GenerateSeparator(widths, \"├\", \"┼\", \"┤\")); for (int i = 0; i < list.Count; i++) { sb.AppendLine(GenerateRow( new[] { paths[i], branches[i], statuses[i] }, widths)); } sb.AppendLine(GenerateSeparator(widths, \"└\", \"┴\", \"┘\")); return sb.ToString().TrimEnd(); } private int CalculateColumnWidth(string header, List<string> values) { var maxContentWidth = values.Any() ? values.Max(v => v.Length) : 0; return Math.Max(header.Length, maxContentWidth); } private string GenerateSeparator(int[] widths, string left, string mid, string right) { var parts = widths.Select(w => new string('─', w + 2)); return left + string.Join(mid, parts) + right; } private string GenerateRow(string[] values, int[] widths) { var parts = values.Select((v, i) => $\" {v.PadRight(widths[i])} \"); return \"│\" + string.Join(\"│\", parts) + \"│\"; } } テスト実行: dotnet test → 成功を確認 Phase 4: ListCommandの実装 Step 4.1: ListCommandのテスト作成（Red） wt.tests/Commands/ListCommandTests.csを作成: [Fact] public async Task Handle_MultipleWorktrees_DisplaysTable() { // Arrange var mockService = new Mock<IWorktreeService>(); mockService .Setup(x => x.ListWorktreesAsync()) .ReturnsAsync(new List<WorktreeInfo> { new WorktreeInfo { Path = \"/path/to/main\", Branch = \"main\", IsDetached = false, CommitHash = \"abc1234567890abcdef1234567890abcdef1234\", CreatedAt = DateTime.Now, Exists = true } }); var command = new ListCommand(mockService.Object); var console = new TestConsole(); // Act var exitCode = await command.InvokeAsync(console); // Assert exitCode.ShouldBe(0); console.Out.ToString().ShouldContain(\"Path\"); console.Out.ToString().ShouldContain(\"main\"); } Step 4.2: ListCommandの実装（Green） wt.cli/Commands/ListCommand.csを作成: using Kuju63.WorkTree.CommandLine.Formatters; namespace Kuju63.WorkTree.CommandLine.Commands; public class ListCommand : Command { private readonly IWorktreeService _worktreeService; public ListCommand(IWorktreeService worktreeService) : base(\"list\", \"List all worktrees with their branches\") { _worktreeService = worktreeService; this.SetHandler(HandleAsync); } private async Task<int> HandleAsync() { try { var worktrees = await _worktreeService.ListWorktreesAsync(); var sortedWorktrees = worktrees .OrderByDescending(w => w.CreatedAt) .ToList(); // 警告メッセージ（存在しないworktree） foreach (var worktree in sortedWorktrees.Where(w => !w.Exists)) { Console.Error.WriteLine( $\"Warning: Worktree at '{worktree.Path}' does not exist on disk\"); } // アクティブなworktreeのみを表示 var activeWorktrees = sortedWorktrees.Where(w => w.Exists).ToList(); var formatter = new TableFormatter(); var output = formatter.Format(activeWorktrees); Console.WriteLine(output); return 0; } catch (GitException ex) { Console.Error.WriteLine($\"Error: {ex.Message}\"); return 10; } catch (Exception ex) { Console.Error.WriteLine($\"Unexpected error: {ex.Message}\"); return 99; } } } テスト実行: dotnet test → 成功を確認 Phase 5: Program.csへの統合 wt.cli/Program.csにコマンドを登録: var rootCommand = new RootCommand(\"Git worktree management tool\"); // サービスのセットアップ var gitService = new GitService(new ProcessRunner()); var worktreeService = new WorktreeService(gitService); // コマンドの追加 rootCommand.AddCommand(new CreateCommand(worktreeService)); rootCommand.AddCommand(new ListCommand(worktreeService)); // 新規追加 return await rootCommand.InvokeAsync(args); Phase 6: 統合テスト 実際のGitリポジトリでテスト: # Worktreeを作成 git worktree add ../test-wt test-branch # コマンドを実行 dotnet run --project wt.cli -- list # 期待される出力: # ┌─────────────────────┬──────────────┬────────┐ # │ Path │ Branch │ Status │ # ├─────────────────────┼──────────────┼────────┤ # │ /path/to/test-wt │ test-branch │ active │ # │ /path/to/main │ main │ active │ # └─────────────────────┴──────────────┴────────┘ # クリーンアップ git worktree remove ../test-wt Best Practices TDDサイクルの厳守 常にテストを先に書く（Red） 最小限の実装でテストをパスさせる（Green） リファクタリングでコード品質を向上（Refactor） 各サイクルでコミット テストの粒度 ユニットテスト: 個別のメソッド・クラスのテスト 統合テスト: サービス間の連携テスト E2Eテスト: 実際のGitリポジトリでのテスト コミット戦略 # Red フェーズ git add . git commit -m \"test: add tests for WorktreeInfo model\" # Green フェーズ git add . git commit -m \"feat: implement WorktreeInfo model\" # Refactor フェーズ git add . git commit -m \"refactor: improve WorktreeInfo code quality\" Troubleshooting テストが失敗する dotnet test --logger \"console;verbosity=detailed\"で詳細を確認 テストのArrange部分を確認（モックの設定等） 実装が仕様に合っているか確認 Gitコマンドが失敗する Git 2.5以上がインストールされているか確認 カレントディレクトリがGitリポジトリか確認 git worktree list --porcelainを手動実行して出力を確認 Next Steps /speckit.tasksコマンドでタスク分解 各タスクをTDDサイクルで実装 コードレビュー ドキュメント更新 Summary このクイックスタートに従うことで: TDDアプローチで品質の高いコードを実装 各フェーズでテストをパスさせながら進行 仕様書と設計ドキュメントに準拠した実装 開発を開始する準備が整いました！"
  },
  "specs/002-list-worktree-branches/research.html": {
    "href": "specs/002-list-worktree-branches/research.html",
    "title": "Research: Worktreeとブランチ情報の一覧表示 | wt",
    "summary": "Research: Worktreeとブランチ情報の一覧表示 Phase: 0 - Outline & Research Date: 2026-01-04 Feature: spec.md | plan.md Purpose このドキュメントは、worktreeとブランチ一覧表示機能を実装するための技術調査結果をまとめています。git worktree listコマンドの出力形式、ブランチ情報の取得方法、テーブル整形アプローチ、ソート方法について調査しました。 Research Tasks 1. Git Worktree List コマンドの出力形式 調査内容: git worktree listコマンドの標準出力とポーセラン出力の形式 結果: git worktree listの標準出力形式: /path/to/main-worktree abc1234 [main] /path/to/feature-worktree def5678 [feature-branch] /path/to/detached-worktree ghi9012 (detached HEAD) git worktree list --porcelainの出力形式（機械可読）: worktree /path/to/main-worktree HEAD abc1234567890abcdef branch refs/heads/main worktree /path/to/feature-worktree HEAD def5678901234567890 branch refs/heads/feature-branch worktree /path/to/detached-worktree HEAD ghi9012345678901234 detached 決定事項: git worktree list --porcelainを使用して機械可読形式で情報を取得 ポーセラン形式は安定したAPIであり、将来のGitバージョンでも互換性が保証される 各worktreeの情報は空行で区切られる 代替案: 標準出力を正規表現でパース: 却下（出力形式が変更される可能性があり不安定） .git/worktrees/ディレクトリを直接読む: 却下（Gitの内部実装に依存し、将来の変更に脆弱） 2. ブランチ情報とDetached HEAD状態の判定 調査内容: ブランチ名の取得方法とdetached HEAD状態の識別 結果: ポーセラン出力から: branch refs/heads/branch-name行が存在する場合: 通常のブランチ detached行が存在する場合: detached HEAD状態 detached HEAD時のコミットハッシュはHEAD行から取得 短縮コミットハッシュの生成: git rev-parse --short HEADコマンドで短縮形を取得（デフォルト7文字） またはHEAD行の最初の7文字を使用 決定事項: ポーセラン出力のbranch行またはdetached行で状態を判定 detached HEAD時はHEAD行のコミットハッシュの最初の7文字を使用 フォーマット: abc1234 (detached) 3. Worktreeの作成日時取得方法 調査内容: worktreeを作成日時順（新しい順）でソートするための情報取得 結果: オプション1: .git/worktrees/<name>/gitdirファイルのタイムスタンプ 各worktreeには.git/worktrees/<worktree-name>/ディレクトリが作成される gitdirファイルの作成日時 = worktreeの作成日時 クロスプラットフォームで利用可能（System.IO.FileInfo.CreationTime） オプション2: git reflogを使用 worktree作成時のreflogエントリを検索 より正確だが、パフォーマンスが低く、reflogが削除されている可能性がある 決定事項: オプション1を採用: ファイルシステムのタイムスタンプを使用 .git/worktrees/ディレクトリ内の各worktreeサブディレクトリのgitdirファイルの作成日時を取得 クロスプラットフォームで動作し、パフォーマンスが良い 理由: シンプルで高速 依存関係なし（標準ファイルシステムAPI） Gitの内部実装への最小限の依存 4. テーブル整形アプローチ 調査内容: C#でテーブル形式の出力を生成する方法 結果: オプション1: 標準ライブラリで自作 列幅の動的計算 罫線文字（Unicode Box Drawing）を使用 依存関係ゼロ オプション2: ConsoleTables NuGetパッケージ 軽量なテーブル整形ライブラリ MIT ライセンス 追加の依存関係 オプション3: Spectre.Console 高機能なコンソールUIライブラリ テーブル、色、プログレスバー等をサポート 比較的大きな依存関係 決定事項: オプション1を採用: 標準ライブラリで自作 TableFormatterユーティリティクラスを実装 憲章V（最小限の依存関係）に準拠 実装アプローチ: ┌─────────────────────┬──────────────────┬───────────┐ │ Path │ Branch │ Status │ ├─────────────────────┼──────────────────┼───────────┤ │ /path/to/main │ main │ active │ │ /path/to/feature │ feature-branch │ active │ │ /path/to/detached │ abc1234 (detached)│ active │ └─────────────────────┴──────────────────┴───────────┘ 各列の最大幅を計算 Unicode Box Drawing文字を使用（U+2500系） 左揃え/右揃えのサポート 5. エラーハンドリング 調査内容: 存在しないworktreeや破損したworktreeの検出 結果: ポーセラン出力には存在しないworktreeも含まれる可能性あり: ファイルシステムでworktreeパスが削除された場合 git worktree pruneを実行していない場合 決定事項: 各worktreeパスの存在をDirectory.Exists()で確認 存在しない場合は警告メッセージを出力: Warning: Worktree at '/path/to/missing' does not exist on disk 警告後も処理を継続し、他のworktreeを表示（FR-008） 実装方法: if (!Directory.Exists(worktreePath)) { Console.WriteLine($\"Warning: Worktree at '{worktreePath}' does not exist on disk\"); continue; } Technology Stack Confirmation Component Technology Justification CLI Framework System.CommandLine 2.0.1 既存プロジェクトで使用中、標準的なCLIフレームワーク Git実行 System.Diagnostics.Process 標準ライブラリ、既存実装を再利用 パス操作 System.IO.Abstractions 22.1.0 既存プロジェクトで使用中、テスト可能な抽象化 テーブル整形 カスタム実装 依存関係ゼロ、要件に最適化 日時処理 System.IO.FileInfo 標準ライブラリ、クロスプラットフォーム Best Practices Git Worktree操作 --porcelainフラグを常に使用して機械可読出力を取得 エラー出力（stderr）を捕捉してユーザーに提示 Git 2.5以上の存在を前提（既存機能と同じ） パフォーマンス git worktree listは1回のみ実行 ファイルシステムアクセスは必要最小限 大量のworktree（100個）でも1秒以内に表示完了 クロスプラットフォーム パスセパレーターはPath.DirectorySeparatorCharを使用 Unicode Box Drawing文字はUTF-8コンソールで正しく表示される前提 タイムゾーン処理はDateTimeKind.Localを使用 Integration Patterns 既存コードとの統合 GitServiceの拡張: public interface IGitService { // 既存メソッド Task<ProcessResult> CreateWorktreeAsync(...); // 新規メソッド Task<IEnumerable<WorktreeInfo>> ListWorktreesAsync(); } 新しいモデル: public class WorktreeInfo { public string Path { get; set; } public string Branch { get; set; } public bool IsDetached { get; set; } public string CommitHash { get; set; } public DateTime CreatedAt { get; set; } } コマンド実装: public class ListCommand : Command { // System.CommandLineパターンに従う // ハンドラーでWorktreeServiceを呼び出し // TableFormatterで整形して出力 } Unknowns Resolved すべての主要な技術的不明点が解決されました： Unknown Resolution Git出力のパース方法 --porcelainフラグで機械可読形式を使用 作成日時の取得 .git/worktrees/<name>/gitdirのファイルタイムスタンプ テーブル整形 カスタムTableFormatterを実装（依存関係なし） Detached HEAD表示 コミットハッシュの最初の7文字 + \"(detached)\" エラーハンドリング Directory.Exists()で確認、警告後も継続 Next Steps Phase 1に進む準備が整いました： data-model.md: WorktreeInfo、BranchInfoモデルの詳細設計 contracts/cli-interface.md: CLIコマンド仕様（引数、オプション、出力形式） quickstart.md: 開発者向けクイックスタートガイド"
  },
  "specs/002-list-worktree-branches/spec.html": {
    "href": "specs/002-list-worktree-branches/spec.html",
    "title": "機能仕様書: Worktreeとブランチ情報の一覧表示 | wt",
    "summary": "機能仕様書: Worktreeとブランチ情報の一覧表示 フィーチャーブランチ: 002-list-worktree-branches 作成日: 2026-01-04 ステータス: Draft 入力: ユーザー説明: \"ユーザーがworktreeに追加されているブランチを把握するためにworktreeとブランチの一覧を表示することができる。\" 明確化事項 セッション 2026-01-04 Q: P3ユーザーストーリー3で、どの代替出力フォーマット（JSON、CSV等）をサポートすべきか? → A: 初期リリースでは代替フォーマットは未サポート（P3は将来機能に延期） Q: detached HEAD状態のworktreeをどのように表示すべきか? → A: 短縮コミットハッシュ + \"(detached)\" ラベルを表示（例: \"abc1234 (detached)\"） Q: worktreeリストのデフォルトソート順序は? → A: 作成日時順（新しい順） Q: ディスク上に存在しないworktreeをどのように扱うべきか? → A: 警告を表示してその項目をスキップし、他の有効なworktreeの表示を継続 Q: \"人間が読みやすい\"出力（FR-003）には具体的にどのフォーマットを使用すべきか? → A: パス、ブランチ、ステータスの列を持つテーブル形式 ユーザーシナリオとテスト (必須) ユーザーストーリー1 - すべてのworktreeとブランチを表示 (優先度: P1) 開発者は、作成されたすべてのworktreeと各worktreeでチェックアウトされているブランチの概要を確認する必要がある。これにより、worktreeを切り替えることなく、複数の作業コンテキストを管理できる。 この優先度の理由: これは機能のコア機能である - worktreeとブランチを表示する能力は、この機能の目的の基礎となる。 独立テスト: すべてのworktreeと現在のブランチを1つのビューにリストするコマンドを実行することでテスト可能。 受入シナリオ: 前提 開発者が異なるブランチをチェックアウトした複数のworktreeを作成している、実行 リストコマンドを実行する、結果 すべてのworktreeとそれに対応するブランチ名を示す構造化された出力が表示される 前提 ブランチがチェックアウトされたworktreeが存在する、実行 リストコマンドを実行する、結果 ブランチ情報がそのworktreeに明確に関連付けられて表示される 前提 worktreeが作成されていない、実行 リストコマンドを実行する、結果 worktreeが利用できないことを示す出力が表示される ユーザーストーリー2 - 人間が読みやすい形式でリストを表示 (優先度: P2) 開発者は、worktreeとブランチ情報が明確で読みやすい形式で表示されることを必要とする。この出力を使用して、現在の開発セットアップを一目で把握できる。 この優先度の理由: コマンドラインツールにとってユーザーエクスペリエンスは重要である。コア機能（P1）が動作する一方で、情報を明確に提示することで、開発者が素早く行動できるようにする。 独立テスト: 出力形式が人間が読みやすく、worktreeと関連するブランチが明確に分離されていることを検証することでテスト可能。 受入シナリオ: 前提 リストコマンドに表示するデータがある、実行 コマンドを実行する、結果 パス、ブランチ、ステータスの列を持つテーブル形式で出力が表示される 前提 複数のworktreeが存在する、実行 リストコマンドを実行する、結果 各worktreeがテーブルの別々の行として表示される ユーザーストーリー3 - 代替出力フォーマットのサポート (優先度: P3 - 将来の拡張) 開発者は、スクリプトや他のツールに適した形式でworktreeとブランチ情報をエクスポートしたい。これにより、自動化や他の開発ワークフローとの統合が可能になる。 注意: この機能は将来のリリースに延期される。初期リリースは人間が読みやすい出力のみに焦点を当てる。 この優先度の理由: 人間が読みやすい形式（P2）は典型的な対話的使用をカバーするが、代替フォーマットのサポートはパワーユーザーや自動化シナリオを可能にする。ただし、これは初期リリースにとって重要ではない。 独立テスト: 他のツールが解析できる代替フォーマットで出力が生成できることを検証することでテスト可能（将来のリリースで実装された場合）。 受入シナリオ: 前提 開発者が代替出力フォーマットフラグを指定する、実行 リストコマンドを実行する、結果 指定されたフォーマットに従って出力がフォーマットされる（将来機能） 前提 出力フォーマットが指定されている、実行 リストコマンドを実行する、結果 すべてのworktreeとブランチ情報が代替フォーマット出力に含まれる（将来機能） [必要に応じて、優先度を割り当てた追加のユーザーストーリーを追加] エッジケース worktreeは存在するがブランチがチェックアウトされていない（detached HEAD）場合はどうなるか? → 短縮コミットハッシュの後に \"(detached)\" ラベルを表示（例: \"abc1234 (detached)\"） ブランチ名に特殊文字やスペースが含まれている場合はどうなるか? ディスク上に存在しないworktreeにアクセスする場合はどうなるか? → 警告メッセージを表示してその項目をスキップし、他の有効なworktreeの表示を継続 非常に多数のworktreeがある場合はどうなるか（パフォーマンス/可読性）? 要件 (必須) 機能要件 FR-001: システムはすべてのアクティブなworktreeのリストを表示しなければならない FR-002: システムは各worktreeでチェックアウトされている現在のブランチを表示しなければならない FR-003: システムはデフォルトでパス、ブランチ、ステータスの列を持つテーブル形式で出力を表示しなければならない FR-004: システムはブランチがチェックアウトされていないworktree（detached HEAD状態）を、短縮コミットハッシュの後に \"(detached)\" ラベルを表示することで処理しなければならない FR-005: システムはユーザーがどのworktreeかを識別できるように、ブランチ情報と共にworktreeパスを表示しなければならない FR-006: ユーザーはこの機能をコマンドラインインターフェースを介して呼び出すことができなければならない FR-007: システムはworktreeを作成日順に新しい順でソートして表示しなければならない FR-008: システムはディスク上に存在しないworktreeに対して警告を表示し、残りのworktreeの処理を継続しなければならない 主要エンティティ Worktree: パス、ブランチ、状態を含むメタデータを持つGit worktreeインスタンス Branch: 名前とworktreeで現在チェックアウトされているかどうかを持つGitブランチ参照 成功基準 (必須) 測定可能な成果 SC-001: 3つ以上のworktreeでコマンドを実行する場合、ユーザーは出力を見てから5秒以内にすべてのworktreeとそのブランチを識別できる SC-002: リスト出力は人間が読みやすく、worktreeとブランチに関する情報が明確に分離されている SC-003: パスやブランチ名に特殊文字が含まれるworktreeに対して機能が正しく動作する SC-004: ユーザーは追加のヘルプドキュメントを必要とせずに、worktreeステータスを表示するワークフローを完了できる 前提条件 Gitリポジトリはすでに初期化されており、標準のGit worktreeコマンドを使用してworktreeが作成されている システムはGitにアクセスでき、git worktree listおよび関連コマンドを実行できる デフォルトの出力形式は完全性よりも人間の可読性を優先すべきである（追加のフォーマットは将来の反復で追加可能）"
  },
  "specs/002-list-worktree-branches/tasks.html": {
    "href": "specs/002-list-worktree-branches/tasks.html",
    "title": "Tasks: Worktreeとブランチ情報の一覧表示 | wt",
    "summary": "Tasks: Worktreeとブランチ情報の一覧表示 Input: Design documents from /specs/002-list-worktree-branches/ Prerequisites: plan.md, spec.md, data-model.md, contracts/cli-interface.md, research.md, quickstart.md TDD前提 このプロジェクトはTDD (Test-Driven Development)を採用しています。 各実装タスクは Red-Green-Refactorサイクル に従って実施してください Red: テストを先に書き、失敗することを確認 Green: テストが通る最小限の実装 Refactor: コード品質の向上 詳細なTDDワークフローは quickstart.md を参照してください テストタスクは実装タスクに統合されているため、個別には記載していません constitution.mdで定義されたテストカバレッジ基準（80%以上）を満たすこと Organization: Tasks are grouped by user story to enable independent implementation and testing of each story. Format: [ID] [P?] [Story] Description [P]: Can run in parallel (different files, no dependencies) [Story]: Which user story this task belongs to (US1, US2, US3) Include exact file paths in descriptions Path Conventions This is a single CLI project with the following structure: wt.cli/ - Main CLI application source wt.tests/ - Test project Phase 1: Setup (Shared Infrastructure) Purpose: Project initialization and basic structure [X] T001 Review existing project structure and ensure it matches plan.md [X] T002 Verify System.CommandLine 2.0.1 and System.IO.Abstractions 22.1.0 dependencies [X] T003 [P] Verify xUnit, Shouldly, and Moq test dependencies are configured Phase 2: Foundational (Blocking Prerequisites) Purpose: Core infrastructure that MUST be complete before ANY user story can be implemented ⚠️ CRITICAL: No user story work can begin until this phase is complete [X] T004 Create WorktreeInfo model with all properties and methods in wt.cli/Models/WorktreeInfo.cs [X] T005 [P] Create BranchInfo model (future extension placeholder) in wt.cli/Models/BranchInfo.cs [X] T006 [P] Create IOutputFormatter interface in wt.cli/Formatters/IOutputFormatter.cs [X] T007 Implement TableFormatter class in wt.cli/Formatters/TableFormatter.cs [X] T008 Extend IGitService interface to add ListWorktreesAsync method signature [X] T009 Implement GitService.ListWorktreesAsync() method to parse git worktree list --porcelain output in wt.cli/Services/Git/GitService.cs Checkpoint: Foundation ready - user story implementation can now begin Phase 3: User Story 1 - すべてのworktreeとブランチを表示 (Priority: P1) \uD83C\uDFAF MVP Goal: Display all worktrees with their checked-out branches in a structured format Independent Test: Execute the list command and verify all worktrees with their branch names are displayed Implementation for User Story 1 [X] T010 [US1] Create ListCommand class inheriting from Command in wt.cli/Commands/ListCommand.cs [X] T011 [US1] Implement ListCommand constructor with IWorktreeService dependency [X] T012 [US1] Implement ListCommand.SetHandler to call WorktreeService and format output [X] T013 [US1] Extend IWorktreeService interface to add ListWorktreesAsync method signature [X] T014 [US1] Implement WorktreeService.ListWorktreesAsync() to call GitService.ListWorktreesAsync() in wt.cli/Services/Worktree/WorktreeService.cs [X] T015 [US1] Add worktree creation time retrieval logic using .git/worktrees/<name>/gitdir file timestamp in WorktreeService [X] T016 [US1] Add worktree existence validation using Directory.Exists() in WorktreeService [X] T017 [US1] Add sorting by creation date (newest first) in WorktreeService.ListWorktreesAsync() [X] T018 [US1] Register ListCommand in Program.cs with dependency injection [X] T019 [US1] Add warning message output to stderr for missing worktrees in ListCommand handler [X] T020 [US1] Add \"No worktrees found\" message handling in ListCommand handler [X] T021 [US1] Add error handling for Git not found (exit code 1) in ListCommand handler [X] T022 [US1] Add error handling for not a Git repository (exit code 2) in ListCommand handler [X] T023 [US1] Add error handling for Git command failure (exit code 10) in ListCommand handler Checkpoint: At this point, User Story 1 should be fully functional - wt list command displays all worktrees with branches Phase 4: User Story 2 - 人間が読みやすい形式でリストを表示 (Priority: P2) Goal: Display worktree and branch information in a clear, human-readable table format Independent Test: Verify output is formatted as a table with Path, Branch, and Status columns Implementation for User Story 2 [X] T024 [US2] Implement TableFormatter.Format() method to calculate column widths in wt.cli/Formatters/TableFormatter.cs [X] T025 [US2] Implement TableFormatter header row generation with Unicode box drawing characters (┌─┬─┐) [X] T026 [US2] Implement TableFormatter separator line generation (├─┼─┤) [X] T027 [US2] Implement TableFormatter data row generation with proper column alignment [X] T028 [US2] Implement TableFormatter footer line generation (└─┴─┘) [X] T029 [US2] Update ListCommand to use TableFormatter.Format() for output [X] T030 [US2] Ensure table displays Path, Branch (using GetDisplayBranch()), and Status (using GetDisplayStatus()) columns [X] T031 [US2] Verify table output handles long paths and branch names correctly with dynamic column widths Checkpoint: At this point, User Stories 1 AND 2 should both work - output is in a clear table format Phase 5: User Story 3 - 代替出力フォーマットのサポート (Priority: P3) Goal: Support alternative output formats (JSON, CSV) for scripting and automation Note: This feature is deferred to future releases per specification Implementation for User Story 3 (Future Release) [ ] T032 [US3] Add --format option to ListCommand with values: table, json, csv [ ] T033 [US3] Create JsonFormatter implementing IOutputFormatter in wt.cli/Formatters/JsonFormatter.cs [ ] T034 [US3] Create CsvFormatter implementing IOutputFormatter in wt.cli/Formatters/CsvFormatter.cs [ ] T035 [US3] Update ListCommand to select formatter based on --format option [ ] T036 [US3] Add JSON serialization support to WorktreeInfo model with JsonPropertyName attributes [ ] T037 [US3] Implement JsonFormatter.Format() to output JSON array [ ] T038 [US3] Implement CsvFormatter.Format() to output CSV with header row Checkpoint: All user stories completed - alternative formats supported Phase 6: Polish & Cross-Cutting Concerns Purpose: Improvements that affect multiple user stories [X] T039 [P] Update README.md with wt list command documentation [X] T040 [P] Add usage examples to getting-started.md documentation [ ] T041 [P] Add ADR for table formatting implementation decision (no external dependencies) [ ] T042 [P] Add ADR for worktree creation time retrieval approach (filesystem timestamp) [X] T043 Code review and refactoring for clarity and maintainability [X] T044 Verify all exit codes are correctly implemented (0, 1, 2, 10, 99) [X] T045 Verify cross-platform compatibility (Windows path separators, Unicode support) [ ] T046 Performance testing with 100 worktrees (should complete within 1 second) [ ] T047 Run quickstart.md validation following TDD workflow [ ] T048 [P] Update docfx documentation with API documentation for new classes Dependencies & Execution Order Phase Dependencies Setup (Phase 1): No dependencies - can start immediately Foundational (Phase 2): Depends on Setup completion - BLOCKS all user stories User Story 1 (Phase 3): Depends on Foundational (Phase 2) completion User Story 2 (Phase 4): Depends on User Story 1 (Phase 3) completion - builds on list functionality User Story 3 (Phase 5): Deferred to future release - not blocking current implementation Polish (Phase 6): Depends on User Stories 1 and 2 being complete User Story Dependencies User Story 1 (P1): Can start after Foundational (Phase 2) - No dependencies on other stories User Story 2 (P2): Depends on User Story 1 - enhances the display format of US1 output User Story 3 (P3): Deferred to future release - no implementation required for initial MVP Within Each User Story User Story 1 (Display all worktrees): Create ListCommand and WorktreeService integration (T010-T014) Add time retrieval and validation (T015-T017) Register command and add error handling (T018-T023) User Story 2 (Human-readable table format): Implement TableFormatter core logic (T024-T028) Integrate formatter with ListCommand (T029-T031) Parallel Opportunities Within Setup (Phase 1): T001, T002, T003 can run in parallel Within Foundational (Phase 2): T005, T006 can run in parallel after T004 completes Within Polish (Phase 6): T039, T040, T041, T042, T048 can all run in parallel Parallel Example: Foundational Phase # After T004 (WorktreeInfo model) is complete, launch these in parallel: Task T005: \"Create BranchInfo model in wt.cli/Models/BranchInfo.cs\" Task T006: \"Create IOutputFormatter interface in wt.cli/Formatters/IOutputFormatter.cs\" Parallel Example: Polish Phase # All documentation tasks can run in parallel: Task T039: \"Update README.md with wt list command documentation\" Task T040: \"Add usage examples to getting-started.md documentation\" Task T041: \"Add ADR for table formatting implementation decision\" Task T042: \"Add ADR for worktree creation time retrieval approach\" Task T048: \"Update docfx documentation with API documentation\" Implementation Strategy MVP First (User Story 1 + User Story 2) Complete Phase 1: Setup Complete Phase 2: Foundational (CRITICAL - blocks all stories) Complete Phase 3: User Story 1 (basic listing functionality) Complete Phase 4: User Story 2 (table formatting) STOP and VALIDATE: Test wt list command with multiple worktrees Deploy/demo MVP Incremental Delivery Setup + Foundational → Foundation ready Add User Story 1 → Basic listing works → Test independently Add User Story 2 → Beautiful table format → Test independently → Deploy/Demo (MVP!) User Story 3 deferred to future release Testing Strategy While test tasks are not included per specification, follow TDD principles from quickstart.md: Write test for each component (Red) Implement minimum code to pass test (Green) Refactor for quality (Refactor) Verify manually with real Git repositories Notes [P] tasks = different files, no dependencies, can run in parallel [Story] label maps task to specific user story for traceability Each user story should be independently testable User Story 3 (P3) is deferred to future release - no implementation required for MVP Follow TDD workflow from quickstart.md: Red → Green → Refactor Commit after each task or logical group Stop at checkpoints to validate story independently All file paths are relative to repository root Summary Total Tasks: 48 (excluding deferred User Story 3 implementation) MVP Tasks: T001-T031 (31 tasks for User Stories 1 and 2) User Story 1 Tasks: 14 tasks (T010-T023) User Story 2 Tasks: 8 tasks (T024-T031) Deferred Tasks: 7 tasks (T032-T038) for User Story 3 Parallel Opportunities: 8 tasks can be parallelized (marked with [P]) Suggested MVP Scope: User Stories 1 and 2 (basic listing + table formatting) Format Validation: ✅ All tasks follow checklist format with checkbox, ID, optional labels, and file paths"
  },
  "specs/003-automated-release-pipeline/checklists/requirements.html": {
    "href": "specs/003-automated-release-pipeline/checklists/requirements.html",
    "title": "Specification Quality Checklist: Automated Binary Release Pipeline | wt",
    "summary": "Specification Quality Checklist: Automated Binary Release Pipeline Purpose: Validate specification completeness and quality before proceeding to planning Created: 2026-01-04 Feature: spec.md Content Quality [x] No implementation details (languages, frameworks, APIs) [x] Focused on user value and business needs [x] Written for non-technical stakeholders [x] All mandatory sections completed Requirement Completeness [x] No [NEEDS CLARIFICATION] markers remain [x] Requirements are testable and unambiguous [x] Success criteria are measurable [x] Success criteria are technology-agnostic (no implementation details) [x] All acceptance scenarios are defined [x] Edge cases are identified [x] Scope is clearly bounded [x] Dependencies and assumptions identified Feature Readiness [x] All functional requirements have clear acceptance criteria [x] User scenarios cover primary flows [x] Feature meets measurable outcomes defined in Success Criteria [x] No implementation details leak into specification Notes All validation items passed successfully Specification is ready for /speckit.clarify or /speckit.plan Added Assumptions and Dependencies section with 7 assumptions and 7 dependencies identified"
  },
  "specs/003-automated-release-pipeline/contracts/build-workflow.html": {
    "href": "specs/003-automated-release-pipeline/contracts/build-workflow.html",
    "title": "Contract: Build Workflow | wt",
    "summary": "Contract: Build Workflow Workflow: .github/workflows/build.yml Feature: 003-automated-release-pipeline Date: 2026-01-05 概要 マルチプラットフォームバイナリのビルドを並列実行するワークフロー。 トリガー Type: workflow_call (再利用可能ワークフロー) Inputs: パラメータ 型 必須 説明 例 version string ✅ ビルドするバージョンタグ v1.2.3 Outputs: パラメータ 型 説明 例 build-status string ビルドステータスサマリー success, partial-failure, failure ジョブ定義 Job: build Purpose: 各プラットフォームのバイナリをビルドする Strategy: strategy: fail-fast: false # OPTIONALプラットフォームの失敗を許容 max-parallel: 4 # 全プラットフォームを並列ビルド matrix: include: - os: windows-latest platform: windows arch: x64 rid: win-x64 mandatory: true script: build-windows.sh artifact-name: wt-${{ inputs.version }}-windows-x64.exe - os: ubuntu-latest platform: linux arch: x64 rid: linux-x64 mandatory: true script: build-linux-x64.sh artifact-name: wt-${{ inputs.version }}-linux-x64 - os: ubuntu-latest platform: linux arch: arm rid: linux-arm mandatory: false script: build-linux-arm.sh artifact-name: wt-${{ inputs.version }}-linux-arm - os: macos-latest platform: macos arch: arm64 rid: osx-arm64 mandatory: true script: build-macos-arm64.sh artifact-name: wt-${{ inputs.version }}-macos-arm64 ステップ: Checkout repository Action: actions/checkout@v4 Purpose: リポジトリコードを取得 Setup .NET Action: actions/setup-dotnet@v4 Version: 10.0.x (最新の.NET 10) Purpose: .NET SDKをインストール Restore dependencies Command: dotnet restore wt.sln Purpose: NuGetパッケージを復元 Build {platform}-{arch} Script: .github/scripts/{matrix.script} Args: version, rid Continue on error: !matrix.mandatory (OPTIONALプラットフォームのみ) Purpose: プラットフォーム固有のバイナリをビルド Check build result Condition: always() Purpose: MANDATORYプラットフォームの失敗を検出 Exit code: 1 if mandatory platform failed 0 if optional platform failed (warning only) Upload build artifact Action: actions/upload-artifact@v4 Condition: steps.build.outcome == 'success' Artifact name: binary-{platform}-{arch} Path: release-assets/{artifact-name} Purpose: ビルド成果物をアップロード プラットフォームマトリックス MANDATORYプラットフォーム (失敗でリリースブロック) Platform Arch OS RID Script Windows x64 windows-latest win-x64 build-windows.sh Linux x64 ubuntu-latest linux-x64 build-linux-x64.sh macOS arm64 macos-latest osx-arm64 build-macos-arm64.sh OPTIONALプラットフォーム (失敗でも警告のみ) Platform Arch OS RID Script Linux arm ubuntu-latest linux-arm build-linux-arm.sh ビルドスクリプト契約 各ビルドスクリプト (.github/scripts/build-*.sh) は以下の契約に従う: 引数: $1: バージョンタグ (例: v1.2.3) $2: Runtime Identifier (例: linux-x64) 出力: バイナリファイル: release-assets/wt-{version}-{platform}-{arch}[.exe] Exit code: 0: ビルド成功 1: ビルド失敗 実装例 (build-linux-x64.sh): #!/usr/bin/env bash set -euo pipefail VERSION=$1 RID=$2 echo \"Building for Linux x64...\" mkdir -p release-assets dotnet publish wt.cli/wt.cli.csproj \\ --configuration Release \\ --runtime \"$RID\" \\ --self-contained true \\ -p:PublishSingleFile=true \\ -p:IncludeNativeLibrariesForSelfExtract=true \\ -p:Version=\"${VERSION#v}\" \\ --output release-assets/ # Rename binary mv release-assets/wt release-assets/wt-${VERSION}-linux-x64 echo \"✅ Build completed: release-assets/wt-${VERSION}-linux-x64\" 成果物 (Artifacts) ビルド成功後、以下のアーティファクトがアップロードされます: Artifact Name Platform Files Size (approx) binary-windows-x64 Windows x64 wt.exe 15-20 MB binary-linux-x64 Linux x64 wt 15-20 MB binary-linux-arm Linux ARM wt 12-18 MB binary-macos-arm64 macOS ARM64 wt 15-20 MB Retention: 7日間 (GitHub Actionsデフォルト) エラーハンドリング MANDATORYプラットフォームの失敗 - name: Check build result if: always() shell: bash run: | if [ \"${{ steps.build.outcome }}\" == \"failure\" ]; then if [ \"${{ matrix.mandatory }}\" == \"true\" ]; then echo \"::error::MANDATORY platform ${{ matrix.platform }}-${{ matrix.arch }} build failed!\" exit 1 fi fi 動作: MANDATORYプラットフォームが失敗 → ジョブ全体が失敗 OPTIONALプラットフォームが失敗 → 警告のみ、他のプラットフォームは続行 OPTIONALプラットフォームの失敗 - name: Build ${{ matrix.platform }}-${{ matrix.arch }} continue-on-error: ${{ !matrix.mandatory }} 動作: Linux ARMビルドが失敗 → 警告ログ、アーティファクトなし、他は続行 性能要件 指標 目標 許容範囲 単一プラットフォームビルド時間 < 10分 < 15分 全プラットフォームビルド時間 (並列) < 15分 < 20分 タイムアウト 20分/プラットフォーム - テスト ローカルビルドテスト # Linux x64ビルド .github/scripts/build-linux-x64.sh \"v0.1.0-test\" \"linux-x64\" # 期待される結果: # - release-assets/wt-v0.1.0-test-linux-x64 が生成される # - Exit code: 0 ワークフローテスト # ワークフローを手動実行 gh workflow run build.yml --ref main gh run watch 依存関係 必要なツール: .NET SDK 10.0.x Bash (ビルドスクリプト実行用) Git (リポジトリチェックアウト用) GitHub Actions: actions/checkout@v4 actions/setup-dotnet@v4 actions/upload-artifact@v4 セキュリティ 権限: permissions: contents: read # リポジトリコードの読み取り シークレット: なし (ビルドのみ、署名やアップロードは不要) リファレンス ワークフローファイル: .github/workflows/build.yml ビルドスクリプト: .github/scripts/ データモデル: data-model.md タスク: tasks.md"
  },
  "specs/003-automated-release-pipeline/contracts/release-workflow.html": {
    "href": "specs/003-automated-release-pipeline/contracts/release-workflow.html",
    "title": "Contract: Release Workflow | wt",
    "summary": "Contract: Release Workflow Workflow: .github/workflows/release.yml Feature: 003-automated-release-pipeline Date: 2026-01-05 概要 mainブランチへのマージをトリガーとして、バージョン計算、ビルド、リリース作成を自動実行するワークフロー。 トリガー Push to main on: push: branches: - main 動作: mainブランチへのプッシュで自動実行 Manual dispatch (手動実行) on: workflow_dispatch: inputs: force-version: description: 'Force specific version (e.g., v1.0.0)' required: false type: string 動作: GitHub Actions UIから手動実行可能、バージョンを強制指定可能 ジョブ定義 Job 1: calculate-version Purpose: 次のバージョン番号を計算する Outputs: 出力 型 説明 例 version string 新しいバージョンタグ v1.2.3 previous-version string 前回のバージョンタグ v1.2.2 should-release boolean リリース作成が必要か true, false ステップ: Checkout repository (fetch-depth: 0) すべてのGit履歴を取得 (バージョン計算に必要) Calculate next version Action: paulhatch/semantic-version@a8f8f59fd7f0625188492e945240f12d7ad2dca3 (v5.4.0) 条件: force-versionが指定されていない場合 パターン: MAJOR: (BREAKING CHANGE:|BREAKING:) MINOR: feat: PATCH: (デフォルト) Use forced version 条件: force-versionが指定されている場合 動作: 指定されたバージョンを使用 Check if release is needed 条件: バージョンが変更されている場合のみ should-release=true 動作: バージョン変更なし → リリーススキップ バージョン計算ロジック: Input: Commits since last tag Logic: if any commit contains \"BREAKING CHANGE:\" → MAJOR++ elif any commit starts with \"feat:\" → MINOR++ elif any commit starts with \"fix:\" → PATCH++ else → No version change Output: New version tag (e.g., v1.3.0) Job 2: build Purpose: 全プラットフォームのバイナリをビルドする Dependencies: calculate-version Condition: needs.calculate-version.outputs.should-release == 'true' Implementation: workflow_call to .github/workflows/build.yml Inputs: version: ${{ needs.calculate-version.outputs.version }} 詳細: build-workflow.md を参照 Job 3: create-release Purpose: GitHub Releaseを作成し、アセットをアップロードする Dependencies: calculate-version, build Timeout: 25分 (SLA: 30分, 5分バッファ) ステップ: Checkout repository (fetch-depth: 0) リリースノート生成のため全履歴を取得 Download build artifacts Action: actions/download-artifact@v4 Path: artifacts/ 動作: ビルドジョブの全アーティファクトをダウンロード Organize binaries スクリプト: Bashスクリプト (inline) 動作: バイナリを release-assets/ ディレクトリに整理 ファイル名変更: wt-{version}-{platform}-{arch}[.exe] Generate checksums スクリプト: .github/scripts/generate-checksums.sh 入力: release-assets/ 出力: release-assets/SHA256SUMS Generate SBOM Action: anchore/sbom-action@61119d458adab75f756bc0b9e4bde25725f86a7a (v0.17.2) 入力: ./wt.cli 出力: release-assets/wt-{version}-sbom.json フォーマット: CycloneDX JSON Sign artifacts スクリプト: .github/scripts/sign-artifacts.sh 入力: release-assets/ 出力: release-assets/wt-{version}-sbom.json.asc release-assets/SHA256SUMS.asc シークレット: GPG_PRIVATE_KEY, GPG_PASSPHRASE Generate release notes スクリプト: .github/scripts/generate-release-notes.sh 引数: $1: 前回バージョン $2: 新バージョン 出力: release-notes.md Create Git tag コマンド: git tag -a {version} -m \"Release {version}\" プッシュ: git push origin {version} Create GitHub Release Action: softprops/action-gh-release@a06a81a03ee405af7f2048a818ed3f03bbf83c7b (v2) Tag: ${{ needs.calculate-version.outputs.version }} Body: release-notes.md Files: release-assets/wt-*-windows-*.exe release-assets/wt-*-linux-* release-assets/wt-*-macos-* release-assets/wt-*-sbom.json release-assets/wt-*-sbom.json.asc release-assets/SHA256SUMS release-assets/SHA256SUMS.asc Release summary 動作: GitHub Actions Step Summaryにリリース情報を表示 リリースアセット ファイル一覧 File Pattern Description Size (approx) wt-v{version}-windows-x64.exe Windows x64 binary 15-20 MB wt-v{version}-linux-x64 Linux x64 binary 15-20 MB wt-v{version}-linux-arm Linux ARM binary (optional) 12-18 MB wt-v{version}-macos-arm64 macOS ARM64 binary 15-20 MB wt-v{version}-sbom.json CycloneDX SBOM 200-500 KB wt-v{version}-sbom.json.asc SBOM GPG signature 1-5 KB SHA256SUMS Checksums for all binaries 1-5 KB SHA256SUMS.asc Checksums GPG signature 1-5 KB Total size: 45-80 MB (within GitHub Release limits) リリースノート形式 ## Features - add support for multiple worktrees (#123) - implement config file parsing (#124) ## Bug Fixes - handle special characters in branch names (#125) - fix path resolution on Windows (#126) ## Breaking Changes - change CLI argument format to kebab-case Migration guide: docs/migration/v2.0.md ## Contributors - @user1 - @user2 生成ロジック: 前回タグから現在までのコミットを取得 Conventional Commitsでパース タイプ別にグループ化 (feat:, fix:, BREAKING CHANGE:) Markdownフォーマットで出力 バージョン計算例 例1: MINOR bump (feat:) Last tag: v1.2.3 Commits since last tag: - feat: add new feature - docs: update README - chore: update dependencies Result: v1.3.0 (MINOR bump) 例2: PATCH bump (fix:) Last tag: v1.3.0 Commits since last tag: - fix: resolve critical bug - test: add unit tests Result: v1.3.1 (PATCH bump) 例3: MAJOR bump (BREAKING CHANGE:) Last tag: v1.3.1 Commits since last tag: - feat: change API format BREAKING CHANGE: All CLI arguments now use kebab-case. Result: v2.0.0 (MAJOR bump) 例4: No version change Last tag: v2.0.0 Commits since last tag: - docs: update documentation - chore: update CI configuration Result: No release (version unchanged) エラーハンドリング ビルド失敗 MANDATORY プラットフォーム失敗: リリース全体が中止 OPTIONAL プラットフォーム失敗: 警告のみ、リリース続行 SBOM生成失敗 動作: リリース中止 (セキュリティクリティカル) エラーコード: 1 署名生成失敗 動作: リリース中止 (セキュリティクリティカル) エラーコード: 1 タイムアウト 制限: 25分 動作: ワークフロー強制終了、リリース未作成 ログ: タイムアウトエラーメッセージ 性能要件 (SC-003) フェーズ 目標時間 許容時間 SLA バージョン計算 < 1分 < 2分 - ビルド (並列) < 15分 < 20分 - リリース作成 < 10分 < 15分 - 合計 < 20分 < 30分 30分 シークレット Name Purpose Format GITHUB_TOKEN GitHub Release作成 自動生成 (actions権限) GPG_PRIVATE_KEY デジタル署名 ASCII-armored GPG key GPG_PASSPHRASE GPG鍵パスフレーズ Plain text 権限 permissions: contents: write # Git tag作成, Release作成 packages: write # (将来のパッケージ公開用) テスト シナリオ1: feat: コミット (MINOR bump) git checkout -b test/feat echo \"test\" >> README.md git add README.md git commit -m \"feat: add new feature\" git push origin test/feat gh pr create --title \"feat: new feature\" --body \"Test\" gh pr merge --squash # 期待される結果: # - バージョン: v1.2.0 → v1.3.0 # - リリースノート: \"Features\" セクションに含まれる # - リリース時間: < 30分 シナリオ2: fix: コミット (PATCH bump) git checkout -b test/fix echo \"fix\" >> README.md git add README.md git commit -m \"fix: resolve bug\" git push origin test/fix gh pr create --title \"fix: bug fix\" --body \"Test\" gh pr merge --squash # 期待される結果: # - バージョン: v1.3.0 → v1.3.1 # - リリースノート: \"Bug Fixes\" セクションに含まれる シナリオ3: BREAKING CHANGE: (MAJOR bump) git checkout -b test/breaking echo \"breaking\" >> README.md git add README.md git commit -m \"feat: breaking change BREAKING CHANGE: Change API format\" git push origin test/breaking gh pr create --title \"feat: breaking change\" --body \"Test\" gh pr merge --squash # 期待される結果: # - バージョン: v1.3.1 → v2.0.0 # - リリースノート: \"Breaking Changes\" セクションに強調表示 リファレンス ワークフローファイル: .github/workflows/release.yml ビルドワークフロー契約: build-workflow.md データモデル: data-model.md タスク: tasks.md ADR 0003: セマンティックバージョニング ADR 0004: タイムアウトとSLA"
  },
  "specs/003-automated-release-pipeline/contracts/test-workflow.html": {
    "href": "specs/003-automated-release-pipeline/contracts/test-workflow.html",
    "title": "Contract: Test Workflow | wt",
    "summary": "Contract: Test Workflow Workflow: .github/workflows/test.yml Feature: 003-automated-release-pipeline Date: 2026-01-05 概要 全ブランチでテストを実行し、コードカバレッジをCodacyに報告するワークフロー。 トリガー Push to branches on: push: branches: - main - 'feature/**' - 'fix/**' 動作: main, feature, fix ブランチへのプッシュで自動実行 Pull request to main on: pull_request: branches: - main 動作: mainブランチへのPRで自動実行 ジョブ定義 Job: test Purpose: テストを実行し、カバレッジを報告する Runner: ubuntu-latest ステップ: Checkout repository Action: actions/checkout@v4 Purpose: テスト実行のためリポジトリコードを取得 Setup .NET Action: actions/setup-dotnet@v4 Version: 10.0.x Purpose: .NET SDKをインストール Restore dependencies Command: dotnet restore wt.sln Purpose: NuGetパッケージを復元 Build solution Command: dotnet build wt.sln --configuration Release --no-restore Purpose: Releaseモードでビルド Run tests with coverage Command: dotnet test wt.sln \\ --configuration Release \\ --no-build \\ --verbosity normal \\ --collect:\"XPlat Code Coverage\" \\ --results-directory ./coverage \\ --logger \"trx;LogFileName=test-results.trx\" Purpose: テストを実行し、カバレッジを収集 Find coverage file Command: find ./coverage -name \"coverage.cobertura.xml\" Output: coverage-file (カバレッジファイルのパス) Purpose: カバレッジファイルの場所を特定 Generate coverage report Tool: reportgenerator Input: coverage.cobertura.xml Output: ./coverage/report/ (HTML + TextSummary) Purpose: 人間が読めるカバレッジレポートを生成 Upload coverage to Codacy Action: codacy/codacy-coverage-reporter-action@a38818475bb21847788496e9f0fddaa4e84955ba Input: coverage.cobertura.xml Token: ${{ secrets.CODACY_PROJECT_TOKEN }} Continue on error: true (Codacy失敗でもテストは続行) Purpose: カバレッジをCodacyに報告 Upload test results Action: actions/upload-artifact@v4 Condition: always() Files: coverage/ **/TestResults/**/*.trx Retention: 7日 Purpose: テスト結果とカバレッジをアーティファクトとして保存 Publish test results Action: dorny/test-reporter@bdab7eb6dfb6be17ac3d72352f67e559a72c8db1 (v2) Condition: always() Reporter: dotnet-trx Fail on error: true (テスト失敗でジョブ失敗) Purpose: PRにテスト結果を表示 テスト要件 テストタイプ Type Required Tool Location Unit Tests ✅ Yes xUnit wt.tests/ Integration Tests ⚠️ Recommended xUnit wt.tests/Integration/ Coverage Collection ✅ Yes coverlet (自動) カバレッジ目標 Metric Target Enforcement Line Coverage 80% ⚠️ Warning (not blocking) Branch Coverage 70% ⚠️ Warning (not blocking) Method Coverage 75% ⚠️ Warning (not blocking) 注意: カバレッジ目標は aspirational goal であり、マージをブロックしません (ADR 0005参照)。 品質ゲート (Quality Gates) ブロッキング (Merge blocked) テスト失敗 → ❌ マージブロック 条件: dotnet test が exit code 1 を返す 理由: 回帰防止 非ブロッキング (Warning only) カバレッジ低下 → ⚠️ 警告のみ 条件: カバレッジが前回より低下 理由: 開発速度とのバランス Codacyアップロード失敗 → ⚠️ 警告のみ 条件: Codacy APIエラー 理由: 外部サービスの一時的障害を許容 カバレッジレポート形式 Cobertura XML <?xml version=\"1.0\"?> <coverage line-rate=\"0.85\" branch-rate=\"0.72\"> <packages> <package name=\"wt.cli\" line-rate=\"0.85\"> <classes> <class name=\"Program\" line-rate=\"1.0\"> <lines> <line number=\"10\" hits=\"5\" branch=\"false\"/> <line number=\"11\" hits=\"5\" branch=\"true\" condition-coverage=\"75% (3/4)\"/> </lines> </class> </classes> </package> </packages> </coverage> GitHub Step Summary ### \uD83D\uDCCA Coverage Summary Summary Generated on: 2026-01-05 12:00:00 Line coverage: 85.2% Branch coverage: 72.1% Method coverage: 78.5% Assemblies: 2 Classes: 25 Files: 30 Covered lines: 1234 Uncovered lines: 215 Coverable lines: 1449 Codacy連携 プロジェクト設定 Organization: kuju63 Repository: wt Token: ${{ secrets.CODACY_PROJECT_TOKEN }} アップロードフォーマット Format: Cobertura XML Language: C# Coverage Tool: coverlet (via dotnet test --collect) Codacyコメント例 (PR) ## Codacy Coverage Report Coverage: 85.2% (+2.5%) Changes by file: - wt.cli/Program.cs: 95% (+5%) - wt.cli/Services/GitService.cs: 80% (-3%) Overall: ✅ Coverage increased エラーハンドリング テスト失敗 Error: Test failed with exit code 1 Failed tests: - wt.tests.GitServiceTests.CreateWorktree_ShouldReturnSuccess - wt.tests.EditorServiceTests.OpenEditor_ShouldLaunchVSCode 動作: ジョブ失敗、PRマージブロック カバレッジファイル未検出 Warning: Coverage file not found 動作: カバレッジアップロードスキップ、テストは続行 Codacyアップロード失敗 Warning: Failed to upload coverage to Codacy Error: Project token is invalid 動作: 警告ログ、テストは続行 (continue-on-error: true) 性能要件 Metric Target Acceptable Test execution time < 5分 < 10分 Coverage collection overhead < 20% < 30% Total workflow time < 8分 < 15分 権限 permissions: contents: read # リポジトリコード読み取り checks: write # テスト結果の書き込み pull-requests: write # PRへのコメント ブランチプロテクション設定 Required Status Checks # GitHub Settings → Branches → main → Branch protection rules protection: required_status_checks: strict: true checks: - \"Test and Coverage / Run Tests\" # ✅ Required 動作: ✅ テスト成功 → PRマージ可能 ❌ テスト失敗 → PRマージブロック ⚠️ Codacyアップロード失敗 → PRマージ可能 (非ブロッキング) テストデータ管理 テストフィクスチャ // wt.tests/Fixtures/GitFixture.cs public class GitFixture : IDisposable { public string TempRepoPath { get; } public GitFixture() { TempRepoPath = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString()); Directory.CreateDirectory(TempRepoPath); // Initialize git repo } public void Dispose() { if (Directory.Exists(TempRepoPath)) { Directory.Delete(TempRepoPath, recursive: true); } } } モック // wt.tests/Mocks/MockProcessRunner.cs public class MockProcessRunner : IProcessRunner { public ProcessResult Run(string command, string args) { return new ProcessResult { ExitCode = 0, Output = \"mocked output\", Error = string.Empty }; } } ローカルテスト実行 すべてのテストを実行 dotnet test wt.sln --configuration Release --verbosity normal カバレッジ付きで実行 dotnet test wt.sln \\ --configuration Release \\ --collect:\"XPlat Code Coverage\" \\ --results-directory ./coverage カバレッジレポートを生成 dotnet tool install --global dotnet-reportgenerator-globaltool reportgenerator \\ -reports:\"./coverage/**/coverage.cobertura.xml\" \\ -targetdir:\"./coverage/report\" \\ -reporttypes:\"Html;TextSummary\" # HTMLレポートを開く open ./coverage/report/index.html 特定のテストを実行 dotnet test wt.tests/GitServiceTests.cs --filter \"CreateWorktree\" トラブルシューティング 問題: テストが失敗する 解決: ローカルでテストを実行: dotnet test wt.sln --verbosity detailed 失敗したテストのログを確認: cat TestResults/test-results.trx テストを修正してプッシュ 問題: カバレッジが0% 解決: カバレッジファイルを確認: find ./coverage -name \"coverage.cobertura.xml\" cat ./coverage/**/coverage.cobertura.xml カバレッジ収集の設定を確認: dotnet test --collect:\"XPlat Code Coverage\" 問題: Codacyアップロード失敗 解決: Codacyトークンを確認: gh secret list | grep CODACY トークンを再設定: gh secret set CODACY_PROJECT_TOKEN リファレンス ワークフローファイル: .github/workflows/test.yml テストプロジェクト: wt.tests/ ADR 0005: 品質ゲート タスク: tasks.md"
  },
  "specs/003-automated-release-pipeline/data-model.html": {
    "href": "specs/003-automated-release-pipeline/data-model.html",
    "title": "Data Model: Automated Binary Release Pipeline | wt",
    "summary": "Data Model: Automated Binary Release Pipeline Feature: 003-automated-release-pipeline Date: 2026-01-05 Related: spec.md, plan.md このドキュメントは、自動化されたバイナリリリースパイプラインのデータモデルを定義します。 概要 リリースパイプラインは、以下の主要エンティティで構成されます: Version - リリースバージョン情報 Release - GitHub Release エンティティ Binary - プラットフォーム固有のバイナリファイル SBOM - Software Bill of Materials Signature - デジタル署名情報 Commit - Gitコミット履歴 Build - ビルドジョブの実行情報 エンティティ定義 1. Version バージョン情報を表現するエンティティ。 属性: 属性 型 必須 説明 例 tag String ✅ Gitタグ (プレフィックス付き) v1.2.3 major Integer ✅ MAJORバージョン 1 minor Integer ✅ MINORバージョン 2 patch Integer ✅ PATCHバージョン 3 prerelease String ❌ プレリリースラベル alpha.1, beta.2 build_metadata String ❌ ビルドメタデータ 20260105 バージョン計算ロジック: Input: Commit history since last tag Process: 1. Parse commits for Conventional Commits types 2. Detect BREAKING CHANGE → MAJOR++, MINOR=0, PATCH=0 3. Detect feat: → MINOR++, PATCH=0 4. Detect fix: → PATCH++ 5. Otherwise → No version change Output: New version tag (e.g., v1.3.0) 関連: Release.version (1:1) - リリースに関連付けられたバージョン Commit.version (N:1) - バージョンに含まれるコミット一覧 2. Release GitHub Releaseエンティティ。 属性: 属性 型 必須 説明 例 id Integer ✅ GitHub Release ID 12345678 tag_name String ✅ リリースタグ v1.2.3 name String ✅ リリース名 v1.2.3 body String ✅ リリースノート (Markdown) ## Features\\n- Add feature A draft Boolean ✅ ドラフト状態 false prerelease Boolean ✅ プレリリース false created_at DateTime ✅ 作成日時 2026-01-05T12:00:00Z published_at DateTime ✅ 公開日時 2026-01-05T12:30:00Z html_url String ✅ GitHub Release URL https://github.com/kuju63/wt/releases/tag/v1.2.3 関連: Version (1:1) - バージョン情報 Binary[] (1:N) - リリースに含まれるバイナリファイル SBOM (1:1) - リリースのSBOM Signature[] (1:N) - リリースのデジタル署名 3. Binary プラットフォーム固有のバイナリファイル。 属性: 属性 型 必須 説明 例 filename String ✅ ファイル名 wt-v1.2.3-linux-x64 platform Enum ✅ プラットフォーム windows, linux, macos architecture Enum ✅ アーキテクチャ x64, arm64, arm rid String ✅ Runtime Identifier linux-x64, win-x64, osx-arm64 mandatory Boolean ✅ 必須プラットフォーム true (失敗でリリースブロック), false (オプション) size Integer ✅ ファイルサイズ (bytes) 15728640 (15 MB) sha256 String ✅ SHA256ハッシュ値 a3c5d... (64文字) download_url String ✅ ダウンロードURL https://github.com/.../wt-v1.2.3-linux-x64 download_count Integer ✅ ダウンロード数 1234 プラットフォーム列挙型: Platform: - windows # MANDATORY - linux # MANDATORY (x64), OPTIONAL (arm) - macos # MANDATORY (arm64) アーキテクチャ列挙型: Architecture: - x64 # 64-bit x86 - arm64 # 64-bit ARM (Apple Silicon) - arm # 32-bit ARM (Raspberry Pi等) 関連: Release (N:1) - 所属するリリース Build (1:1) - ビルドジョブ情報 4. SBOM (Software Bill of Materials) CycloneDX形式のSBOM。 属性: 属性 型 必須 説明 例 filename String ✅ ファイル名 wt-v1.2.3-sbom.json format String ✅ SBOM形式 CycloneDX spec_version String ✅ 仕様バージョン 1.4, 1.5 bom_format String ✅ BOMフォーマット json, xml component_count Integer ✅ コンポーネント数 42 components Component[] ✅ 依存関係リスト (下記参照) size Integer ✅ ファイルサイズ (bytes) 524288 (512 KB) download_url String ✅ ダウンロードURL https://github.com/.../wt-v1.2.3-sbom.json Component (コンポーネント): 属性 型 説明 例 name String パッケージ名 System.CommandLine version String バージョン 2.0.0 type String タイプ library, framework, application licenses String[] ライセンス [\"MIT\"] purl String Package URL pkg:nuget/System.CommandLine@2.0.0 関連: Release (N:1) - 所属するリリース Signature (1:1) - SBOM署名 5. Signature GPGデジタル署名。 属性: 属性 型 必須 説明 例 filename String ✅ 署名ファイル名 wt-v1.2.3-sbom.json.asc signed_file String ✅ 署名対象ファイル wt-v1.2.3-sbom.json algorithm String ✅ 署名アルゴリズム RSA, DSA key_length Integer ✅ 鍵長 (bits) 4096 fingerprint String ✅ GPG鍵フィンガープリント ABCD1234... (40文字) signer String ✅ 署名者 Release Bot <release@example.com> created_at DateTime ✅ 署名作成日時 2026-01-05T12:25:00Z download_url String ✅ ダウンロードURL https://github.com/.../wt-v1.2.3-sbom.json.asc 署名対象ファイル: wt-v<version>-sbom.json → wt-v<version>-sbom.json.asc SHA256SUMS → SHA256SUMS.asc 関連: SBOM (1:1) - 署名されたSBOM Release (N:1) - 所属するリリース 6. Commit Gitコミット履歴。 属性: 属性 型 必須 説明 例 sha String ✅ コミットSHA a3c5d1f... (40文字) message String ✅ コミットメッセージ feat: add feature A type Enum ✅ Conventional Commit タイプ feat, fix, docs, chore subject String ✅ コミット件名 add feature A body String ❌ コミット本文 Detailed description... breaking_change Boolean ✅ 破壊的変更フラグ true, false author String ✅ 作成者 John Doe <john@example.com> committed_at DateTime ✅ コミット日時 2026-01-04T10:00:00Z Conventional Commit タイプ列挙型: CommitType: - feat # 新機能 (MINOR bump) - fix # バグ修正 (PATCH bump) - docs # ドキュメント (バージョン変更なし) - style # コードスタイル (バージョン変更なし) - refactor # リファクタリング (バージョン変更なし) - test # テスト (バージョン変更なし) - chore # ビルド/ツール (バージョン変更なし) - BREAKING # 破壊的変更 (MAJOR bump) 関連: Version (N:1) - 所属するバージョン Release (N:1) - リリースノートに含まれるコミット 7. Build GitHub Actionsビルドジョブ情報。 属性: 属性 型 必須 説明 例 run_id Integer ✅ GitHub Actions Run ID 12345678 job_id Integer ✅ Job ID 87654321 platform Enum ✅ ビルドプラットフォーム windows, linux, macos architecture Enum ✅ アーキテクチャ x64, arm64, arm status Enum ✅ ビルドステータス success, failure, cancelled started_at DateTime ✅ 開始日時 2026-01-05T12:00:00Z completed_at DateTime ✅ 完了日時 2026-01-05T12:10:00Z duration Integer ✅ 実行時間 (秒) 600 (10分) runner_os String ✅ Runnerオペレーティングシステム ubuntu-latest, windows-latest, macos-latest logs_url String ✅ ログURL https://github.com/kuju63/wt/actions/runs/12345678 ビルドステータス列挙型: BuildStatus: - queued # ビルド待機中 - in_progress # ビルド実行中 - success # ビルド成功 - failure # ビルド失敗 - cancelled # ビルドキャンセル 関連: Binary (1:1) - 生成されたバイナリ Release (N:1) - 所属するリリース エンティティ関係図 (ER図) erDiagram Version ||--|| Release : \"has\" Release ||--|{ Binary : \"contains\" Release ||--|| SBOM : \"includes\" Release ||--|{ Signature : \"includes\" Release ||--|{ Commit : \"generated-from\" Binary ||--|| Build : \"built-by\" SBOM ||--|| Signature : \"signed-by\" Version ||--|{ Commit : \"includes\" Version { string tag PK int major int minor int patch string prerelease } Release { int id PK string tag_name FK string name string body bool draft bool prerelease datetime created_at datetime published_at string html_url } Binary { string filename PK enum platform enum architecture string rid bool mandatory int size string sha256 string download_url int download_count } SBOM { string filename PK string format string spec_version string bom_format int component_count json components int size string download_url } Signature { string filename PK string signed_file FK string algorithm int key_length string fingerprint string signer datetime created_at string download_url } Commit { string sha PK string message enum type string subject string body bool breaking_change string author datetime committed_at } Build { int run_id PK int job_id enum platform enum architecture enum status datetime started_at datetime completed_at int duration string runner_os string logs_url } データフロー リリース作成フロー flowchart TD A[Commit to main] --> B[Calculate Version] B --> C{Version changed?} C -->|No| D[Skip release] C -->|Yes| E[Build Binaries] E --> F[Generate SBOM] F --> G[Generate Checksums] G --> H[Sign Artifacts] H --> I[Generate Release Notes] I --> J[Create Git Tag] J --> K[Create GitHub Release] K --> L[Upload Binaries] L --> M[Upload SBOM] M --> N[Upload Signatures] N --> O[Upload Checksums] O --> P[Release Published] バージョン計算フロー flowchart TD A[Get last tag] --> B[Get commits since last tag] B --> C{Parse commits} C -->|BREAKING CHANGE:| D[MAJOR++] C -->|feat:| E[MINOR++] C -->|fix:| F[PATCH++] C -->|docs:, chore:, etc.| G[No version change] D --> H[Generate new tag] E --> H F --> H G --> I[Skip release] H --> J[Create release] ファイル命名規則 バイナリファイル wt-<version>-<platform>-<arch>[.<ext>] Examples: - wt-v1.2.3-windows-x64.exe - wt-v1.2.3-linux-x64 - wt-v1.2.3-linux-arm - wt-v1.2.3-macos-arm64 SBOMファイル wt-<version>-sbom.json Example: - wt-v1.2.3-sbom.json 署名ファイル <original-filename>.asc Examples: - wt-v1.2.3-sbom.json.asc - SHA256SUMS.asc チェックサムファイル SHA256SUMS Format (inside file): <hash> <filename> Example: a3c5d1f2b4e6... wt-v1.2.3-linux-x64 b5d7e2f3c5g8... wt-v1.2.3-windows-x64.exe API契約 GitHub Release API Endpoint: POST /repos/{owner}/{repo}/releases Request: { \"tag_name\": \"v1.2.3\", \"name\": \"v1.2.3\", \"body\": \"## Features\\n- Add feature A\\n\\n## Bug Fixes\\n- Fix bug B\", \"draft\": false, \"prerelease\": false } Response: { \"id\": 12345678, \"tag_name\": \"v1.2.3\", \"name\": \"v1.2.3\", \"body\": \"...\", \"draft\": false, \"prerelease\": false, \"created_at\": \"2026-01-05T12:00:00Z\", \"published_at\": \"2026-01-05T12:30:00Z\", \"html_url\": \"https://github.com/kuju63/wt/releases/tag/v1.2.3\", \"assets\": [...] } ストレージ GitHub Releases (Primary Storage) バイナリファイル: 最大2GB/ファイル, 10GB/リリース 保存期間: 無期限 (リリース削除まで) アクセス: Public (認証不要でダウンロード可能) Git Repository (Metadata Storage) Gitタグ: バージョン情報 (v1.2.3) コミット履歴: リリースノート生成元 ドキュメント: GPG公開鍵 (docs/GPG_PUBLIC_KEY.asc) GitHub Actions Artifacts (Temporary Storage) ビルド成果物: 一時保存 (7日間保持) カバレッジレポート: 一時保存 (7日間保持) ログファイル: 一時保存 (90日間保持) セキュリティ考慮事項 シークレット管理 シークレット 用途 保存場所 GITHUB_TOKEN GitHub API認証 GitHub Actions (自動生成) GPG_PRIVATE_KEY デジタル署名 GitHub Secrets GPG_PASSPHRASE GPG鍵のパスフレーズ GitHub Secrets CODACY_PROJECT_TOKEN カバレッジ報告 GitHub Secrets 署名検証フロー flowchart TD A[Download SBOM] --> B[Download SBOM.asc] B --> C[Import GPG public key] C --> D[Verify signature] D -->|Valid| E[Trust SBOM] D -->|Invalid| F[Reject SBOM] 参考資料 Semantic Versioning 2.0.0 Conventional Commits 1.0.0 CycloneDX Specification GitHub Releases API GitHub Actions Workflow Syntax"
  },
  "specs/003-automated-release-pipeline/plan.html": {
    "href": "specs/003-automated-release-pipeline/plan.html",
    "title": "Implementation Plan: 自動化されたバイナリリリースパイプライン | wt",
    "summary": "Implementation Plan: 自動化されたバイナリリリースパイプライン Branch: 001-automated-release-pipeline | Date: 2026-01-04 | Spec: specs/001-automated-release-pipeline/spec.md Input: Feature specification from /specs/001-automated-release-pipeline/spec.md Summary GitHub Releaseを通じて、テスト済みのコンパイル済みバイナリを複数プラットフォーム（Windows x64、Linux x64/ARM、Mac ARM64）向けに自動配布するパイプラインを構築します。mainへのマージをトリガーとして、Conventional Commitsベースの自動バージョニング、ファイルハッシュ生成、CycloneDX SBOM生成、リリースノート自動生成、Codacy連携によるカバレッジ報告を実現します。すべてのプロセスはGitHub Actions上で自動化され、セキュリティと品質を担保します。 Technical Context Language/Version: GitHub Actions (YAML-based CI/CD configuration) + Bash scripting + platform-specific build tools Primary Dependencies: GitHub Actions (built-in, no external dependency) Conventional Commits parser (semantic-release or custom implementation) CycloneDX tools (for SBOM generation - language/platform specific) Codacy (external service, already integrated) Platform-specific compilers (C#, .NET for wt project) Storage: GitHub Releases (binary artifacts), Git repository (SBOM, hashes, version tags) Testing: Existing test suite (automated via GitHub Actions), coverage via Codacy Target Platform: Multi-platform (Windows x64, Linux x64/ARM, Mac ARM64) Project Type: CLI tool with multi-platform binary distribution Performance Goals: Release publish within 30 minutes of main merge, binary download < 2 minutes Constraints: GitHub Release size limits (2GB per file, 10GB per release), GitHub Actions concurrency limits Scale/Scope: 3 mandatory platforms + 1 optional, supporting multiple architecture variants Constitution Check GATE: Must pass before Phase 0 research. Re-check after Phase 1 design. Core Principles Compliance Principle Requirement Status Notes I. Developer Usability GitHub Actions workflows should be clear, version strategy transparent ✅ PASS Conventional Commits used; version auto-detection clear II. Cross-Platform Support Windows, Linux, macOS ✅ PASS 3 mandatory + 1 optional platform supported III. Clean & Secure Code No hardcoded secrets, TDD for tests ⚠️ CONDITIONAL Requires SBOM verification and signature validation implementation IV. Documentation Japanese docs priority, ADR for decisions ✅ PASS Spec in Japanese; technical decisions recorded in clarifications V. Minimal Dependencies Prefer built-in tools, reduce external deps ✅ PASS GitHub Actions native; no extra runtime deps needed VI. Comprehensive Testing TDD + CI automation ✅ PASS All branches tested before merge; Codacy integration VII. Quantitative Thresholds 80% coverage goal, <50 LOC per function ⚠️ CONDITIONAL Coverage threshold set to 80%; workflow LOC needs review Gate Evaluation ✅ PASS - No blocking violations. Conditional items (III, VII) are addressed through proper workflow design and code review. SBOM generation and signature validation are explicit requirements (FR-004, FR-011). Project Structure Documentation (this feature) specs/001-automated-release-pipeline/ ├── spec.md # Feature specification (完了) ├── plan.md # This file - Implementation plan ├── research.md # Phase 0 - Technology research (来週生成) ├── data-model.md # Phase 1 - Release pipeline data model (来週生成) ├── contracts/ # Phase 1 - GitHub Actions contract definitions (来週生成) │ ├── build-workflow.yml # Build matrix specification │ ├── release-workflow.yml # Release process specification │ └── test-workflow.yml # Test & coverage specification ├── quickstart.md # Phase 1 - Quick start guide (来週生成) └── checklists/ └── requirements.md # Quality checklist (完了) ### Source Code (repository root) This feature implements GitHub Actions workflows and supporting infrastructure: ```text .github/ ├── workflows/ │ ├── test.yml # Branch testing & coverage reporting │ ├── build.yml # Multi-platform binary building │ └── release.yml # Release publishing to GitHub Releases ├── scripts/ │ ├── generate-sbom.sh # CycloneDX SBOM generation │ ├── generate-checksums.sh # SHA256 hash generation │ └── generate-release-notes.sh # Conventional Commits → release notes └── prompts/ └── speckit.plan.prompt.md # Spec Kit configuration wt.cli/ # Existing CLI project (update: add version info) ├── src/ │ └── Program.cs # Add --version flag support └── wt.cli.csproj wt.tests/ # Existing test suite (update: coverage reporting) ├── [existing test structure] └── [add Codacy integration] Structure Decision: The feature is exclusively GitHub Actions workflows and supporting scripts. No new core application code is created. Version control and release automation are handled by workflow configuration and shell scripts in .github/. Existing test infrastructure is leveraged; Codacy integration is configured via workflow secrets. Complexity Tracking None required at this stage. Constitution Check passed without violations."
  },
  "specs/003-automated-release-pipeline/quickstart.html": {
    "href": "specs/003-automated-release-pipeline/quickstart.html",
    "title": "Quick Start: 自動化されたバイナリリリースパイプライン | wt",
    "summary": "Quick Start: 自動化されたバイナリリリースパイプライン Feature: 003-automated-release-pipeline Date: 2026-01-04 Spec: spec.md | Plan: plan.md このガイドは、自動化されたバイナリリリースパイプラインの使用方法を説明します。 \uD83D\uDCE6 リリースバイナリのダウンロード ステップ1: GitHub Releasesページにアクセス リポジトリのGitHub Releasesページに移動: https://github.com/kuju63/wt/releases 最新リリースを選択 (例: v1.0.0) ステップ2: プラットフォームに適したバイナリをダウンロード 利用可能なプラットフォーム: Windows x64: wt-v<version>-windows-x64.exe Linux x64: wt-v<version>-linux-x64 Linux ARM: wt-v<version>-linux-arm (オプション) macOS ARM64: wt-v<version>-macos-arm64 ステップ3: バイナリに実行権限を付与 (Linux/macOS) chmod +x wt-v<version>-linux-x64 # または chmod +x wt-v<version>-macos-arm64 ステップ4: バイナリを実行 # Linux/macOS ./wt-v<version>-linux-x64 --version # Windows (PowerShell) .\\wt-v<version>-windows-x64.exe --version \uD83D\uDD12 バイナリの整合性検証 SHA256ハッシュ値の検証 ステップ1: チェックサムファイルをダウンロード GitHub Releasesページから以下のファイルをダウンロード: SHA256SUMS SHA256SUMS.asc (GPG署名) ステップ2: GPG署名を検証 # GPG公開鍵をインポート (初回のみ) curl -fsSL https://raw.githubusercontent.com/kuju63/wt/main/docs/GPG_PUBLIC_KEY.asc | gpg --import # 署名を検証 gpg --verify SHA256SUMS.asc SHA256SUMS 期待される出力: gpg: Signature made ... gpg: Good signature from \"Release Pipeline Bot <release@kuju63.example.com>\" ステップ3: ハッシュ値を検証 # Linux/macOS sha256sum -c SHA256SUMS --ignore-missing # macOS (sha256sum がない場合) shasum -a 256 -c SHA256SUMS --ignore-missing # Windows (PowerShell) $hash = (Get-FileHash -Algorithm SHA256 wt-v<version>-windows-x64.exe).Hash.ToLower() $expected = (Get-Content SHA256SUMS | Select-String \"wt-v<version>-windows-x64.exe\").Line.Split()[0] if ($hash -eq $expected) { Write-Host \"OK: Hash verified\" -ForegroundColor Green } else { Write-Host \"ERROR: Hash mismatch\" -ForegroundColor Red } 期待される出力: wt-v1.0.0-linux-x64: OK \uD83D\uDCC4 SBOM (Software Bill of Materials) の確認 ステップ1: SBOMファイルをダウンロード GitHub Releasesページから以下のファイルをダウンロード: wt-v<version>-sbom.json (CycloneDX形式) wt-v<version>-sbom.json.asc (GPG署名) ステップ2: SBOM署名を検証 gpg --verify wt-v<version>-sbom.json.asc wt-v<version>-sbom.json ステップ3: SBOMの内容を確認 # 依存関係の一覧を表示 jq '.components[].name' wt-v<version>-sbom.json # 依存関係の数を表示 jq '.components | length' wt-v<version>-sbom.json # 特定の依存関係を検索 jq '.components[] | select(.name | contains(\"System.CommandLine\"))' wt-v<version>-sbom.json SBOM形式 フォーマット: CycloneDX 1.4 (JSON) 仕様: https://cyclonedx.org/specification/overview/ \uD83D\uDE80 リリースの自動作成 (開発者向け) 前提条件 GitHub Secrets の設定 (リポジトリ管理者のみ): GH_RELEASE_TOKEN: GitHub Personal Access Token (repo権限) CODACY_PROJECT_TOKEN: Codacyプロジェクトトークン GPG_PRIVATE_KEY: GPG秘密鍵 (ASCII-armored形式) GPG_PASSPHRASE: GPG鍵のパスフレーズ 詳細: .github/SECRETS.md Conventional Commits規約の遵守: すべてのコミットメッセージは Conventional Commits 規約に従うこと 詳細: docs/ja/CONVENTIONAL_COMMITS.md リリース作成フロー ステップ1: 機能ブランチを作成 git checkout -b feature/new-amazing-feature ステップ2: Conventional Commitsでコミット # 新機能 (MINOR version bump) git commit -m \"feat: add support for multiple worktrees\" # バグ修正 (PATCH version bump) git commit -m \"fix: handle special characters in branch names\" # 破壊的変更 (MAJOR version bump) git commit -m \"feat: change CLI argument format BREAKING CHANGE: All CLI arguments now use kebab-case. Migration guide: docs/migration/v2.0.md\" ステップ3: プルリクエストを作成 git push origin feature/new-amazing-feature GitHub上でPRを作成し、レビューを受ける。 ステップ4: mainにマージ PRが承認されたら、mainブランチにマージします。 ステップ5: 自動リリース作成を確認 GitHub Actions workflow (release.yml) が自動実行されます 次のバージョン番号が自動計算されます: feat: → MINOR bump (0.1.0 → 0.2.0) fix: → PATCH bump (0.1.0 → 0.1.1) BREAKING CHANGE: → MAJOR bump (0.1.0 → 1.0.0) バイナリが全プラットフォーム向けにビルドされます SHA256SUMS、SBOM、署名ファイルが生成されます リリースノートが自動生成されます GitHub Releaseが公開されます 予想時間: mainマージから30分以内 トラブルシューティング 問題: リリースが作成されない 原因: Conventional Commits規約に準拠していない、またはバージョン変更が不要なコミット (docs, style等) のみ 解決策: コミットメッセージを確認: git log feat:, fix:, BREAKING CHANGE: が含まれているか確認 必要に応じて、git commit --amend で修正 問題: ビルドが失敗する 原因: テストが失敗している、またはビルドエラー 解決策: GitHub Actions のログを確認 ローカルでテストを実行: dotnet test wt.sln ローカルでビルドを実行: dotnet build wt.sln --configuration Release 問題: 署名ファイルが生成されない 原因: GPG_PRIVATE_KEY または GPG_PASSPHRASE が設定されていない 解決策: GitHub リポジトリ設定 > Secrets and variables > Actions を確認 必要なシークレットが設定されているか確認 詳細: .github/SECRETS.md \uD83D\uDCCA カバレッジレポートの確認 Codacyでカバレッジを確認 Codacyプロジェクトダッシュボードにアクセス: https://app.codacy.com/gh/kuju63/wt \"Coverage\" タブを選択 最新のコミットのカバレッジを確認 カバレッジ目標 プロジェクト全体: 80%以上 品質ゲート: カバレッジが80%未満の場合は警告 (マージはブロックしない) \uD83D\uDEE1️ ブランチ保護ルール (リポジトリ管理者向け) mainブランチを保護するため、以下のルールを設定してください: GitHub リポジトリ設定 > Branches > Branch protection rules \"Add rule\" をクリック Branch name pattern: main 以下を有効化: ✅ Require a pull request before merging ✅ Require status checks to pass before merging Required checks: test (Test and Coverage workflow) ✅ Require branches to be up to date before merging ✅ Do not allow bypassing the above settings \uD83D\uDCDA 参考資料 Conventional Commits 規約 GitHub Secrets 設定ガイド 技術調査レポート 実装計画 仕様書 最終更新: 2026-01-04 担当者: Release Pipeline Team"
  },
  "specs/003-automated-release-pipeline/research.html": {
    "href": "specs/003-automated-release-pipeline/research.html",
    "title": "Research: Automated Binary Release Pipeline | wt",
    "summary": "Research: Automated Binary Release Pipeline Feature: 003-automated-release-pipeline Date: 2026-01-04 Spec: spec.md | Plan: plan.md このドキュメントは、自動化されたバイナリリリースパイプラインの技術調査結果を記録します。 1. セマンティックバージョニング決定ログ 背景 プロジェクトでは、バージョン番号の自動管理が必要です。Conventional Commitsに基づいて、次のバージョン番号を自動計算する仕組みを構築します。 採用規約 Semantic Versioning 2.0.0 を採用 フォーマット: MAJOR.MINOR.PATCH (例: 1.2.3) プレリリース版: MAJOR.MINOR.PATCH-alpha.1 (例: 1.0.0-alpha.1) バージョンインクリメントルール Commit Type Version Bump 例 BREAKING CHANGE: (footer) MAJOR (X.0.0) 0.5.2 → 1.0.0 feat: MINOR (0.X.0) 0.5.2 → 0.6.0 fix: PATCH (0.0.X) 0.5.2 → 0.5.3 その他 (docs, style, refactor, test, chore, ci) バージョン変更なし - 初期バージョン プロジェクト初回リリース: v0.1.0 初回MAJORリリース (安定版): v1.0.0 バージョンタグ形式 Gitタグ: v1.2.3 (プレフィックス v を付ける) GitHub Release名: v1.2.3 バイナリファイル名: wt-v1.2.3-windows-x64.exe 実装戦略 バージョン計算スクリプト (.github/scripts/calculate-version.sh) 最新タグを取得: git describe --tags --abbrev=0 前回リリース以降のコミットを解析: git log <last-tag>..HEAD --pretty=format:%s Conventional Commitsをパース: 正規表現で feat:, fix:, BREAKING CHANGE: を検出 次のバージョンを計算: MAJOR/MINOR/PATCH インクリメント 新しいタグを作成: git tag -a v1.2.3 -m \"Release v1.2.3\" タグプッシュとリリース作成 GitHub Actions workflow (release.yml) でタグをプッシュ GitHub Releases APIでリリースを作成 計算されたバージョンをリリース名とタグに使用 参考資料 Semantic Versioning 2.0.0 Conventional Commits 1.0.0 GitHub Releases API 2. CycloneDX統合オプション CycloneDX統合の背景 Software Bill of Materials (SBOM) を生成し、依存関係の透明性を確保する必要があります。CycloneDX形式を採用します。 調査対象ツール Option 1: dotnet-sbom (推奨) ツール名: Microsoft dotnet-sbom リポジトリ: https://github.com/microsoft/sbom-tool 対応言語: .NET, NuGet, npm, Python, Go, Rust 出力形式: CycloneDX JSON/XML, SPDX インストール: dotnet tool install --global Microsoft.Sbom.DotNetTool 使用例: dotnet tool install --global Microsoft.Sbom.DotNetTool sbom-tool generate -b /path/to/project -bc /path/to/project -pn wt -pv 1.0.0 -ps kuju63 -nsb https://github.com/kuju63 メリット: Microsoft公式ツール .NETプロジェクトに最適化 GitHub Actionsとの統合が容易 CycloneDX 1.4準拠 デメリット: マルチプラットフォームビルドの場合、各ビルドごとにSBOMを生成する必要がある 集約SBOMの生成には追加ロジックが必要 Option 2: CycloneDX CLI ツール名: CycloneDX CLI リポジトリ: https://github.com/CycloneDX/cyclonedx-cli 対応言語: 汎用 (任意のSBOM操作) 出力形式: CycloneDX JSON/XML インストール: npm install -g @cyclonedx/cyclonedx-cli または GitHub Releasesからバイナリダウンロード 使用例: cyclonedx-cli convert --input-file sbom1.json --output-file sbom-cyclonedx.xml --output-format xml cyclonedx-cli merge --input-files sbom1.json sbom2.json --output-file merged.json メリット: 汎用ツール (言語非依存) 複数SBOMのマージ機能あり CycloneDX公式ツール デメリット: .NET依存関係の自動検出機能なし (別ツールと併用が必要) Node.js依存 (GitHub Actionsでのインストール必要) Option 3: Syft (Anchore) ツール名: Syft リポジトリ: https://github.com/anchore/syft 対応言語: .NET, Go, Python, Java, JavaScript, Ruby, Rust等 出力形式: CycloneDX JSON/XML, SPDX, Syft JSON インストール: curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh 使用例: syft packages dir:/path/to/project -o cyclonedx-json > sbom.json メリット: 自動依存関係検出 マルチ言語対応 高速 デメリット: .NETプロジェクトでは dotnet-sbom ほど詳細な情報を提供しない 外部依存 (Anchore製品) 決定 Option 4: anchore/sbom-action (GitHub Action) を採用 ← 実装時に変更 理由: より広く使われている（1.5k+ stars） セットアップが簡単（dotnet tool installが不要） エラーハンドリングが充実 CycloneDX 1.4準拠 保守コストの削減 実装 - name: Generate SBOM uses: anchore/sbom-action@61119d458adab75f756bc0b9e4bde25725f86a7a # v0.17.2 with: path: ./wt.cli format: cyclonedx-json output-file: release-assets/wt-${{ needs.calculate-version.outputs.version }}-sbom.json セキュリティ: コミットID指定（61119d45...）でサプライチェーン攻撃を防止 メリット: 50行のカスタムスクリプトが4行のAction設定に簡素化 参考資料 CycloneDX Specification Microsoft SBOM Tool Documentation NTIA Minimum Elements for SBOM 3. Conventional Commitsパーサーオプション 背景 Conventional Commitsメッセージを解析し、バージョンインクリメントを自動決定する必要があります。 調査対象ツール Option 1: カスタムBashスクリプト (推奨) 実装: .github/scripts/calculate-version.sh 依存: git, grep, sed (GitHub Actions標準環境に含まれる) 使用例: #!/usr/bin/env bash LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo \"v0.0.0\") COMMITS=$(git log ${LAST_TAG}..HEAD --pretty=format:%s) if echo \"$COMMITS\" | grep -q \"BREAKING CHANGE:\"; then # MAJOR bump VERSION=\"X.0.0\" elif echo \"$COMMITS\" | grep -q \"^feat\"; then # MINOR bump VERSION=\"0.X.0\" elif echo \"$COMMITS\" | grep -q \"^fix\"; then # PATCH bump VERSION=\"0.0.X\" else echo \"No version bump needed\" exit 1 fi メリット: 追加依存なし (標準Unixツールのみ) GitHub Actionsで直接実行可能 カスタマイズが容易 デバッグが簡単 デメリット: 複雑なパース (スコープ、複数行body等) は実装が煩雑 テストが必要 Option 2: semantic-release ツール名: semantic-release リポジトリ: https://github.com/semantic-release/semantic-release 依存: Node.js, npm 使用例: npm install -g semantic-release npx semantic-release メリット: Conventional Commits完全対応 プラグインエコシステム豊富 GitHub Releasesへの自動公開機能 リリースノート自動生成 デメリット: Node.js依存 (追加のランタイムが必要) 設定が複雑 (.releaserc ファイル必要) ビルドプロセスとの統合が必要 Option 3: commitlint + standard-version ツール名: commitlint + standard-version リポジトリ: https://github.com/conventional-changelog/commitlint https://github.com/conventional-changelog/standard-version 依存: Node.js, npm 使用例: npm install -g @commitlint/cli @commitlint/config-conventional standard-version npx commitlint --from HEAD~1 --to HEAD npx standard-version メリット: commitlint: コミットメッセージバリデーション standard-version: バージョンインクリメント + CHANGELOG生成 Conventional Commits標準対応 デメリット: Node.js依存 2つのツールを組み合わせる必要がある GitHub Actions統合には追加設定が必要 決定 Option 4: paulhatch/semantic-version (GitHub Action) を採用 ← 実装時に変更 理由: コミュニティメンテナンス（7.3k+ stars）による保守性向上 信頼性が高く、広く使われている実績 カスタムスクリプトの保守コストを削減 エラーハンドリングが充実 Conventional Commits完全対応 実装 - name: Calculate next version id: version uses: paulhatch/semantic-version@a8f8f59fd7f0625188492e945240f12d7ad2dca3 # v5.4.0 with: tag_prefix: \"v\" major_pattern: \"(BREAKING CHANGE:|BREAKING:)\" minor_pattern: \"feat:\" version_format: \"v${major}.${minor}.${patch}\" bump_each_commit: false search_commit_body: true セキュリティ: コミットID指定（a8f8f59f...）でサプライチェーン攻撃を防止 参考資料 Bash Parameter Expansion Git Log Formatting Semantic Versioning Parser in Bash 4. GitHub Actions並行性制限 背景 複数プラットフォーム向けビルドを並行実行する際、GitHub Actionsの並行性制限を考慮する必要があります。 調査結果 GitHub-hostedランナーの制限 Freeプラン (Public repositories): 並行ジョブ数: 20ジョブ macOSランナー: 5並行ジョブ 月間実行時間: 無制限 ストレージ: 500MB Proプラン: 並行ジョブ数: 40ジョブ macOSランナー: 5並行ジョブ 月間実行時間: 3,000分 (Linux/Windows), 600分 (macOS) Enterpriseプラン: 並行ジョブ数: 180ジョブ macOSランナー: 50並行ジョブ 月間実行時間: 50,000分 (Linux/Windows), 10,000分 (macOS) ビルドマトリックス設計 このプロジェクトでは、以下のプラットフォームを並行ビルドします: Windows x64 (MANDATORY) Linux x64 (MANDATORY) Linux ARM (OPTIONAL) Mac ARM64 (MANDATORY) 並行ジョブ数: 4ジョブ (Freeプランの制限内) ビルドマトリックス設定 (.github/workflows/build.yml): strategy: fail-fast: false # OPTIONAL platformが失敗してもMANDATORYは続行 matrix: include: - os: windows-latest platform: windows arch: x64 rid: win-x64 mandatory: true - os: ubuntu-latest platform: linux arch: x64 rid: linux-x64 mandatory: true - os: ubuntu-latest platform: linux arch: arm rid: linux-arm mandatory: false # OPTIONAL - os: macos-latest platform: macos arch: arm64 rid: osx-arm64 mandatory: true 実行時間予測 各プラットフォームのビルド時間 (概算): Windows x64: 5-7分 (.NETビルド + テスト) Linux x64: 4-6分 Linux ARM: 6-8分 (クロスコンパイル) Mac ARM64: 5-7分 並行実行により、最も遅いビルド (Linux ARM: 8分) に合わせて完了。 リリース全体の実行時間目標: 30分以内 (ビルド + SBOM + ハッシュ + リリース公開) 参考資料 GitHub Actions: Usage limits GitHub Actions: Matrix strategies 5. Codacy統合ステータス 背景 テストカバレッジをCodacyに報告し、PRで品質ゲートを表示する必要があります。 現在のCodacy統合状況 Codacyプロジェクト: 既に設定済み カバレッジアップロード: 未設定 (これから実装) 品質ゲート: 未設定 (これから実装) Codacy Coverage Reporter ツール名: Codacy Coverage Reporter リポジトリ: https://github.com/codacy/codacy-coverage-reporter インストール: GitHub Actions Marketplaceから利用可能 使用例 (.github/workflows/test.yml) - name: Upload coverage to Codacy uses: codacy/codacy-coverage-reporter-action@v1 with: project-token: ${{ secrets.CODACY_PROJECT_TOKEN }} coverage-reports: coverage/cobertura.xml カバレッジフォーマット .NETプロジェクトでは、Cobertura XML形式を使用: dotnet test --collect:\"XPlat Code Coverage\" --results-directory ./coverage 出力ファイル: coverage/**/coverage.cobertura.xml Codacy品質ゲート設定 Codacyダッシュボードで以下を設定: カバレッジ閾値: 80% (プロジェクト全体) PR品質ゲート: カバレッジが閾値を下回る場合: 警告 (マージはブロックしない) テストが失敗する場合: エラー (マージをブロック) 通知設定: PRコメントでカバレッジ変化を表示 Slackへの通知 (オプション) ワークフロー統合 test.yml: 全ブランチでテスト実行、カバレッジ収集、Codacyアップロード release.yml: mainマージ時、test.ymlが成功した場合のみリリース作成 ブランチ保護ルール: test.yml workflowの成功をmainマージの必須条件に設定 参考資料 Codacy Coverage Reporter dotnet test coverage options 6. プラットフォーム固有コンパイラ可用性 背景 GitHub-hosted runnersで各プラットフォーム向けビルドが可能か確認する必要があります。 GitHub-hosted runners環境 Ubuntu Latest (linux) OS: Ubuntu 22.04 .NET SDK: .NET 6.0, 7.0, 8.0 プリインストール クロスコンパイル: Linux x64ネイティブビルド可能、ARM向けクロスコンパイルも可能 利用可能ツール: gcc, clang, make, cmake, git, curl, wget ビルドコマンド: dotnet publish -c Release -r linux-x64 --self-contained dotnet publish -c Release -r linux-arm --self-contained Windows Latest (windows) OS: Windows Server 2022 .NET SDK: .NET 6.0, 7.0, 8.0 プリインストール ビルドツール: MSBuild, Visual Studio Build Tools 利用可能ツール: git, PowerShell, Chocolatey ビルドコマンド: dotnet publish -c Release -r win-x64 --self-contained macOS Latest (macos) OS: macOS 14 (Sonoma) .NET SDK: .NET 6.0, 7.0, 8.0 プリインストール アーキテクチャ: ARM64 (Apple Silicon) 利用可能ツール: Xcode, Homebrew, git ビルドコマンド: dotnet publish -c Release -r osx-arm64 --self-contained .NETランタイム識別子 (RID) プラットフォーム RID ランナー ビルド可否 Windows x64 win-x64 windows-latest ✅ ネイティブ Linux x64 linux-x64 ubuntu-latest ✅ ネイティブ Linux ARM linux-arm ubuntu-latest ✅ クロスコンパイル macOS ARM64 osx-arm64 macos-latest ✅ ネイティブ 追加依存関係 特になし。.NET SDKが全てのランナーにプリインストールされているため、追加のセットアップは不要。 参考資料 GitHub Actions: Runner Images .NET RID Catalog 7. デジタル署名ツール選定 背景 SBOM と SHA256SUMS ファイルにデジタル署名を付与し、改ざん検証を可能にする必要があります (FR-011)。 調査対象ツール Option 1: GPG (GNU Privacy Guard) ツール名: GPG バージョン: 2.x 使用例: gpg --armor --detach-sign --default-key YOUR_KEY_ID sbom.json # 生成: sbom.json.asc メリット: 業界標準ツール GitHub Actions環境にプリインストール OpenPGP準拠 公開鍵の配布が容易 デメリット: 秘密鍵の管理が必要 パスフレーズ入力が必要 (自動化時は環境変数で対応) Option 2: Cosign (Sigstore) ツール名: Cosign リポジトリ: https://github.com/sigstore/cosign 使用例: cosign sign-blob --key cosign.key sbom.json > sbom.json.sig cosign verify-blob --key cosign.pub --signature sbom.json.sig sbom.json メリット: モダンな署名ツール Keyless署名対応 (OIDC認証) コンテナイメージ署名にも使用可能 透明性ログ (Rekor) 統合 デメリット: GitHub Actions環境に手動インストールが必要 比較的新しいツール (学習コストあり) GPGほど広く普及していない Option 3: GitHub Actions Native Attestation ツール名: GitHub Actions Attestation (Beta) 使用例: - name: Attest Build Provenance uses: actions/attest-build-provenance@v1 with: subject-path: 'wt-v1.0.0-windows-x64.exe' メリット: GitHub公式機能 追加ツール不要 自動的に検証可能 ビルドプロベナンス情報も含む デメリット: Beta機能 (安定性未知) GitHub外での検証が困難 SBOMファイル自体の署名には適さない (バイナリのみ) 決定 Option 1: GPG を採用 理由: GitHub Actions環境に標準でインストール済み 業界標準で広く認知されている SBOM と SHA256SUMS の両方に署名可能 公開鍵を簡単に配布・検証できる 実装計画 GPG鍵ペア生成 (ローカル作業) gpg --full-generate-key # 鍵タイプ: RSA and RSA (default) # 鍵サイズ: 4096 # 有効期限: 2年 # 名前: Release Pipeline Bot # メール: release@kuju63.example.com 秘密鍵のエクスポートとシークレット設定 gpg --armor --export-secret-keys YOUR_KEY_ID # 出力を SECRETS.md に従って GitHub Secrets に設定 署名スクリプト作成 (.github/scripts/sign-artifacts.sh) #!/usr/bin/env bash echo \"$GPG_PRIVATE_KEY\" | gpg --batch --import echo \"$GPG_PASSPHRASE\" | gpg --batch --yes --passphrase-fd 0 --armor --detach-sign sbom.json echo \"$GPG_PASSPHRASE\" | gpg --batch --yes --passphrase-fd 0 --armor --detach-sign SHA256SUMS # 生成: sbom.json.asc, SHA256SUMS.asc 公開鍵の配布 docs/GPG_PUBLIC_KEY.asc としてリポジトリに保存 GitHub Releaseの説明に公開鍵のフィンガープリントを記載 検証方法のドキュメント化 (quickstart.md) # 公開鍵のインポート gpg --import docs/GPG_PUBLIC_KEY.asc # 署名の検証 gpg --verify sbom.json.asc sbom.json gpg --verify SHA256SUMS.asc SHA256SUMS 参考資料 GPG Manual GitHub: Managing GPG keys Sigstore Cosign まとめ 技術決定項目 選択ツール/手法 理由 セマンティックバージョニング paulhatch/semantic-version (Action) コミュニティメンテ、保守コスト削減、7.3k+ stars CycloneDX統合 anchore/sbom-action (Action) セットアップ簡単、1.5k+ stars、保守コスト削減 Conventional Commitsパーサー paulhatch/semantic-version内蔵 Action統合済み、追加実装不要 並行ビルド GitHub Actionsマトリックス (max-parallel: 4) 全4プラットフォーム並列実行保証、70-75%高速化 カバレッジ報告 Codacy Coverage Reporter (コミットID指定) 既存Codacy統合活用、PR品質ゲート デジタル署名 GPG 2.x 業界標準、プリインストール、広く普及 セキュリティ強化 全サードパーティActionコミットID指定 サプライチェーン攻撃防止、不変参照 認証 GITHUB_TOKEN (自動提供) Personal Access Token不要、安全 実装時の主要変更点 バージョン計算: カスタムスクリプト削除 → paulhatch/semantic-version@a8f8f59f 採用 SBOM生成: カスタムスクリプト削除 → anchore/sbom-action@61119d45 採用 セキュリティ: 全サードパーティActions（5つ）をコミットID指定に変更 paulhatch/semantic-version@a8f8f59f (v5.4.0) anchore/sbom-action@61119d45 (v0.17.2) codacy/codacy-coverage-reporter-action@a3881847 dorny/test-reporter@bdab7eb6 (v2) softprops/action-gh-release@a06a81a0 (v2) 並列化: build.ymlにmax-parallel: 4追加で全プラットフォーム同時ビルド保証 認証: GH_RELEASE_TOKEN削除、GITHUB_TOKEN（自動提供）使用 ドキュメント: CONVENTIONAL_COMMITS.mdを.github/からdocs/ja/に移動 全ての技術調査と実装が完了しました。 最終更新: 2026-01-05 担当者: Release Pipeline Team"
  },
  "specs/003-automated-release-pipeline/spec.html": {
    "href": "specs/003-automated-release-pipeline/spec.html",
    "title": "機能仕様書: 自動化されたバイナリリリースパイプライン | wt",
    "summary": "機能仕様書: 自動化されたバイナリリリースパイプライン 機能ブランチ: 001-automated-release-pipeline 作成日: 2026-01-04 ステータス: ドラフト Input: User description: \"ユーザーはコンパイル済みのバイナリをGitHub Releaseからダウンロードしてインストールする。このバイナリファイルはテスト済みであり、別途ファイルハッシュやCycloneDXによる依存関係が取得できなければならない。バイナリファイルはWindows、Linux（Redhat系, Debian系）、Macをサポートし、Windowsはx64のみ、Linuxはx64とARM系、Macはaarm64を対象とする。このバイナリのリリースには人手を介してはならず（セキュリティの担保のため）、すべてGitHub Hostedな環境で完結すること。バイナリのリリースタイミングはmainへのマージタイミングとし、一貫したバージョン管理によりユーザーへの変更を保証するものとする。これらの前提としてすべてのブランチは都度テストされる必要があり、カバレッジはCodacyに集約されている必要がある。Codacyには本プロジェクトの品質情報が集約されているため、カバレッジもその指標として扱われる。\" ユーザーシナリオとテスト (必須) ユーザーストーリー 1 - コンパイル済みバイナリのダウンロードとインストール (優先度: P1) エンドユーザーとして、ソースからビルドすることなく、GitHub Releasesから事前コンパイルされテスト済みのバイナリをダウンロードしてシステムにインストールし、アプリケーションをすぐに使い始めたい。 この優先度の理由: これは中核的な価値提案です - ユーザーにすぐに使えるバイナリを提供すること。これがなければ、ユーザーはアプリケーションに簡単にアクセスできません。 独立テスト: サポートされている任意のプラットフォーム向けリリースバイナリをダウンロードし、ファイルハッシュを検証し、バイナリを実行して正しく動作することを確認することで完全にテストできます。動作するアプリケーションを提供することで即座に価値を提供します。 受け入れシナリオ: 前提条件 GitHub Releasesページにいる、操作 最新リリースを選択する、期待結果 サポートされているすべてのプラットフォーム（Windows x64、Linux x64、Linux ARM、Mac ARM64）のダウンロードリンクが表示される 前提条件 自分のプラットフォーム向けのバイナリをダウンロードした、操作 提供されたハッシュファイルに対してファイルハッシュを検証する、期待結果 ハッシュが完全に一致する 前提条件 バイナリをダウンロードした、操作 インストールして実行する、期待結果 アプリケーションが正常に実行されバージョン情報が表示される 前提条件 Windows x64ユーザーである、操作 Windowsバイナリをダウンロードする、期待結果 Windows x64で動作する.exeファイルを受け取る 前提条件 Linuxユーザー（RedhatまたはDebian）である、操作 Linuxバイナリをダウンロードする、期待結果 x64とARMアーキテクチャの両方で動作するバイナリを受け取る 前提条件 Mac ARM64ユーザーである、操作 Macバイナリをダウンロードする、期待結果 ARM64アーキテクチャでネイティブに動作するバイナリを受け取る ユーザーストーリー 2 - ソフトウェアサプライチェーンセキュリティの検証 (優先度: P1) セキュリティ意識の高いユーザーとして、CycloneDX SBOMとファイルハッシュを通じてバイナリの依存関係と完全性を検証し、ソフトウェアが信頼でき改ざんされていないことを確認したい。 この優先度の理由: セキュリティは企業やセキュリティ意識の高いユーザーにとって重要です。これにより信頼が構築され、セキュリティポリシーへの準拠が可能になります。 独立テスト: リリースをダウンロードし、SBOMの可用性を確認し、すべてのチェックサムを検証し、依存関係情報が完全であることを確認することで完全にテストできます。バイナリの機能とは独立してセキュリティの透明性を提供します。 受け入れシナリオ: 前提条件 新しいリリースが公開された、操作 リリースアセットにアクセスする、期待結果 すべての依存関係を一覧表示するCycloneDX SBOMファイル（JSONまたはXML形式）が見つかる 前提条件 SBOMファイルを持っている、操作 それを解析する、期待結果 パッケージ名、バージョン、ライセンスを含む完全な依存関係情報が表示される 前提条件 新しいリリースが公開された、操作 リリースアセットにアクセスする、期待結果 すべてのバイナリのハッシュを含むチェックサムファイル（例: SHA256SUMS）が見つかる 前提条件 バイナリとチェックサムファイルをダウンロードした、操作 ローカルでハッシュを計算する、期待結果 チェックサムファイル内のハッシュと一致する 前提条件 ソフトウェアサプライチェーンを監査する必要がある、操作 SBOMをレビューする、期待結果 すべてのサードパーティ依存関係とそのセキュリティステータスを特定できる ユーザーストーリー 3 - mainブランチマージ時の自動リリース受信 (優先度: P2) ユーザーとして、変更がmainブランチにマージされたときに新しいリリースが自動的に公開され、一貫したバージョン管理により常に最新の安定版にアクセスできるようにしたい。 この優先度の理由: 自動化により適時の更新が保証され、手動エラーが削減されます。一貫したバージョン管理により、ユーザーは変更を追跡し更新を計画できます。 独立テスト: mainへの変更をマージし、新しいリリースが自動的に作成されることを確認し、バージョン番号が正しくインクリメントされることを確認し、新しいリリースをダウンロードすることで完全にテストできます。継続的デリバリーの価値を独立して提供します。 受け入れシナリオ: 前提条件 プルリクエストがmainにマージされた、操作 マージが完了する、期待結果 手動介入なしで新しいGitHub Releaseが自動的に作成される 前提条件 新しいリリースがトリガーされた、操作 リリースを確認する、期待結果 セマンティックバージョニングに従ったバージョン番号（例: v1.2.3）がある 前提条件 mainへの複数のマージが発生した、操作 リリースを比較する、期待結果 バージョン番号が一貫してインクリメントされる（変更タイプに基づいてpatch、minor、またはmajor） 前提条件 リリースが作成された、操作 リリースノートをレビューする、期待結果 前回のリリース以降に含まれる変更の要約が表示される 前提条件 リリースを監視している、操作 新しいバージョンが公開される、期待結果 通知を購読して情報を得られる ユーザーストーリー 4 - カバレッジ付きですべての変更がテストされることの検証 (優先度: P2) プロジェクトメンテナーとして、リリース前にすべてのブランチがカバレッジレポート付きで自動的にテストされCodacyに報告されることで、品質基準が維持されることを確認したい。 この優先度の理由: 品質保証は、リリースされたバイナリへの信頼を維持するために不可欠です。自動テストにより回帰を防ぎます。 独立テスト: ブランチを作成し、変更をプッシュし、テストが自動的に実行されることを確認し、カバレッジがCodacyに報告されることを確認し、失敗したテストがリリースをブロックすることを確認することで完全にテストできます。品質保証を独立して提供します。 受け入れシナリオ: 前提条件 任意のブランチに変更をプッシュした、操作 プッシュが完了する、期待結果 すべてのテストが自動的に実行される 前提条件 テストが完了した、操作 Codacyを確認する、期待結果 カバレッジレポートが最新のデータで更新される 前提条件 ブランチでテストが失敗した、操作 mainへのマージを試みる、期待結果 テストが合格するまでマージがブロックされる 前提条件 カバレッジが閾値を下回った、操作 プルリクエストをレビューする、期待結果 カバレッジの低下を示す警告が表示される 前提条件 すべてのテストが合格しカバレッジが適切である、操作 mainへのマージが発生する、期待結果 リリースプロセスが自動的にトリガーされる エッジケース リリースプロセス中にビルドが失敗した場合どうなるか？（システムは不完全または失敗したビルドでリリースを作成してはならない） システムはプラットフォーム固有のビルド失敗をどのように処理するか？（必須プラットフォームのいずれかが失敗した場合はリリース全体を失敗させる。オプショナルプラットフォームの失敗は警告を生成するがリリースをブロックしない） カバレッジレポート中にCodacyが利用できない場合どうなるか?(システムは再試行するか、ビルドをブロックせずに明確なエラーメッセージを提供すべき。カバレッジ報告の失敗のみではリリースをブロックしない) 複数のマージが同時に発生した場合、バージョン競合はどのように解決されるか？（システムはマージ順序に基づいて順次バージョン管理を使用すべき） バイナリ署名やチェックサムが生成できない場合どうなるか？（システムはセキュリティ保証を維持するためにリリースを失敗させるべき） システムはGitHubリリースのサイズ制限を超える非常に大きなバイナリをどのように処理するか？（システムは必要に応じてバイナリを圧縮するか複数のアセットに分割すべき） ユーザーが間違ったプラットフォーム向けのバイナリをダウンロードした場合どうなるか？（システムはファイル名に明確な命名規則とプラットフォームインジケータを提供すべき。形式: <プロジェクト名>-<バージョン>-<プラットフォーム>-<アーキテクチャ>） バージョン番号で破壊的変更はどのように伝えられるか？（システムはメジャーバージョンのインクリメントで破壊的変更を示すセマンティックバージョニングに従うべき） 要件 (必須) 機能要件 FR-001: システムは変更がmainブランチにマージされたときに自動的にリリース作成をトリガーしなければならない FR-002: システムはサポートされているプラットフォーム向けのバイナリをビルドしなければならない。必須プラットフォーム: Windows (x64)、Linux x64 (Redhat系/Debian系)、Mac (ARM64)。オプショナルプラットフォーム: Linux ARM (Redhat系/Debian系)。必須プラットフォームのビルド失敗はリリースをブロックする FR-003: システムはすべてのバイナリアーティファクトのファイルハッシュ（SHA256）を生成しなければならない FR-004: システムは各バイナリのすべての依存関係を含むCycloneDX SBOM（ソフトウェア部品表）を生成しなければならない FR-005: システムはmainへのマージを許可する前に、すべてのブランチのすべてのテストを実行しなければならない FR-006: システムはすべてのブランチのテストカバレッジをCodacyに報告しなければならない。カバレッジ目標は80%とし、これを下回る場合は警告を表示する FR-007: システムはソースブランチでテストが失敗した場合、mainへのマージをブロックしなければならない。カバレッジ低下のみではマージをブロックしない FR-008: システムはGitHubホステッドランナーのみを使用しなければならない（セルフホステッドランナーは使用不可） FR-009: システムはすべてのビルド、テスト、リリース操作を手動介入なしで実行しなければならない FR-010: システムはすべてのリリースに一貫したセマンティックバージョニングを適用しなければならない。バージョンインクリメントはConventional Commits規約（feat:でminor、fix:でpatch、BREAKING CHANGE:でmajor）に基づいて自動的に決定される FR-011: システムはバイナリ、ハッシュファイル、SBOMファイルをGitHub Releaseアセットとして利用可能にしなければならない。バイナリ命名規則: <プロジェクト名>-<バージョン>-<プラットフォーム>-<アーキテクチャ>（例: wt-v1.2.3-windows-x64.exe, wt-v1.2.3-linux-x64, wt-v1.2.3-linux-arm64, wt-v1.2.3-darwin-arm64） FR-011a: システムはSBOMファイル（JSON）とSHA256SUMSファイルに対してデジタル署名を生成しなければならない。署名ファイル（.sig形式）もGitHub Releaseアセットとして公開される。注：バイナリ自体の署名は技術的制約により除外 FR-012: システムはリリースに含まれる前にバイナリがテストされていることを保証しなければならない FR-013: システムは前回のリリース以降の変更を要約したリリースノートを含めなければならない。リリースノートはConventional Commitsから自動生成され、機能追加(feat:)、バグ修正(fix:)、破壊的変更(BREAKING CHANGE:)等のカテゴリ別に整理される FR-014: システムは障害を適切に処理し、ワークフローログに明確なエラーメッセージを提供しなければならない FR-015: システムはすべてのリリースアーティファクトがGitHub Releasesから公開ダウンロード可能であることを保証しなければならない 主要エンティティ バイナリアーティファクト: 特定のプラットフォーム（Windows x64、Linux x64、Linux ARM、Mac ARM64）向けのコンパイル済み実行可能ファイルで、テスト済みで配布準備完了 ファイルハッシュ: 各バイナリアーティファクトのSHA256チェックサムで、完全性の検証と改ざんの検出に使用 SBOM（ソフトウェア部品表）: バイナリに含まれるすべての依存関係、バージョン、ライセンスを一覧表示するCycloneDX形式のドキュメント リリース: バイナリアーティファクト、ハッシュファイル、SBOMファイル、リリースノートのバージョン管理されたコレクションで、GitHub Releasesに公開される バージョン番号: リリースを一意に識別し変更の性質を示すセマンティックバージョン識別子（例: v1.2.3） カバレッジレポート: テスト中に収集されCodacyに報告される品質追跡用のテストカバレッジメトリクス GitHub Releaseアセット: ユーザーがダウンロードできるようGitHub Releaseに添付された個別のファイル（バイナリ、ハッシュ、SBOM） 明確化 (Clarifications) セッション 2026-01-04 Q: セマンティックバージョニング（major.minor.patch）において、システムはどのようにバージョン番号を自動的にインクリメントしますか？ → A: Conventional Commits（feat:, fix:, BREAKING CHANGE:）に基づいて自動判定 Q: 1つ以上のプラットフォームでビルドが失敗した場合、システムはどのように対応すべきですか？ → A: 必須プラットフォーム（Windows x64、Linux x64、Mac ARM64）は必須、他（Linux ARM）はオプショナル。必須プラットフォームのいずれかが失敗した場合はリリース全体を失敗させる Q: テストカバレッジの最小要件は何ですか?この閾値を下回った場合、mainへのマージはブロックされますか? → A: 80%のカバレッジ閾値を目標とし、低下時は警告を表示するがマージはブロックしない。継続的な品質改善を促進する Q: リリースノートはどのように生成されますか？ → A: Conventional Commitsから自動生成（feat/fix/BREAKING CHANGE等でカテゴリ分け） Q: リリースされるバイナリファイルの命名規則はどのようにしますか？ → A: 詳細形式「プロジェクト名-バージョン-プラットフォーム-アーキテクチャ」（例: wt-v1.2.3-windows-x64.exe, wt-v1.2.3-linux-x64, wt-v1.2.3-darwin-arm64） Q: CycloneDX SBOMのフォーマット（JSON/XML）はどちらを使用しますか？ → A: JSON形式を採用。理由：GitHub Actionsとの統合が容易、ユーザーによる自動解析が一般的、ファイルサイズが小さい## 成功基準 (必須) 測定可能な成果 SC-001: ユーザーはGitHub Releasesページに移動してから2分以内に自分のプラットフォーム向けの動作するバイナリをダウンロードできる SC-002: 100%のリリースに手動介入なしで完全なファイルハッシュとCycloneDX SBOMファイルが含まれる SC-003: リリースはmainへのマージから30分以内に人間の介入なしで公開される SC-004: すべてのバイナリはリリース前に自動テストに合格し、未テストのバイナリがユーザーに届くことはゼロ SC-005: テストカバレッジはマージ前に100%のブランチに対してCodacyに報告される。プロジェクト全体のカバレッジ目標は80%以上 SC-006: 95%のユーザーが提供されたハッシュファイルを使用して最初の試行でバイナリの完全性を正常に検証できる SC-007: バージョン番号はセマンティックバージョニングルールに従ってすべてのリリースで一貫してインクリメントされる SC-008: リリースプロセスでマージから公開まで手動ステップはゼロ SC-009: 必須プラットフォーム（3つのプラットフォーム: Windows x64、Linux x64、Mac ARM64）が100%のリリースでバイナリを受け取る。オプショナルプラットフォーム（Linux ARM）はベストエフォートベースで提供される SC-010: ユーザーはセキュリティ監査とコンプライアンスのためにSBOMファイルを通じて完全な依存関係情報にアクセスできる SC-010a: 100%のリリースでSBOMファイルとSHA256SUMSファイルに検証可能なデジタル署名が含まれ、改ざん検証が可能である SC-011: 失敗したビルドまたはテストはリリース作成を防ぎ、100%の品質ゲートコンプライアンスを維持する 前提条件と依存関係 前提条件 A-001: GitHub Actionsはすべてのプラットフォームビルドを同時に処理するのに十分な計算リソースと同時実行制限を持っている A-002: プロジェクトはConventional Commits規約に従ってコミットメッセージを記述し、セマンティックバージョニング原則を使用している。コミットメッセージ形式: <type>(<scope>): <subject>(type: feat, fix, docs, style, refactor, test, chore等)。リリースノートはこれらのコミットから自動生成される A-003: サポートされているすべてのプラットフォームは、プラットフォーム固有のソースコードブランチなしで単一のコードベースからビルドできる A-004: すべてのプラットフォームのバイナリサイズはGitHub Releaseアセットのサイズ制限内に収まる（ファイルあたり2GB、リリースあたり10GB） A-005: ユーザーはGitHub Releasesからのファイルダウンロードとチェックサム検証の基本的な知識を持っている A-006: ビルドプロセスはリリース前に確実にテストできる決定論的なバイナリを生成する A-007: CycloneDXツールが利用可能でプロジェクトの依存関係管理システムと互換性がある 依存関係 D-001: GitHub Actionsが適切な権限でリポジトリに対して有効化されている必要がある D-002: GitHub Releases機能がリポジトリで利用可能でアクセス可能である必要がある D-003: Codacyアカウントがカバレッジレポート用にリポジトリで設定され統合されている必要がある D-004: すべてのターゲットプラットフォーム向けのビルドツールとコンパイラがGitHubホステッドランナーで利用可能である必要がある D-005: CycloneDX SBOM生成ツールがプロジェクトの技術スタックで利用可能である必要がある D-006: mainへのマージ前にテスト成功を強制するマージ保護ルールが設定可能である必要がある D-007: リポジトリはmainブランチが安定したリリース可能なコードを表す明確なブランチ戦略を持っている必要がある"
  },
  "specs/003-automated-release-pipeline/tasks.html": {
    "href": "specs/003-automated-release-pipeline/tasks.html",
    "title": "Tasks: 自動化されたバイナリリリースパイプライン | wt",
    "summary": "Tasks: 自動化されたバイナリリリースパイプライン Feature: 001-automated-release-pipeline Date: 2026-01-04 Plan: plan.md | Spec: spec.md Task Workflow This feature is organized by user story (independent implementation and testing). Each phase must be completed and tested before moving to the next. Phases: Phase 0: Foundation - Build infrastructure and prerequisites Phase 1: P1 Stories - Core user stories (binary distribution + security) Phase 2: P2 Stories - Supporting stories (automation + quality) Phase 3: Integration & Polish - Cross-cutting concerns and final validation Phase 0: Foundation & Prerequisites Phase 0 establishes the base infrastructure needed by all user stories. Setup & Configuration [X] T001 Create GitHub Actions workflow directory structure in .github/workflows/ [X] T002 Create shell script directory in .github/scripts/ [X] T003 Create GitHub repository secrets configuration document (list required secrets: GH_RELEASE_TOKEN, CODACY_TOKEN, etc.) [X] T004 Document Conventional Commits naming convention in .github/ (for team reference) [X] T005 Create semantic versioning decision log in specs/001-automated-release-pipeline/research.md Dependency & Tool Verification [X] T006 Research and document CycloneDX integration options for .NET projects (dotnet-sbom, etc.) [X] T007 Research and document Conventional Commits parser options (semantic-release, commitlint, custom) [X] T008 Verify GitHub Actions concurrency limits for parallel platform builds [X] T009 Verify Codacy integration status and required workflow configuration [X] T010 Document platform-specific compiler availability in GitHub-hosted runners Phase 1: P1 Stories - Core Binary Distribution & Security User Story 1: Download and Install Compiled Binary This story delivers the ability to download pre-built binaries for each platform. Story Goal: Binaries are available on GitHub Releases for download, testable, and runnable on target platforms. Independent Test: Download a binary for each platform, verify it runs and displays version info. Build Infrastructure (Prerequisite for US1) Platform Matrix: Mandatory (Windows x64, Linux x64, Mac ARM64) - build failure blocks release. Optional (Linux ARM) - build failure logged but does not block release (see T078 for error handling). [X] T011 [P] Implement cross-platform build matrix in .github/workflows/build.yml (Windows x64, Linux x64, Linux ARM, Mac ARM64) with platform status tracking [X] T012 [P] Create .github/scripts/build-windows.sh to build Windows x64 binary (MANDATORY) [X] T013 [P] Create .github/scripts/build-linux-x64.sh to build Linux x64 binary (MANDATORY) [X] T014 [P] Create .github/scripts/build-linux-arm.sh to build Linux ARM binary (OPTIONAL - failure allowed) [X] T015 [P] Create .github/scripts/build-macos-arm64.sh to build Mac ARM64 binary (MANDATORY) [X] T016 [P] Update wt.cli.csproj to support multi-platform publishing (RID-specific builds) [ ] T017 Test local builds for all 4 platform combinations manually before workflow automation Binary Release to GitHub Releases [X] T018 Implement .github/workflows/release.yml to trigger on main branch push [X] T019 Add release workflow step to upload all platform binaries as GitHub Release assets [X] T020 Verify binary naming convention: wt-<version>-<platform>-<arch>.<ext> (e.g., wt-v1.0.0-windows-x64.exe) [ ] T021 Test release workflow: merge a PR to main and verify binaries appear on GitHub Releases [ ] T022 Document release manual download process in specs/001-automated-release-pipeline/quickstart.md User Story 2: Verify Software Supply Chain Security This story delivers file hashes and SBOM for binary integrity and dependency verification. Story Goal: Every release includes SHA256SUMS and CycloneDX SBOM files alongside binaries. Independent Test: Download SBOM, download checksum file, verify hash matches computed hash. Hash Generation [X] T023 Create .github/scripts/generate-checksums.sh to compute SHA256 hashes for all binaries [X] T024 Add workflow step in build.yml to generate SHA256SUMS file after all builds complete [X] T025 Upload SHA256SUMS file to GitHub Release as asset [ ] T026 Test hash generation: verify downloaded binary hash matches SHA256SUMS entry SBOM Generation [X] T027 Integrate CycloneDX tool into build workflow (research result from Phase 0 used here) [X] T028 Create .github/scripts/generate-sbom.sh to generate CycloneDX SBOM for binary [X] T029 Add workflow step in build.yml to generate SBOM for each platform build [X] T030 Generate single aggregated SBOM listing all dependencies across platforms [X] T031 Upload aggregated SBOM (JSON format) to GitHub Release as asset [ ] T032 Test SBOM: download and verify SBOM contains expected dependency list Digital Signature Generation [X] T032a Research and select signature tool (GPG, cosign, or GitHub Actions built-in) during Phase 0 [X] T032b Create .github/scripts/sign-artifacts.sh to generate signatures for SBOM and SHA256SUMS files [X] T032c Add workflow step in build.yml to sign SBOM.json and SHA256SUMS files after generation [X] T032d Upload signature files (SBOM.json.sig, SHA256SUMS.sig) to GitHub Release as assets [ ] T032e Test signature generation: verify signature files are present and properly formatted [ ] T032f Document signature verification process in quickstart.md (public key distribution, verification command) Supply Chain Documentation [X] T033 Add file hash verification instructions to quickstart.md [X] T034 Add SBOM interpretation guide to quickstart.md [X] T035 Create ADR (Architecture Decision Record) explaining SBOM format choice (CycloneDX JSON/XML) and signature tool selection [X] T035a Add signature verification guide to quickstart.md (download .sig files, verify with public key) Phase 2: P2 Stories - Automation & Quality Assurance User Story 3: Receive Automated Releases on Main Branch Merge This story delivers automatic version management and release notes. Story Goal: Releases are published automatically with correct version numbers and descriptive notes when PR merges to main. Independent Test: Merge a feature PR to main, verify release is created with incremented version and release notes. Version Management [X] T036 Implement version number parsing from latest Git tag [X] T037 Create .github/scripts/calculate-version.sh to determine next version based on Conventional Commits [X] T038 Implement logic: feat: → minor, fix: → patch, BREAKING CHANGE: → major [X] T039 Add workflow step to create Git tag for new version [ ] T040 Test version calculation: commit feat/fix/BREAKING CHANGE and verify version increments correctly Release Notes Generation [X] T041 Create .github/scripts/generate-release-notes.sh to extract Conventional Commits since last tag [X] T042 Implement categorization: features (feat:), fixes (fix:), breaking changes (BREAKING CHANGE:) [X] T043 Add workflow step to generate release notes and include in GitHub Release body [ ] T044 Test release notes: verify notes accurately reflect commits since last release Release Workflow Automation [X] T045 Update release.yml workflow to automatically trigger on main push (not manual) [X] T046 Add version calculation and git tag creation to release workflow [X] T047 Add release notes generation to release workflow [ ] T048 Verify release appears on GitHub Releases within 30 minutes of main merge [ ] T049 Test release end-to-end: merge PR to main, monitor workflow, verify release created Release Documentation [X] T050 Document versioning strategy in ADR (Conventional Commits → SemVer) [X] T051 Add release notification setup guide to quickstart.md User Story 4: Verify All Changes Are Tested with Coverage This story delivers automated testing, coverage reporting, and quality gates. Story Goal: All branches are tested, coverage is reported to Codacy, and failures block main merges. Independent Test: Create feature branch, push failing test, verify merge is blocked; push passing test, verify merge is allowed and Codacy reports coverage. Test Automation on All Branches [X] T052 Create .github/workflows/test.yml to run all tests on every push/PR [X] T053 Add test execution step to run dotnet test with code coverage collection [X] T054 Configure test failure reporting (exit code check) [ ] T055 Add branch protection rule: require passing tests before main merge [ ] T056 Test: push failing test to feature branch, verify CI fails and merge is blocked Coverage Reporting to Codacy [ ] T057 Add Codacy token secret configuration in GitHub repository settings [X] T058 Integrate Codacy coverage upload in test.yml workflow [ ] T059 Configure coverage threshold: 80% project-wide goal (from spec) [X] T060 Add coverage report comment on pull requests [ ] T061 Test: push change with coverage drop, verify Codacy warning appears on PR Quality Gates [ ] T062 Configure Codacy check to warn (not block) on coverage below 80% [ ] T063 Configure test failure check to block merge [X] T064 Document quality gate policy in ADR [ ] T065 Test: verify test failure blocks merge, coverage drop shows warning but allows merge Release Trigger on Quality Gate Pass [X] T066 Update release.yml to run only if test workflow succeeds [X] T067 Add check: all required status checks passed before release [ ] T068 Test: merge PR to main with failing tests, verify release is NOT triggered [ ] T069 Test: merge PR to main with passing tests, verify release IS triggered Release Performance SLA Configuration [X] T048a Configure GitHub Actions job timeout in release.yml to 25 minutes (buffer before 30-minute SLA from SC-003) [X] T048b Document timeout rationale in ADR (5-minute buffer for cleanup, upload finalization) [ ] T048c Test: verify workflow kills gracefully at timeout and logs clear error message Testing Documentation [ ] T070 Document testing requirements in quickstart.md [ ] T071 Document Codacy integration in quickstart.md [X] T072 Create testing ADR explaining TDD expectations and coverage goals Phase 3: Integration & Polish Cross-Cutting Concerns [ ] T073 [P] Create comprehensive testing guide for workflow validation (manual test scenarios) [ ] T074 [P] Document troubleshooting guide for common workflow failures [ ] T075 [P] Create workflow status monitoring dashboard documentation [ ] T076 [P] Implement error logging/reporting from all shell scripts Error Handling & Robustness [X] T077 Add retry logic to Codacy upload (transient failure handling) [X] T078 Add graceful failure if optional platform build fails (log warning, skip asset) [X] T079 Add graceful failure if SBOM generation fails (fail release - security critical) [ ] T080 Test error scenarios: simulate Codacy outage, simulate single platform failure Documentation & Handoff [X] T081 Complete research.md with all Phase 0 research findings [X] T082 Complete data-model.md with release pipeline data model (versions, tags, releases) [X] T083 Complete contracts/ directory with detailed workflow specifications [X] T084 Complete quickstart.md with end-to-end user journey walkthrough [X] T085 Create troubleshooting guide in specs/001-automated-release-pipeline/troubleshooting.md Final Validation & Testing [ ] T086 End-to-end test: create feature branch with test + code, push, verify all workflows run [ ] T087 End-to-end test: merge to main, verify release created with version/notes/binaries/hashes/sbom [ ] T088 Verify all 4 platform binaries present in release [ ] T089 Verify SHA256SUMS file is present and checksums are correct [ ] T090 Verify SBOM file is present and contains expected dependencies [ ] T091 Manual download test: download each binary, verify it runs and shows version [ ] T092 Verify release notes are accurate and well-formatted [ ] T093 Performance test: measure time from main merge to release availability (goal: < 30 min) [ ] T094 Performance test: measure binary download time (goal: < 2 min for typical connection) [ ] T095 Security test: verify no secrets leaked in workflows or scripts [ ] T096 Accessibility test: verify documentation is clear for new developers Task Execution Strategy Phase 0 (Foundation) Duration: ~1 week Parallelization: T001-T005 can run in parallel, followed by T006-T010 in parallel Blocking: Phase 1 blocks on Phase 0 completion Phase 1 (P1 Stories) Duration: ~2 weeks Parallelization: Build infrastructure (T011-T017) can run in parallel across platforms Hash generation (T023-T026) and SBOM generation (T027-T032) can run in parallel Documentation (T033-T035) can run in parallel Phase 2 (P2 Stories) Duration: ~2 weeks Parallelization: Version management (T036-T040) and release notes (T041-T044) can run in parallel Test automation (T052-T056) and coverage reporting (T057-T061) can run in parallel Quality gates (T062-T065) are sequential (depend on earlier steps) Phase 3 (Integration & Polish) Duration: ~1 week Parallelization: T073-T076 can run in parallel, followed by T077-T080, then final validation (T086-T096) Total Estimated Timeline ~6 weeks with efficient parallelization and team coordination Dependency Map Phase 0: Foundation (T001-T010) ↓ Phase 1a: Build Infrastructure (T011-T017) ├→ Phase 1b: Release to GitHub (T018-T022) ├→ Phase 1c: Hash & SBOM (T023-T035) ↓ Phase 2a: Version Management (T036-T040) ├→ Phase 2b: Release Notes (T041-T044) ├→ Phase 2c: Test Automation (T052-T056) ├→ Phase 2d: Coverage Reporting (T057-T061) ├→ Phase 2e: Quality Gates (T062-T065) ├→ Phase 2f: Release Trigger (T066-T069) ↓ Phase 3: Integration & Polish (T073-T096) Success Criteria per Phase Phase 0: All prerequisites verified, research completed, team ready Phase 1: Binaries downloadable, hashes verifiable, SBOM accessible Phase 2: Releases automatic, version increments correct, quality gates enforced Phase 3: All workflows robust, documentation complete, end-to-end validated"
  },
  "specs/003-automated-release-pipeline/testing-guide.html": {
    "href": "specs/003-automated-release-pipeline/testing-guide.html",
    "title": "Testing Guide: Automated Binary Release Pipeline | wt",
    "summary": "Testing Guide: Automated Binary Release Pipeline Feature: 003-automated-release-pipeline Date: 2026-01-05 Related: spec.md, quickstart.md このガイドは、自動化されたバイナリリリースパイプラインのテスト方法を説明します。 \uD83D\uDCCB テスト概要 テスト対象 ビルドプロセス: 全プラットフォームのバイナリ生成 バージョン計算: Conventional Commitsベースの自動バージョニング リリースノート生成: コミット履歴からの自動生成 ハッシュ生成: SHA256チェックサム計算 SBOM生成: CycloneDX形式のSBOM作成 デジタル署名: GPG署名の生成と検証 GitHub Release作成: Release APIへのアップロード テスト自動化: 全ブランチでのテスト実行 カバレッジ報告: Codacy連携 テスト戦略 Phase 1 Tests: ビルドとリリースの基本機能 (T017, T021-T022, T026, T032, T032e-f) Phase 2 Tests: バージョン計算とテスト自動化 (T040, T044, T048-T049, T055-T056) Phase 3 Tests: エンドツーエンド統合テスト (T086-T096) \uD83E\uDDEA Phase 1: ビルドとリリースの基本テスト T017: ローカルビルドテスト 目的: 全プラットフォームのビルドスクリプトが正常に動作することを確認 手順: # 1. Windows x64ビルド cd /Users/kuriharajun/project/wt .github/scripts/build-windows.sh \"v0.1.0-test\" \"win-x64\" # 期待される出力: release-assets/wt-v0.1.0-test-windows-x64.exe # 2. Linux x64ビルド .github/scripts/build-linux-x64.sh \"v0.1.0-test\" \"linux-x64\" # 期待される出力: release-assets/wt-v0.1.0-test-linux-x64 # 3. Linux ARMビルド (オプション) .github/scripts/build-linux-arm.sh \"v0.1.0-test\" \"linux-arm\" # 期待される出力: release-assets/wt-v0.1.0-test-linux-arm (失敗しても問題なし) # 4. macOS ARM64ビルド .github/scripts/build-macos-arm64.sh \"v0.1.0-test\" \"osx-arm64\" # 期待される出力: release-assets/wt-v0.1.0-test-macos-arm64 検証: # バイナリが生成されたことを確認 ls -lh release-assets/ # 各バイナリが実行可能であることを確認 (Linux/macOS) chmod +x release-assets/wt-*-linux-* chmod +x release-assets/wt-*-macos-* # バージョン情報を表示 (実装されている場合) ./release-assets/wt-v0.1.0-test-linux-x64 --version 成功基準: ✅ Windows, Linux x64, macOS ARM64バイナリが生成される (MANDATORY) ✅ 各バイナリが実行可能で、エラーなく起動する ⚠️ Linux ARMビルドは失敗してもよい (OPTIONAL) T021-T022: リリースワークフローテストとドキュメント 目的: mainブランチへのマージでリリースが自動作成されることを確認 手順: # 1. テスト用ブランチを作成 git checkout -b test/release-workflow-001 # 2. 軽微な変更をコミット echo \"# Test Release\" >> README.md git add README.md git commit -m \"test: verify release workflow automation\" # 3. リモートにプッシュ git push origin test/release-workflow-001 # 4. GitHubでプルリクエストを作成 gh pr create --title \"test: release workflow\" --body \"Testing automated release creation\" # 5. PRをmainにマージ gh pr merge --squash --delete-branch # 6. GitHub Actionsワークフローを監視 gh run watch 検証: # リリースが作成されたことを確認 gh release list # 最新リリースの詳細を確認 gh release view --web 期待される結果: ✅ mainマージから30分以内にリリースが作成される ✅ リリースに全プラットフォームのバイナリが含まれる ✅ SHA256SUMS、SBOM、署名ファイルが含まれる ✅ リリースノートが自動生成される ドキュメント更新 (T022): quickstart.mdに以下を追加: リリース作成フローの説明 手動ダウンロード手順 トラブルシューティング T026: ハッシュ生成テスト 目的: SHA256チェックサムが正しく生成されることを確認 手順: # 1. テスト用バイナリを作成 mkdir -p test-assets echo \"test binary content\" > test-assets/wt-v0.1.0-test-linux-x64 # 2. チェックサムを生成 .github/scripts/generate-checksums.sh test-assets/ # 3. SHA256SUMSファイルを確認 cat test-assets/SHA256SUMS 検証: # ハッシュ値を手動計算して比較 sha256sum test-assets/wt-v0.1.0-test-linux-x64 # SHA256SUMSファイルを使って検証 cd test-assets sha256sum -c SHA256SUMS --ignore-missing 期待される結果: ✅ SHA256SUMSファイルが生成される ✅ 各バイナリのハッシュ値が正しい ✅ sha256sum -cコマンドで検証成功 T032: SBOMテスト 目的: CycloneDX SBOMが正しく生成されることを確認 手順: # 1. GitHub Actionsワークフローを実行してSBOMを生成 # (ローカルでSBOM生成をテストする場合) # Syftをインストール (Anchore SBOM Action の代替) brew install syft # macOS # または curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin # 2. SBOMを生成 syft packages dir:./wt.cli -o cyclonedx-json > test-sbom.json # 3. SBOMの内容を確認 cat test-sbom.json | jq . 検証: # 依存関係の数を確認 jq '.components | length' test-sbom.json # 主要な依存関係を確認 jq '.components[].name' test-sbom.json | grep -E 'System.CommandLine|Microsoft' # SBOM形式が正しいことを確認 jq '.bomFormat' test-sbom.json # 期待値: \"CycloneDX\" jq '.specVersion' test-sbom.json # 期待値: \"1.4\" または \"1.5\" 期待される結果: ✅ SBOM JSONファイルが生成される ✅ .bomFormatが\"CycloneDX\"である ✅ .componentsに依存関係が含まれる (.NET SDKなど) T032e-f: デジタル署名テストとドキュメント 目的: GPG署名が正しく生成・検証できることを確認 前提条件: # GPGキーペアを生成 (テスト用) gpg --batch --gen-key <<EOF %no-protection Key-Type: RSA Key-Length: 4096 Name-Real: Test Release Bot Name-Email: test-release@example.com Expire-Date: 0 %commit EOF # 秘密鍵をエクスポート gpg --armor --export-secret-keys test-release@example.com > test-gpg-private.asc # 公開鍵をエクスポート gpg --armor --export test-release@example.com > test-gpg-public.asc 手順 (T032e): # 1. テストファイルを作成 echo \"test content\" > test-file.txt # 2. 署名を生成 gpg --armor --detach-sign test-file.txt # 3. 署名ファイルを確認 ls -lh test-file.txt.asc cat test-file.txt.asc 検証: # 署名を検証 gpg --verify test-file.txt.asc test-file.txt # 期待される出力: # gpg: Signature made ... # gpg: Good signature from \"Test Release Bot <test-release@example.com>\" 期待される結果: ✅ .asc署名ファイルが生成される ✅ GPG署名が有効である ✅ 署名検証が成功する ドキュメント更新 (T032f): quickstart.mdに以下を追加: ### 署名検証プロセス 1. 公開鍵をインポート: \\`\\`\\`bash curl -fsSL https://raw.githubusercontent.com/kuju63/wt/main/docs/GPG_PUBLIC_KEY.asc | gpg --import \\`\\`\\` 2. SBOM署名を検証: \\`\\`\\`bash gpg --verify wt-v1.0.0-sbom.json.asc wt-v1.0.0-sbom.json \\`\\`\\` 3. チェックサム署名を検証: \\`\\`\\`bash gpg --verify SHA256SUMS.asc SHA256SUMS \\`\\`\\` \uD83E\uDDEA Phase 2: バージョン計算とテスト自動化 T040: バージョン計算テスト 目的: Conventional Commitsに基づくバージョンインクリメントが正しく動作することを確認 手順: # 1. 最新タグを確認 git describe --tags --abbrev=0 # 2. feat: コミット (MINOR bump) git checkout -b test/version-minor echo \"# New Feature\" >> docs/test.md git add docs/test.md git commit -m \"feat: add new amazing feature\" git push origin test/version-minor # 3. PRを作成してマージ gh pr create --title \"feat: new feature\" --body \"Test MINOR version bump\" gh pr merge --squash --delete-branch # 4. リリースを確認 gh release list # 5. fix: コミット (PATCH bump) git checkout -b test/version-patch echo \"# Bug Fix\" >> docs/test.md git add docs/test.md git commit -m \"fix: resolve critical bug\" git push origin test/version-patch # 6. PRを作成してマージ gh pr create --title \"fix: bug fix\" --body \"Test PATCH version bump\" gh pr merge --squash --delete-branch # 7. リリースを確認 gh release list # 8. BREAKING CHANGE: コミット (MAJOR bump) git checkout -b test/version-major echo \"# Breaking Change\" >> docs/test.md git add docs/test.md git commit -m \"feat: change API format BREAKING CHANGE: All CLI arguments now use kebab-case. Migration guide: docs/migration/v2.0.md\" git push origin test/version-major # 9. PRを作成してマージ gh pr create --title \"feat: breaking change\" --body \"Test MAJOR version bump\" gh pr merge --squash --delete-branch # 10. リリースを確認 gh release list 期待される結果: ✅ feat: → MINORバージョン増加 (例: v0.5.0 → v0.6.0) ✅ fix: → PATCHバージョン増加 (例: v0.6.0 → v0.6.1) ✅ BREAKING CHANGE: → MAJORバージョン増加 (例: v0.6.1 → v1.0.0) ✅ docs:, chore: → バージョン変更なし T044: リリースノートテスト 目的: リリースノートが正しく生成されることを確認 手順: # 1. 複数のコミットタイプを含むPRを作成 git checkout -b test/release-notes git commit --allow-empty -m \"feat: add feature A\" git commit --allow-empty -m \"fix: resolve bug B\" git commit --allow-empty -m \"docs: update README\" git push origin test/release-notes # 2. PRをマージ gh pr create --title \"test: release notes\" --body \"Test release notes generation\" gh pr merge --squash --delete-branch # 3. リリースノートを確認 gh release view --web 期待されるリリースノート形式: ## Features - add feature A ## Bug Fixes - resolve bug B ## Documentation - update README 検証: ✅ feat:コミットが「Features」セクションに表示される ✅ fix:コミットが「Bug Fixes」セクションに表示される ✅ BREAKING CHANGE:が強調表示される ✅ docs:, chore:コミットは除外される (またはOther Changesセクション) T048-T049: リリース自動化のエンドツーエンドテスト 目的: mainマージからリリース作成まで の全フローが正常に動作することを確認 手順: # 1. テスト用ブランチを作成 git checkout -b test/e2e-release echo \"# E2E Test\" >> docs/test-e2e.md git add docs/test-e2e.md git commit -m \"feat: end-to-end release test\" git push origin test/e2e-release # 2. PRを作成 gh pr create --title \"feat: E2E test\" --body \"Testing full release pipeline\" # 3. GitHub Actionsを監視 gh pr checks --watch # 4. テストが成功したらマージ gh pr merge --squash --delete-branch # 5. リリースワークフローを監視 gh run watch # 6. リリースが作成されるまで待機 (最大30分) timeout 1800 bash -c 'until gh release list | grep -q \"v\"; do sleep 30; done' # 7. リリースを確認 gh release view --web 検証: # リリースアセットを確認 gh release view --json assets -q '.assets[].name' # 期待されるファイル: # - wt-v<version>-windows-x64.exe # - wt-v<version>-linux-x64 # - wt-v<version>-linux-arm (オプション) # - wt-v<version>-macos-arm64 # - wt-v<version>-sbom.json # - wt-v<version>-sbom.json.asc # - SHA256SUMS # - SHA256SUMS.asc 性能検証 (SC-003): # mainマージ時刻を取得 MERGE_TIME=$(git log -1 --format=%ct origin/main) # リリース作成時刻を取得 RELEASE_TIME=$(gh release view --json publishedAt -q '.publishedAt' | date -j -f \"%Y-%m-%dT%H:%M:%SZ\" \"+%s\") # 経過時間を計算 (秒) DURATION=$((RELEASE_TIME - MERGE_TIME)) echo \"Release duration: ${DURATION} seconds ($((DURATION / 60)) minutes)\" # 30分 (1800秒) 以内であることを確認 if [ $DURATION -le 1800 ]; then echo \"✅ PASS: Release published within 30 minutes\" else echo \"❌ FAIL: Release took longer than 30 minutes\" fi 期待される結果: ✅ mainマージから30分以内にリリースが作成される ✅ 全必須プラットフォームのバイナリが含まれる ✅ SHA256SUMS、SBOM、署名ファイルが含まれる ✅ リリースノートが正しく生成される T055-T056: ブランチプロテクションとテスト自動化 目的: テスト失敗時にmainへのマージがブロックされることを確認 手順: # 1. テスト失敗を含むブランチを作成 git checkout -b test/failing-tests # 2. 意図的にテストを失敗させる # (例: wt.tests/SampleTest.cs に失敗するテストを追加) cat <<EOF >> wt.tests/FailingTest.cs using Xunit; namespace wt.tests { public class FailingTest { [Fact] public void ThisTestShouldFail() { Assert.True(false, \"Intentional test failure\"); } } } EOF git add wt.tests/FailingTest.cs git commit -m \"test: add intentionally failing test\" git push origin test/failing-tests # 3. PRを作成 gh pr create --title \"test: failing tests\" --body \"Testing branch protection with failing tests\" # 4. GitHub Actionsを監視 gh pr checks --watch # 5. テストが失敗することを確認 gh pr checks # 6. マージを試みる (失敗するはず) gh pr merge --squash --delete-branch # 期待されるエラー: \"Required status check 'Test and Coverage / Run Tests' is failing\" 検証: ✅ テストが失敗したPRはマージできない ✅ PRに「❌ Test and Coverage / Run Tests」が表示される ✅ GitHub UIで「Merge」ボタンが無効になる 修正して再テスト: # 7. 失敗するテストを削除 git rm wt.tests/FailingTest.cs git commit -m \"test: remove failing test\" git push origin test/failing-tests # 8. テストが成功することを確認 gh pr checks --watch # 9. マージが許可されることを確認 gh pr merge --squash --delete-branch 期待される結果: ✅ テスト失敗でマージブロック ✅ テスト成功でマージ許可 \uD83E\uDDEA Phase 3: エンドツーエンド統合テスト T086-T087: 完全なリリースフローテスト 目的: 機能ブランチ作成からリリース公開までの全フローを検証 手順: # 1. 機能ブランチを作成 git checkout -b feature/complete-e2e-test # 2. 新機能を実装 (簡易版) echo \"// New feature implementation\" >> wt.cli/Program.cs git add wt.cli/Program.cs git commit -m \"feat: implement complete E2E test feature\" # 3. テストを追加 echo \"// Test for new feature\" >> wt.tests/E2ETest.cs git add wt.tests/E2ETest.cs git commit -m \"test: add E2E test for new feature\" # 4. リモートにプッシュ git push origin feature/complete-e2e-test # 5. PRを作成 gh pr create --title \"feat: complete E2E test\" --body \"Testing full pipeline from feature to release\" # 6. テストワークフローを監視 gh pr checks --watch # 7. テストが成功したらマージ gh pr merge --squash --delete-branch # 8. リリースワークフローを監視 gh run watch # 9. リリースを確認 gh release view 検証ポイント (T086): ✅ テストワークフローが自動実行される ✅ カバレッジがCodacyにアップロードされる ✅ テスト成功後にマージが許可される 検証ポイント (T087): ✅ mainマージ後にリリースワークフローが自動実行される ✅ 正しいバージョン番号が計算される ✅ リリースノートにfeat:コミットが含まれる ✅ 全プラットフォームのバイナリが生成される ✅ ハッシュ、SBOM、署名ファイルが含まれる T088-T090: リリースアセット検証 目的: リリースに含まれる全アセットが正しいことを確認 手順: # 最新リリースのアセットをダウンロード LATEST_RELEASE=$(gh release list --limit 1 | awk '{print $1}') gh release download \"$LATEST_RELEASE\" # ファイル一覧を確認 ls -lh # 期待されるファイル: # - wt-v<version>-windows-x64.exe # - wt-v<version>-linux-x64 # - wt-v<version>-linux-arm (オプション) # - wt-v<version>-macos-arm64 # - wt-v<version>-sbom.json # - wt-v<version>-sbom.json.asc # - SHA256SUMS # - SHA256SUMS.asc T088: 全プラットフォームバイナリ確認: # Windows x64 file wt-v*-windows-x64.exe # PE32+ executable # Linux x64 file wt-v*-linux-x64 # ELF 64-bit LSB executable, x86-64 # Linux ARM (オプション) file wt-v*-linux-arm # ELF 32-bit LSB executable, ARM # macOS ARM64 file wt-v*-macos-arm64 # Mach-O 64-bit arm64 executable T089: SHA256SUMS検証: # チェックサムファイルを確認 cat SHA256SUMS # GPG署名を検証 gpg --verify SHA256SUMS.asc SHA256SUMS # ハッシュ値を検証 sha256sum -c SHA256SUMS --ignore-missing T090: SBOM検証: # SBOMファイルを確認 cat wt-v*-sbom.json | jq . # GPG署名を検証 gpg --verify wt-v*-sbom.json.asc wt-v*-sbom.json # SBOM形式を確認 jq '.bomFormat' wt-v*-sbom.json # \"CycloneDX\" jq '.specVersion' wt-v*-sbom.json # \"1.4\" または \"1.5\" # 依存関係を確認 jq '.components[].name' wt-v*-sbom.json 期待される結果: ✅ 全バイナリが正しい形式である ✅ SHA256SUMSのハッシュ値が一致する ✅ GPG署名が有効である ✅ SBOMにCycloneDX形式で依存関係が含まれる T091: 手動ダウンロードテスト 目的: ユーザー視点でバイナリのダウンロードと実行が正常に行えることを確認 手順 (各プラットフォーム): Windows: # PowerShellでダウンロード $LATEST = (gh release list --limit 1 | Select-String -Pattern \"v\\d+\\.\\d+\\.\\d+\").Matches.Value gh release download $LATEST --pattern \"wt-*-windows-x64.exe\" # 実行 .\\wt-*-windows-x64.exe --version Linux x64: # ダウンロード LATEST=$(gh release list --limit 1 | awk '{print $1}') gh release download \"$LATEST\" --pattern \"wt-*-linux-x64\" # 実行権限を付与 chmod +x wt-*-linux-x64 # 実行 ./wt-*-linux-x64 --version macOS ARM64: # ダウンロード LATEST=$(gh release list --limit 1 | awk '{print $1}') gh release download \"$LATEST\" --pattern \"wt-*-macos-arm64\" # 実行権限を付与 chmod +x wt-*-macos-arm64 # 実行 ./wt-*-macos-arm64 --version 期待される結果: ✅ 各プラットフォームでバイナリがダウンロードできる ✅ バイナリが実行可能である ✅ --versionフラグでバージョン情報が表示される T092: リリースノート検証 目的: リリースノートが正確でフォーマットが適切であることを確認 手順: # リリースノートを確認 gh release view --json body -q .body 検証ポイント: ✅ ## Featuresセクションにfeat:コミットが含まれる ✅ ## Bug Fixesセクションにfix:コミットが含まれる ✅ ## Breaking ChangesセクションにBREAKING CHANGE:コミットが含まれる ✅ Markdown形式が正しい ✅ コミットメッセージが読みやすく整形されている T093: 性能テスト 目的: リリース作成がSLA (30分) 以内に完了することを確認 手順: # スクリプトを作成: test-performance.sh cat > test-performance.sh <<'EOF' #!/bin/bash set -e # mainブランチの最新コミット時刻を取得 COMMIT_TIME=$(git log -1 --format=%ct origin/main) # 最新リリースの作成時刻を取得 RELEASE_TIME=$(gh release list --limit 1 --json publishedAt -q '.[0].publishedAt') RELEASE_TIMESTAMP=$(date -j -f \"%Y-%m-%dT%H:%M:%SZ\" \"$RELEASE_TIME\" \"+%s\" 2>/dev/null || date -d \"$RELEASE_TIME\" \"+%s\") # 経過時間を計算 DURATION=$((RELEASE_TIMESTAMP - COMMIT_TIME)) MINUTES=$((DURATION / 60)) echo \"\uD83D\uDCCA Performance Test Results:\" echo \" Commit time: $(date -r $COMMIT_TIME)\" echo \" Release time: $(date -r $RELEASE_TIMESTAMP)\" echo \" Duration: ${MINUTES} minutes (${DURATION} seconds)\" echo \"\" # SLA検証 (30分 = 1800秒) if [ $DURATION -le 1800 ]; then echo \"✅ PASS: Release published within 30 minutes (SLA: SC-003)\" exit 0 else echo \"❌ FAIL: Release took longer than 30 minutes (SLA violation)\" exit 1 fi EOF chmod +x test-performance.sh ./test-performance.sh 期待される結果: ✅ リリース作成が30分以内に完了する (SC-003) ✅ 平均リリース時間が20分以下である (80%ルール) T094: バイナリダウンロード性能テスト 目的: バイナリのダウンロードが2分以内に完了することを確認 (SC-004) 手順: # ダウンロード性能テスト time gh release download $(gh release list --limit 1 | awk '{print $1}') --pattern \"wt-*-linux-x64\" # 期待される結果: real < 2m0.000s 期待される結果: ✅ バイナリダウンロードが2分以内に完了する (典型的な接続環境) T095: セキュリティテスト 目的: ワークフローやスクリプトでシークレットが漏洩していないことを確認 手順: # ワークフローログを確認 (シークレットがマスクされていることを確認) gh run view --log | grep -i \"secret\\|token\\|password\\|key\" # 期待される結果: すべてのシークレットが `***` でマスクされている 検証ポイント: ✅ GPG_PRIVATE_KEYが漏洩していない ✅ GPG_PASSPHRASEが漏洩していない ✅ CODACY_PROJECT_TOKENが漏洩していない ✅ GITHUB_TOKENが漏洩していない セキュリティチェックリスト: # リポジトリ内でシークレットの痕跡を検索 git grep -i \"BEGIN.*PRIVATE KEY\" # 期待: ヒットなし (テスト用キー除く) git grep -i \"ghp_\" # GitHub Personal Access Token形式 git grep -i \"sk_live\" # Stripe等のAPIキー形式 T096: アクセシビリティテスト 目的: ドキュメントが新規開発者にとって明確であることを確認 手順: 新規開発者視点でドキュメントをレビュー: quickstart.md: リリースのダウンロードと検証手順が明確か research.md: 技術的決定の背景が理解できるか ADR文書: 決定理由が明確に記録されているか ドキュメントのチェックリスト: ✅ 専門用語に説明がある ✅ コマンド例が実行可能である ✅ 前提条件が明記されている ✅ トラブルシューティングセクションがある ✅ 日本語ドキュメントが提供されている 期待される結果: ✅ 新規開発者がドキュメントを読んで理解できる ✅ 手順が明確で実行可能である ✅ トラブルシューティング情報が充実している \uD83D\uDCCA テスト結果の記録 テストレポート形式 各テスト完了後、以下の形式で結果を記録: ## Test Report: T<番号> **Date**: 2026-01-05 **Tester**: [名前] **Status**: ✅ PASS / ❌ FAIL / ⚠️ PARTIAL **Details**: - [テスト手順と結果] **Issues**: - [発見された問題] **Follow-up**: - [必要なフォローアップアクション] テスト完了基準 ✅ 全Phase 1テストが成功 ✅ 全Phase 2テストが成功 ✅ 全Phase 3テストが成功 ✅ セキュリティテストが成功 ✅ 性能テストがSLAを満たす ✅ アクセシビリティテストが成功 \uD83D\uDD17 関連ドキュメント spec.md: 仕様書 quickstart.md: クイックスタートガイド troubleshooting.md: トラブルシューティングガイド ADR 0002: SBOM形式とデジタル署名の選択 ADR 0003: セマンティックバージョニング戦略 ADR 0004: リリースワークフローのタイムアウトとSLA ADR 0005: 品質ゲートとテスト要件"
  },
  "specs/003-automated-release-pipeline/troubleshooting.html": {
    "href": "specs/003-automated-release-pipeline/troubleshooting.html",
    "title": "Troubleshooting Guide: Automated Binary Release Pipeline | wt",
    "summary": "Troubleshooting Guide: Automated Binary Release Pipeline Feature: 003-automated-release-pipeline Date: 2026-01-05 Related: spec.md, quickstart.md, testing-guide.md このガイドは、自動化されたバイナリリリースパイプラインで発生する一般的な問題の解決方法を説明します。 \uD83D\uDCCB 目次 ビルド失敗 リリース失敗 バージョン計算の問題 テスト失敗 カバレッジ報告の問題 SBOM生成の問題 デジタル署名の問題 性能問題とタイムアウト GitHub Actions の問題 ビルド失敗 問題: プラットフォーム固有のビルドが失敗する 症状: Error: Build failed for linux-arm ##[error]The process '/usr/bin/bash' failed with exit code 1 原因: 必須プラットフォーム (Windows x64, Linux x64, macOS ARM64) のビルド失敗 → リリース全体が失敗 オプションプラットフォーム (Linux ARM) のビルド失敗 → 警告のみ、リリース続行 解決方法: ビルドログを確認: gh run view <run-id> --log | grep -A 50 \"Build.*failed\" ローカルでビルドを再現: # 問題のプラットフォームでビルドを試行 .github/scripts/build-linux-arm.sh \"v0.1.0-test\" \"linux-arm\" 一般的な原因と対処: 原因 対処方法 .NET SDKバージョン不一致 .github/workflows/build.ymlのdotnet-versionを確認 依存関係の解決失敗 dotnet restoreを実行して依存関係を確認 RID (Runtime Identifier) 誤り wt.cli.csprojの<RuntimeIdentifier>を確認 ディスク容量不足 GitHub Actions runnerのディスク使用量を確認 オプションプラットフォームの失敗を無視: Linux ARMはオプションなので、失敗しても問題ありません: # .github/workflows/build.yml matrix: include: - platform: linux arch: arm mandatory: false # 失敗許容 問題: すべてのプラットフォームでビルドが失敗する 症状: Error: dotnet restore failed NuGet package restore failed 原因: NuGetパッケージの依存関係解決失敗 ネットワーク問題 パッケージソースの設定誤り 解決方法: NuGet設定を確認: cat NuGet.Config # パッケージソースが正しいか確認 依存関係をローカルで確認: dotnet restore wt.sln --verbosity detailed キャッシュをクリア: dotnet nuget locals all --clear dotnet restore wt.sln GitHub Actionsワークフローを再実行: gh run rerun <run-id> リリース失敗 問題: GitHub Releaseの作成が失敗する 症状: Error: Failed to create release HttpError: Resource not accessible by integration 原因: GitHub token権限不足 リリース名の重複 ネットワークタイムアウト 解決方法: GitHub token権限を確認: # .github/workflows/release.yml permissions: contents: write # リリース作成に必要 packages: write 既存リリースを確認: gh release list | grep \"v1.0.0\" # 同じバージョンが存在するか確認 既存リリースがある場合は削除: gh release delete v1.0.0 --yes git push origin :refs/tags/v1.0.0 # タグも削除 ワークフローを再実行: gh run rerun <run-id> 問題: アセットのアップロードが失敗する 症状: Error: Failed to upload release asset Error: ENOENT: no such file or directory 原因: ビルドアーティファクトが存在しない ファイルパスの誤り ファイル名の誤り 解決方法: アーティファクトの存在を確認: # GitHub Actionsログで確認 gh run view <run-id> --log | grep -A 10 \"Upload build artifact\" ローカルでファイル生成を確認: ls -lh release-assets/ # 期待されるファイル: # - wt-v<version>-windows-x64.exe # - wt-v<version>-linux-x64 # - wt-v<version>-macos-arm64 # - SHA256SUMS # - wt-v<version>-sbom.json ファイル名パターンを確認: # .github/workflows/release.yml files: | release-assets/wt-*-windows-*.exe release-assets/wt-*-linux-* release-assets/wt-*-macos-* release-assets/wt-*-sbom.json release-assets/wt-*-sbom.json.asc release-assets/SHA256SUMS release-assets/SHA256SUMS.asc バージョン計算の問題 問題: バージョンがインクリメントされない 症状: mainにマージしてもリリースが作成されない バージョン番号が変わらない 原因: Conventional Commits形式に従っていないコミット docs:, chore:などのバージョン変更不要なコミットのみ 解決方法: コミットメッセージを確認: git log origin/main --oneline --since=\"1 day ago\" Conventional Commits形式を確認: 有効なコミットタイプ: feat: → MINORバージョン増加 fix: → PATCHバージョン増加 BREAKING CHANGE: → MAJORバージョン増加 無効なコミット (バージョン変更なし): docs:, style:, refactor:, test:, chore: バージョンを手動で強制する (緊急時のみ): # GitHub Actions workflow_dispatchで手動実行 gh workflow run release.yml -f force-version=v1.2.3 問題: 間違ったバージョンが計算される 症状: 期待: PATCH増加 (v1.0.0 → v1.0.1) 実際: MINOR増加 (v1.0.0 → v1.1.0) 原因: コミットメッセージに誤ったタイプが含まれている スクワッシュマージ時にコミットメッセージが結合されている 解決方法: マージされたコミットを確認: git log origin/main --oneline -1 # 最新のマージコミット git show HEAD # コミットメッセージ全体を確認 スクワッシュマージのコミットメッセージを修正: PRマージ時に、適切なConventional Commitsフォーマットを使用: fix: resolve critical bug - Fix issue #123 - Update error handling 間違ったリリースを削除して再作成: # 間違ったリリースとタグを削除 gh release delete v1.1.0 --yes git push origin :refs/tags/v1.1.0 # mainブランチの最新コミットを修正 (必要に応じて) git revert HEAD --no-edit git push origin main テスト失敗 問題: テストが失敗してPRがマージできない 症状: ❌ Test and Coverage / Run Tests — Failed Tests failed with exit code 1 原因: 単体テストの失敗 テストコードのバグ テスト環境の問題 解決方法: ローカルでテストを実行: dotnet test wt.sln --verbosity detailed 失敗したテストを特定: dotnet test wt.sln --logger \"trx;LogFileName=test-results.trx\" cat TestResults/test-results.trx | grep -A 5 \"Outcome=\\\"Failed\\\"\" テストログを確認: gh run view <run-id> --log | grep -A 20 \"Test.*Failed\" テストを修正してプッシュ: # テストを修正 git add wt.tests/ git commit -m \"test: fix failing unit test\" git push origin <branch-name> # GitHub Actionsが自動的に再実行される gh pr checks --watch 問題: テストがタイムアウトする 症状: Error: The operation was canceled. ##[error]The action 'Run Tests' has timed out after 10 minutes. 原因: テストが無限ループに陥っている テストの実行時間が長すぎる ネットワーク待機が発生している 解決方法: タイムアウトしたテストを特定: # ローカルで個別にテストを実行 dotnet test wt.tests/LongRunningTest.cs --verbosity detailed タイムアウト時間を延長 (一時的): # .github/workflows/test.yml jobs: test: timeout-minutes: 20 # デフォルト: 10分 テストを最適化: 不要なTask.Delay()を削除 モックを使用して外部依存を排除 テストをより小さな単位に分割 カバレッジ報告の問題 問題: Codacyへのカバレッジアップロードが失敗する 症状: Warning: Failed to upload coverage to Codacy Error: Project token is invalid 原因: Codacyプロジェクトトークンの設定誤り Codacy APIの一時的な障害 カバレッジファイルの形式誤り 解決方法: Codacyトークンを確認: # GitHub Secrets設定を確認 gh secret list | grep CODACY トークンを再設定: # Codacyダッシュボードから新しいトークンを取得 # Settings → Coverage → Project API Token # GitHub Secretsに設定 gh secret set CODACY_PROJECT_TOKEN カバレッジファイルを確認: # ローカルでカバレッジを生成 dotnet test wt.sln --collect:\"XPlat Code Coverage\" --results-directory ./coverage # カバレッジファイルを確認 find ./coverage -name \"coverage.cobertura.xml\" cat ./coverage/**/coverage.cobertura.xml | head -20 Codacy APIステータスを確認: Codacy Status Page でサービスステータスを確認 一時的な障害の場合は、continue-on-error: trueにより影響なし ワークフローを再実行: gh run rerun <run-id> 問題: カバレッジが0%と報告される 症状: Codacyダッシュボードでカバレッジが0% テストは成功しているが、カバレッジが計測されていない 原因: カバレッジ収集の設定誤り テストプロジェクトとソースプロジェクトの参照誤り カバレッジフィルターの設定誤り 解決方法: カバレッジ収集の設定を確認: # テスト実行時にカバレッジを明示的に指定 dotnet test wt.sln \\ --collect:\"XPlat Code Coverage\" \\ --results-directory ./coverage カバレッジファイルが生成されているか確認: find ./coverage -name \"coverage.cobertura.xml\" カバレッジフィルターを確認 (runsettings): <!-- coverletArgs.runsettings --> <RunSettings> <DataCollectionRunSettings> <DataCollectors> <DataCollector friendlyName=\"XPlat Code Coverage\"> <Configuration> <Exclude>[*.Tests]*,[*]*.Program</Exclude> <Include>[wt.cli]*</Include> </Configuration> </DataCollector> </DataCollectors> </DataCollectionRunSettings> </RunSettings> SBOM生成の問題 問題: SBOM生成が失敗する 症状: Error: Failed to generate SBOM Syft error: unable to analyze packages 原因: プロジェクトディレクトリのパス誤り 依存関係の解決失敗 Syft/Anchorツールのバージョン誤り 解決方法: SBOM生成スクリプトを手動実行: # Syftを使用してローカルでSBOM生成 syft packages dir:./wt.cli -o cyclonedx-json > sbom-test.json プロジェクトディレクトリを確認: # .github/workflows/release.yml - name: Generate SBOM uses: anchore/sbom-action@61119d458adab75f756bc0b9e4bde25725f86a7a with: path: ./wt.cli # 正しいプロジェクトパスか確認 format: cyclonedx-json 依存関係を事前に復元: # ワークフローでrestoreを追加 - name: Restore dependencies run: dotnet restore wt.sln - name: Generate SBOM uses: anchore/sbom-action@... Anchorアクションのバージョンを確認: # 最新の安定版を使用 uses: anchore/sbom-action@61119d458adab75f756bc0b9e4bde25725f86a7a # v0.17.2 問題: SBOMに依存関係が含まれていない 症状: SBOM JSONファイルは生成されるが、.componentsが空 原因: プロジェクトファイル (.csproj) に依存関係が含まれていない ビルド前にSBOM生成している 解決方法: プロジェクトファイルを確認: cat wt.cli/wt.cli.csproj | grep PackageReference SBOM生成前にビルドを実行: - name: Build solution run: dotnet build wt.sln --configuration Release - name: Generate SBOM uses: anchore/sbom-action@... SBOMの内容を確認: jq '.components | length' sbom.json # 依存関係の数 jq '.components[].name' sbom.json # 依存関係の名前一覧 デジタル署名の問題 問題: GPG署名の生成が失敗する 症状: Error: gpg: signing failed: No secret key Error: gpg: signing failed: Inappropriate ioctl for device 原因: GPG秘密鍵が正しく設定されていない GPGパスフレーズの誤り GPGエージェントの設定問題 解決方法: GitHub Secretsを確認: gh secret list | grep GPG # 期待されるシークレット: # - GPG_PRIVATE_KEY # - GPG_PASSPHRASE GPG秘密鍵のフォーマットを確認: # ASCII-armored形式であることを確認 cat gpg-private-key.asc | head -5 # 期待される出力: # -----BEGIN PGP PRIVATE KEY BLOCK----- GPGキーを再インポート: # ローカルでテスト echo \"$GPG_PRIVATE_KEY\" | gpg --batch --import # キーが正しくインポートされたか確認 gpg --list-secret-keys 署名スクリプトを手動実行: # テスト用ファイルを署名 export GPG_PRIVATE_KEY=\"<your-key>\" export GPG_PASSPHRASE=\"<your-passphrase>\" .github/scripts/sign-artifacts.sh GPGエージェント設定を確認: # .github/workflows/release.yml - name: Sign artifacts run: | gpg --batch --yes --passphrase \"$GPG_PASSPHRASE\" \\ --pinentry-mode loopback \\ # CI環境で必要 --armor --detach-sign file.txt 問題: 署名検証が失敗する 症状: gpg: BAD signature from \"Release Bot <release@example.com>\" 原因: 署名されたファイルが改変されている 間違った公開鍵を使用している 署名ファイルが破損している 解決方法: 公開鍵を確認: # 公開鍵をインポート curl -fsSL https://raw.githubusercontent.com/kuju63/wt/main/docs/GPG_PUBLIC_KEY.asc | gpg --import # インポートされた鍵を確認 gpg --list-keys ファイルの整合性を確認: # ハッシュ値を確認 sha256sum wt-v1.0.0-sbom.json sha256sum -c SHA256SUMS --ignore-missing 署名ファイルを再ダウンロード: # 破損していないか確認 gh release download v1.0.0 --pattern \"*.asc\" 署名を再検証: gpg --verify wt-v1.0.0-sbom.json.asc wt-v1.0.0-sbom.json 性能問題とタイムアウト 問題: リリースワークフローが30分以内に完了しない 症状: Error: The operation was canceled. ##[error]Workflow canceled by GitHub Actions (timeout-minutes: 25) 原因: ビルド時間が長すぎる 外部サービス (Codacy, GitHub API) の遅延 ネットワークタイムアウト 解決方法: ワークフローのボトルネックを特定: # 各ステップの実行時間を確認 gh run view <run-id> --log | grep \"##\\[group\\]\" | grep -oE \"[0-9]+m[0-9]+s\" ビルドを最適化: 並列ビルドを活用: strategy: max-parallel: 4 # 全プラットフォームを並列ビルド キャッシュを有効化: - name: Cache NuGet packages uses: actions/cache@v4 with: path: ~/.nuget/packages key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }} 外部サービスのタイムアウトを設定: - name: Upload coverage to Codacy timeout-minutes: 5 # Codacyアップロードに5分以上かかる場合はスキップ continue-on-error: true タイムアウト時間を延長 (一時的): create-release: timeout-minutes: 30 # 25分 → 30分に延長 (SLA上限) 問題: ビルドが遅い 症状: 単一プラットフォームのビルドに10分以上かかる 解決方法: 不要なビルド手順を削除: # 例: Releaseビルドでデバッグシンボルを無効化 - name: Build run: dotnet publish -c Release /p:DebugType=None 依存関係のキャッシュ: - name: Cache dependencies uses: actions/cache@v4 with: path: ~/.nuget/packages key: nuget-${{ hashFiles('**/*.csproj') }} ビルド構成を最適化: <!-- wt.cli.csproj --> <PropertyGroup> <PublishTrimmed>true</PublishTrimmed> <!-- トリミングで高速化 --> <PublishReadyToRun>true</PublishReadyToRun> <!-- AOTコンパイル --> </PropertyGroup> GitHub Actions の問題 問題: ワークフローが実行されない 症状: mainにマージしてもリリースワークフローが実行されない 原因: ワークフローのトリガー設定誤り ブランチ名の不一致 ワークフローファイルの構文エラー 解決方法: トリガー設定を確認: # .github/workflows/release.yml on: push: branches: - main # mainブランチへのプッシュでトリガー ワークフローファイルの構文を検証: # YAMLの構文チェック yamllint .github/workflows/release.yml GitHub Actionsログを確認: gh run list --workflow=release.yml --limit 5 ワークフローを手動実行: gh workflow run release.yml 問題: アーティファクトのダウンロードが失敗する 症状: Error: Unable to find artifact binary-linux-x64 原因: ビルドジョブが失敗してアーティファクトが生成されなかった アーティファクト名の不一致 解決方法: ビルドジョブの状態を確認: gh run view <run-id> --log | grep -A 10 \"Build.*linux-x64\" アーティファクト名を確認: # build.yml - name: Upload build artifact uses: actions/upload-artifact@v4 with: name: binary-${{ matrix.platform }}-${{ matrix.arch }} # release.yml - name: Download build artifacts uses: actions/download-artifact@v4 with: path: artifacts/ アーティファクトを手動ダウンロード: gh run download <run-id> --name binary-linux-x64 その他の問題 問題: ドキュメントが古い 症状: ドキュメントの手順が実際の動作と一致しない 解決方法: ドキュメントを更新してPRを作成: git checkout -b docs/update-troubleshooting # ドキュメントを修正 git add docs/ specs/ git commit -m \"docs: update troubleshooting guide\" git push origin docs/update-troubleshooting gh pr create --title \"docs: update troubleshooting guide\" 問題: 不明なエラー 症状: エラーメッセージが不明確 ログに有用な情報がない 解決方法: 詳細ログを有効化: # .github/workflows/*.yml - name: Run command run: | set -x # Bashデバッグモード <your-command> --verbosity detailed GitHub Actionsデバッグモードを有効化: # リポジトリシークレットに設定 gh secret set ACTIONS_STEP_DEBUG --body \"true\" gh secret set ACTIONS_RUNNER_DEBUG --body \"true\" Issue を作成: gh issue create \\ --title \"Release pipeline failure: <error-message>\" \\ --body \"Steps to reproduce: ...\" \uD83D\uDD17 関連ドキュメント quickstart.md: クイックスタートガイド testing-guide.md: テストガイド spec.md: 仕様書 ADR 0002: SBOM形式とデジタル署名 ADR 0003: セマンティックバージョニング ADR 0004: タイムアウトとSLA ADR 0005: 品質ゲート サポート 問題が解決しない場合: GitHub Issueを作成: kuju63/wt/issues ワークフローログを添付: gh run view <run-id> --log > workflow.log 再現手順を記載: 問題を再現する最小限の手順"
  },
  "specs/004-complete-sbom-generation/checklists/requirements.html": {
    "href": "specs/004-complete-sbom-generation/checklists/requirements.html",
    "title": "仕様品質チェックリスト: リリースパイプラインにおける完全なSBOM生成 | wt",
    "summary": "仕様品質チェックリスト: リリースパイプラインにおける完全なSBOM生成 目的: 計画フェーズに進む前に仕様の完全性と品質を検証する 作成日: 2026-01-06 機能: spec.md コンテンツの品質 [x] 実装の詳細なし（言語、フレームワーク、API） [x] ユーザー価値とビジネスニーズに焦点 [x] 非技術的な利害関係者向けに記述 [x] すべての必須セクションが完了 要件の完全性 [x] [NEEDS CLARIFICATION]マーカーが残っていない [x] 要件がテスト可能で明確 [x] 成功基準が測定可能 [x] 成功基準が技術非依存（実装の詳細なし） [x] すべての受入シナリオが定義されている [x] エッジケースが特定されている [x] スコープが明確に境界付けられている [x] 依存関係と仮定が特定されている 機能の準備状況 [x] すべての機能要件に明確な受入基準がある [x] ユーザーシナリオが主要なフローをカバー [x] 機能が成功基準で定義された測定可能な成果を満たす [x] 実装の詳細が仕様に漏れていない 備考 すべてのチェックリスト項目が検証に合格しました。仕様は /speckit.clarify または /speckit.plan フェーズの準備ができています。"
  },
  "specs/004-complete-sbom-generation/contracts/github-dependency-submission-api.html": {
    "href": "specs/004-complete-sbom-generation/contracts/github-dependency-submission-api.html",
    "title": "GitHub Dependency Submission API Contract | wt",
    "summary": "GitHub Dependency Submission API Contract このファイルは、GitHub Dependency Submission API v1の契約を定義します。 エンドポイント POST /repos/{owner}/{repo}/dependency-graph/snapshots パス パラメータ パラメータ 型 必須 説明 owner string ✅ リポジトリのオーナー（ユーザー名または組織名） repo string ✅ リポジトリ名 認証 Authorization: Bearer {GITHUB_TOKEN} 必要な権限: contents: write - 依存関係スナップショットの書き込み id-token: write - OIDCトークンの生成（GitHub Actions内で自動） リクエスト ヘッダー Content-Type: application/json Accept: application/vnd.github+json X-GitHub-Api-Version: 2022-11-28 ボディ（JSON） { \"version\": 0, \"sha\": \"string\", \"ref\": \"string\", \"job\": { \"correlator\": \"string\", \"id\": \"string\", \"html_url\": \"string\" }, \"detector\": { \"name\": \"string\", \"version\": \"string\", \"url\": \"string\" }, \"scanned\": \"string\", \"metadata\": {}, \"manifests\": { \"{manifest_name}\": { \"name\": \"string\", \"file\": { \"source_location\": \"string\" }, \"metadata\": {}, \"resolved\": { \"{package_url}\": { \"package_url\": \"string\", \"relationship\": \"string\", \"scope\": \"string\", \"dependencies\": [\"string\"] } } } } } フィールド定義 トップレベル フィールド 型 必須 説明 version integer ✅ APIバージョン（常に 0） sha string ✅ スナップショットに関連するコミットSHA ref string ✅ Git参照（例: refs/heads/main） job object ✅ ジョブ情報 detector object ✅ 検出ツール情報 scanned string ✅ スキャン日時（ISO 8601形式） metadata object ❌ 追加メタデータ（任意） manifests object ✅ マニフェストと依存関係のマップ job オブジェクト フィールド 型 必須 説明 correlator string ✅ ワークフローとジョブの一意識別子 id string ✅ ジョブID（GitHub Actions run IDなど） html_url string ❌ ジョブのURL correlatorの形式: {workflow_name}-{job_name} 例: release-publish detector オブジェクト フィールド 型 必須 説明 name string ✅ 検出ツール名 version string ✅ ツールバージョン url string ✅ ツールのURL manifests オブジェクト キーはマニフェストファイル名（例: wt.cli.csproj）、値はManifestオブジェクト。 Manifest オブジェクト フィールド 型 必須 説明 name string ✅ マニフェスト名 file.source_location string ❌ ソースファイルの相対パス metadata object ❌ 追加メタデータ resolved object ✅ 解決済み依存関係のマップ resolved オブジェクト キーはPackage URL（purl）、値はDependencyオブジェクト。 Dependency オブジェクト フィールド 型 必須 説明 package_url string ✅ Package URL（purl）形式 relationship string ❌ direct または indirect scope string ❌ runtime または development dependencies array ❌ このパッケージが依存する他のpurlのリスト レスポンス 成功（201 Created） { \"id\": 12345678, \"created_at\": \"2026-01-06T12:00:00Z\", \"message\": \"Dependency snapshot created successfully\" } レスポンスフィールド フィールド 型 説明 id integer スナップショットID created_at string 作成日時（ISO 8601形式） message string 成功メッセージ エラー 400 Bad Request { \"message\": \"Invalid request\", \"errors\": [ { \"field\": \"manifests\", \"code\": \"missing_field\" } ] } 401 Unauthorized { \"message\": \"Bad credentials\" } 403 Forbidden { \"message\": \"Resource not accessible by integration\" } 404 Not Found { \"message\": \"Not Found\" } 422 Unprocessable Entity { \"message\": \"Validation Failed\", \"errors\": [ { \"resource\": \"DependencySnapshot\", \"field\": \"package_url\", \"code\": \"invalid\" } ] } 使用例 リクエスト例（wt CLI Tool） curl -X POST \\ -H \"Authorization: Bearer ${GITHUB_TOKEN}\" \\ -H \"Accept: application/vnd.github+json\" \\ -H \"X-GitHub-Api-Version: 2022-11-28\" \\ -H \"Content-Type: application/json\" \\ https://api.github.com/repos/kuju63/wt/dependency-graph/snapshots \\ -d @- <<EOF { \"version\": 0, \"sha\": \"abc123def456\", \"ref\": \"refs/heads/main\", \"job\": { \"correlator\": \"release-publish\", \"id\": \"87654321\" }, \"detector\": { \"name\": \"Microsoft SBOM Tool\", \"version\": \"2.2.0\", \"url\": \"https://github.com/microsoft/sbom-tool\" }, \"scanned\": \"2026-01-06T12:00:00Z\", \"manifests\": { \"wt.cli.csproj\": { \"name\": \"wt.cli\", \"file\": { \"source_location\": \"wt.cli/wt.cli.csproj\" }, \"resolved\": { \"pkg:nuget/System.CommandLine@2.0.1\": { \"package_url\": \"pkg:nuget/System.CommandLine@2.0.1\", \"relationship\": \"direct\", \"scope\": \"runtime\", \"dependencies\": [ \"pkg:nuget/System.Memory@4.5.5\" ] }, \"pkg:nuget/System.Memory@4.5.5\": { \"package_url\": \"pkg:nuget/System.Memory@4.5.5\", \"relationship\": \"indirect\", \"scope\": \"runtime\" }, \"pkg:nuget/System.IO.Abstractions@22.1.0\": { \"package_url\": \"pkg:nuget/System.IO.Abstractions@22.1.0\", \"relationship\": \"direct\", \"scope\": \"runtime\" } } } } } EOF レスポンス例 { \"id\": 12345678, \"created_at\": \"2026-01-06T12:00:01Z\", \"message\": \"Dependency snapshot created successfully\" } GitHub Actions統合 actions/dependency-submission@v3の使用 GitHub公式のアクションを使用する場合（推奨）: - name: Submit dependencies to GitHub uses: actions/dependency-submission@v3 with: # SBOMファイルのパス sbom-file: _manifest/sbom.spdx.json # フォーマット（spdxまたはcyclonedx） snapshot-format: spdx # トークン（省略時はGITHUB_TOKENを自動使用） token: ${{ secrets.GITHUB_TOKEN }} このアクションは内部で以下を実行: SPDX/CycloneDXファイルをパース Dependency Snapshot形式に変換 API呼び出し エラーハンドリング 手動API呼び出し より細かい制御が必要な場合: - name: Convert SBOM to Dependency Snapshot run: | # SPDXからDependency Snapshot形式への変換スクリプト python scripts/spdx-to-snapshot.py \\ --spdx _manifest/sbom.spdx.json \\ --output snapshot.json \\ --sha ${{ github.sha }} \\ --ref ${{ github.ref }} - name: Submit to GitHub API run: | curl -X POST \\ -H \"Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}\" \\ -H \"Accept: application/vnd.github+json\" \\ -H \"X-GitHub-Api-Version: 2022-11-28\" \\ -H \"Content-Type: application/json\" \\ https://api.github.com/repos/${{ github.repository }}/dependency-graph/snapshots \\ -d @snapshot.json エラーハンドリング戦略 リトライ戦略 - name: Submit with retry uses: nick-fields/retry@v2 with: timeout_minutes: 5 max_attempts: 3 retry_wait_seconds: 10 command: | gh api \\ --method POST \\ -H \"Accept: application/vnd.github+json\" \\ -H \"X-GitHub-Api-Version: 2022-11-28\" \\ /repos/${{ github.repository }}/dependency-graph/snapshots \\ --input snapshot.json 失敗時の動作（FR-013準拠） - name: Submit dependencies uses: actions/dependency-submission@v3 with: sbom-file: _manifest/sbom.spdx.json snapshot-format: spdx # 失敗時はパイプライン全体を失敗させる continue-on-error: false バリデーション リクエストバリデーション 送信前に以下を確認: Package URL形式: pkg:nuget/PackageName@Version ISO 8601日時: YYYY-MM-DDTHH:MM:SSZ Git参照: refs/heads/ または refs/tags/ で始まる コミットSHA: 40文字の16進数 検証スクリプト例 #!/bin/bash set -euo pipefail SNAPSHOT_FILE=\"$1\" # JSON形式チェック jq empty \"$SNAPSHOT_FILE\" || { echo \"Invalid JSON format\" exit 1 } # 必須フィールドチェック required_fields=(\"version\" \"sha\" \"ref\" \"job\" \"detector\" \"scanned\" \"manifests\") for field in \"${required_fields[@]}\"; do jq -e \".$field\" \"$SNAPSHOT_FILE\" > /dev/null || { echo \"Missing required field: $field\" exit 1 } done # Package URL形式チェック jq -r '.manifests[].resolved | keys[]' \"$SNAPSHOT_FILE\" | while read -r purl; do if [[ ! \"$purl\" =~ ^pkg:[a-z]+/.+@.+ ]]; then echo \"Invalid package URL: $purl\" exit 1 fi done echo \"Validation passed\" レート制限 GitHub Actions内 制限: 通常制限なし（大規模なスナップショットを除く） 監視: X-RateLimit-* ヘッダーをチェック GitHub Actions外 認証済みリクエスト: 5,000リクエスト/時間 未認証: 60リクエスト/時間 セキュリティ考慮事項 トークン権限: 最小権限（contents: writeのみ） 秘密情報の除外: 依存関係情報のみ送信（ソースコードや秘密情報は含まない） HTTPS必須: すべてのAPI通信はHTTPS トークン有効期限: GitHub Actionsのトークンはジョブごとに自動更新 参考リンク GitHub Dependency Submission API公式ドキュメント actions/dependency-submission Package URL仕様 SPDX仕様"
  },
  "specs/004-complete-sbom-generation/data-model.html": {
    "href": "specs/004-complete-sbom-generation/data-model.html",
    "title": "Phase 1: Data Model | wt",
    "summary": "Phase 1: Data Model SBOM生成機能はCI/CDパイプライン（ワークフロー）の変更のみで実現するため、アプリケーションコード内で使用する新しいデータモデルは基本的に不要です。ここでは、SBOM生成プロセスで扱う概念的なデータ構造を文書化します。 1. SBOM Document (SPDX 2.3形式) 概要 Microsoft SBOM Toolが生成するSPDX 2.3形式のJSON文書。 構造 interface SpdxDocument { spdxVersion: \"SPDX-2.3\"; dataLicense: \"CC0-1.0\"; SPDXID: string; // \"SPDXRef-DOCUMENT\" name: string; // プロジェクト名 documentNamespace: string; // 一意のURI creationInfo: CreationInfo; packages: Package[]; relationships: Relationship[]; } interface CreationInfo { created: string; // ISO 8601形式 creators: string[]; // \"Tool: Microsoft.Sbom.Tool-x.x.x\" licenseListVersion?: string; } interface Package { SPDXID: string; // \"SPDXRef-Package-{hash}\" name: string; versionInfo: string; downloadLocation: string; // NuGetパッケージURL filesAnalyzed: boolean; licenseConcluded: string; // SPDX License Identifier or \"NOASSERTION\" licenseDeclared: string; copyrightText: string; externalRefs?: ExternalRef[]; } interface ExternalRef { referenceCategory: \"PACKAGE-MANAGER\"; referenceType: \"purl\"; referenceLocator: string; // Package URL形式 } interface Relationship { spdxElementId: string; relationshipType: \"DEPENDS_ON\" | \"DESCRIBES\" | \"CONTAINS\"; relatedSpdxElement: string; } 使用例 { \"spdxVersion\": \"SPDX-2.3\", \"dataLicense\": \"CC0-1.0\", \"SPDXID\": \"SPDXRef-DOCUMENT\", \"name\": \"wt CLI Tool\", \"documentNamespace\": \"https://github.com/kuju63/wt/sbom/v1.0.0-20260106\", \"creationInfo\": { \"created\": \"2026-01-06T12:00:00Z\", \"creators\": [\"Tool: Microsoft.Sbom.Tool-2.2.0\"] }, \"packages\": [ { \"SPDXID\": \"SPDXRef-Package-1234\", \"name\": \"System.CommandLine\", \"versionInfo\": \"2.0.1\", \"downloadLocation\": \"https://www.nuget.org/packages/System.CommandLine/2.0.1\", \"filesAnalyzed\": false, \"licenseConcluded\": \"MIT\", \"licenseDeclared\": \"MIT\", \"copyrightText\": \"Copyright Microsoft Corporation\", \"externalRefs\": [ { \"referenceCategory\": \"PACKAGE-MANAGER\", \"referenceType\": \"purl\", \"referenceLocator\": \"pkg:nuget/System.CommandLine@2.0.1\" } ] } ], \"relationships\": [ { \"spdxElementId\": \"SPDXRef-DOCUMENT\", \"relationshipType\": \"DESCRIBES\", \"relatedSpdxElement\": \"SPDXRef-Package-1234\" } ] } 2. Dependency Snapshot (GitHub API形式) 概要 GitHub Dependency Submission APIに送信する依存関係スナップショット。 構造 interface DependencySnapshot { version: 0; // APIバージョン sha: string; // コミットSHA ref: string; // ブランチ参照（例: \"refs/heads/main\"） job: JobInfo; detector: DetectorInfo; scanned: string; // ISO 8601形式 manifests: Record<string, Manifest>; } interface JobInfo { correlator: string; // ワークフロー識別子 id: string; // ジョブID } interface DetectorInfo { name: string; // \"Microsoft SBOM Tool\" version: string; url: string; } interface Manifest { name: string; // マニフェストファイル名 file?: { source_location: string; }; resolved: Record<string, Dependency>; } interface Dependency { package_url: string; // Package URL (purl) relationship: \"direct\" | \"indirect\"; scope?: \"runtime\" | \"development\"; dependencies?: string[]; // 依存パッケージのpurlリスト } 使用例 { \"version\": 0, \"sha\": \"abc123...\", \"ref\": \"refs/heads/main\", \"job\": { \"correlator\": \"release-publish\", \"id\": \"12345678\" }, \"detector\": { \"name\": \"Microsoft SBOM Tool\", \"version\": \"2.2.0\", \"url\": \"https://github.com/microsoft/sbom-tool\" }, \"scanned\": \"2026-01-06T12:00:00Z\", \"manifests\": { \"wt.cli.csproj\": { \"name\": \"wt.cli\", \"file\": { \"source_location\": \"wt.cli/wt.cli.csproj\" }, \"resolved\": { \"System.CommandLine@2.0.1\": { \"package_url\": \"pkg:nuget/System.CommandLine@2.0.1\", \"relationship\": \"direct\", \"scope\": \"runtime\", \"dependencies\": [ \"pkg:nuget/System.Memory@4.5.5\" ] }, \"System.Memory@4.5.5\": { \"package_url\": \"pkg:nuget/System.Memory@4.5.5\", \"relationship\": \"indirect\", \"scope\": \"runtime\" } } } } } 3. Workflow Configuration (GitHub Actions) 概要 ワークフロー定義で使用する設定パラメータ。 構造 interface WorkflowConfig { sbom: SbomConfig; github: GitHubConfig; performance: PerformanceConfig; } interface SbomConfig { outputDir: string; // SBOM出力ディレクトリ（例: \"_manifest\"） fileName: string; // SBOMファイル名（例: \"sbom.spdx.json\"） format: \"spdx\"; // フォーマット packageName: string; // パッケージ名 packageVersion: string; // バージョン namespace: string; // ドキュメント名前空間URI } interface GitHubConfig { repository: string; // リポジトリ名（owner/repo） token: string; // GITHUB_TOKEN releaseTag: string; // リリースタグ permissions: { contents: \"write\"; idToken: \"write\"; }; } interface PerformanceConfig { restoreTimeout: number; // リストアタイムアウト（分） sbomTimeout: number; // SBOM生成タイムアウト（分） cacheEnabled: boolean; // キャッシュ有効化 cachePath: string; // キャッシュパス cacheKey: string; // キャッシュキー } 使用例（GitHub Actionsワークフロー） env: SBOM_OUTPUT_DIR: _manifest SBOM_FILE_NAME: sbom.spdx.json PACKAGE_NAME: ${{ github.repository }} PACKAGE_VERSION: ${{ steps.version.outputs.version }} NAMESPACE: https://github.com/${{ github.repository }}/sbom/${{ steps.version.outputs.version }} jobs: generate-sbom: permissions: contents: write id-token: write timeout-minutes: 15 4. Package URL (purl) 形式 概要 依存関係パッケージを一意に識別するための標準形式。 構造 pkg:<type>/<namespace>/<name>@<version>?<qualifiers>#<subpath> # NuGetの例 pkg:nuget/System.CommandLine@2.0.1 # プラットフォーム固有の例 pkg:nuget/System.CommandLine@2.0.1?targetframework=net10.0 TypeScript型定義 interface PackageUrl { type: \"nuget\" | \"npm\" | \"pypi\" | \"maven\" | ...; namespace?: string; name: string; version: string; qualifiers?: Record<string, string>; subpath?: string; } function formatPurl(purl: PackageUrl): string { let result = `pkg:${purl.type}`; if (purl.namespace) result += `/${purl.namespace}`; result += `/${purl.name}`; if (purl.version) result += `@${purl.version}`; if (purl.qualifiers) { const queries = Object.entries(purl.qualifiers) .map(([k, v]) => `${k}=${v}`) .join('&'); result += `?${queries}`; } if (purl.subpath) result += `#${purl.subpath}`; return result; } 5. Release Asset Metadata 概要 GitHubリリースに添付するSBOMファイルのメタデータ。 構造 interface ReleaseAsset { name: string; // \"wt-v1.0.0-sbom.spdx.json\" label: string; // \"SBOM (SPDX 2.3)\" contentType: \"application/json\"; size: number; // バイト数 state: \"uploaded\"; browserDownloadUrl: string; // ダウンロードURL } 使用例 { \"name\": \"wt-v1.0.0-sbom.spdx.json\", \"label\": \"SBOM (SPDX 2.3)\", \"contentType\": \"application/json\", \"size\": 45678, \"state\": \"uploaded\", \"browserDownloadUrl\": \"https://github.com/kuju63/wt/releases/download/v1.0.0/wt-v1.0.0-sbom.spdx.json\" } データフロー図 graph TD A[dotnet restore] --> B[packages.lock.json] B --> C[Microsoft SBOM Tool] C --> D[sbom.spdx.json] D --> E[GitHub Dependency Submission API] D --> F[GitHub Release Asset] E --> G[Dependency Graph] G --> H[Dependabot Alerts] G --> I[Renovate Integration] エンティティ関係図 erDiagram SPDX-DOCUMENT ||--o{ PACKAGE : contains PACKAGE ||--o{ EXTERNAL-REF : has PACKAGE }o--o{ PACKAGE : depends-on SPDX-DOCUMENT ||--|{ RELATIONSHIP : defines DEPENDENCY-SNAPSHOT ||--o{ MANIFEST : includes MANIFEST ||--o{ DEPENDENCY : resolved DEPENDENCY }o--o{ DEPENDENCY : depends-on GITHUB-RELEASE ||--o{ RELEASE-ASSET : attaches RELEASE-ASSET ||--|| SPDX-DOCUMENT : contains 状態遷移図 stateDiagram-v2 [*] --> Restoring: dotnet restore Restoring --> Restored: Success Restoring --> Failed: Failure Restored --> Generating: sbom-tool generate Generating --> Generated: Success Generating --> Failed: Failure Generated --> Submitting: API submission Submitting --> Submitted: Success (201) Submitting --> Failed: Failure (4xx/5xx) Generated --> Uploading: Release asset Uploading --> Uploaded: Success Uploading --> Failed: Failure Submitted --> [*] Uploaded --> [*] Failed --> [*]: Pipeline fails バリデーションルール SPDX Document spdxVersion は \"SPDX-2.3\" 固定 dataLicense は \"CC0-1.0\" 固定 documentNamespace は一意のURI（リポジトリ + バージョン + タイムスタンプ） packages は1個以上必要 Package name と versionInfo は必須 licenseConcluded は SPDX License Identifier または \"NOASSERTION\" downloadLocation は有効なURL または \"NOASSERTION\" Dependency Snapshot version は 0 固定 sha は有効なGitコミットSHA package_url はPackage URL仕様に準拠 まとめ この機能はアプリケーションコードの変更を伴わないため、新しいデータモデルの実装は不要です。上記のデータ構造はすべて： Microsoft SBOM Tool が自動生成（SPDX Document） GitHub Actions が構築（Dependency Snapshot、Workflow Config） GitHub API が定義（Release Asset） したがって、Phase 2のタスク分解では、これらの外部ツール・APIの正しい使用に焦点を当てます。"
  },
  "specs/004-complete-sbom-generation/plan.html": {
    "href": "specs/004-complete-sbom-generation/plan.html",
    "title": "Implementation Plan: Complete SBOM Generation in Release Pipeline | wt",
    "summary": "Implementation Plan: Complete SBOM Generation in Release Pipeline Branch: 004-complete-sbom-generation | Date: 2026-01-06 | Spec: spec.md Input: Feature specification from /specs/004-complete-sbom-generation/spec.md Note: This template is filled in by the /speckit.plan command. See .specify/templates/commands/plan.md for the execution workflow. Summary 現在のリリースパイプラインは、SBOM生成前にプロジェクトの依存関係を復元していないため、推移的依存関係が欠落した不完全なSBOMが生成されています。この機能は、依存関係の完全な復元プロセスを追加し、SPDX 2.3+形式の完全なSBOMを生成し、GitHubのDependency Submission APIに送信してDependabotおよびRenovateとの統合を有効にします。 技術的アプローチ: リリースパイプラインにdotnet restoreステップを追加（SBOM生成前） Microsoft SBOM Toolを使用してSPDX 2.3+形式のSBOMを生成 GitHub Dependency Submission APIを使用してSBOMを依存関係グラフに送信 SBOMファイルをGitHubリリースの成果物として添付 15分のタイムアウトと依存関係キャッシングを実装 Technical Context Language/Version: C# / .NET 10.0 Primary Dependencies: System.CommandLine 2.0.1, System.IO.Abstractions 22.1.0 Storage: N/A (CLI tool, no persistent storage) Testing: xUnit (wt.tests project) Target Platform: Multi-platform (win-x64, linux-x64, linux-arm, osx-arm64) Project Type: Single project (CLI application) Performance Goals: SBOM生成完了時間 - 一般的なプロジェクト（50依存関係）で5分以内、大規模（200依存関係）で15分以内 Constraints: タイムアウト: 15分以内でSBOM生成完了必須 SBOM形式: SPDX 2.3+ (ISO/IEC 5962:2021) 準拠 GitHubインテグレーション: Dependency Submission API必須 失敗時の動作: SBOM生成またはAPI送信失敗時はパイプライン全体を失敗させる Scale/Scope: 対象: .NETソリューション（単一または複数プロジェクト） 依存関係数: 最大200の直接・推移的依存関係をサポート リリース頻度: mainブランチへのプッシュまたは手動トリガー Constitution Check GATE: Must pass before Phase 0 research. Re-check after Phase 1 design. I. Developer Usability (開発者のユーザビリティ) ✅ PASS - リリースパイプラインの変更はCLIツール自体には影響せず、CI/CD設定のみを変更。ワークフローファイルは明確で理解しやすい構造を維持。 II. Cross-Platform (クロスプラットフォーム) ✅ PASS - Microsoft SBOM ToolはWindows、Linux、macOSで動作。GitHub Actionsはクロスプラットフォーム。パイプラインは既存のマルチプラットフォームビルドに影響を与えない。 III. Clean & Secure Code (クリーンでセキュアなコード) ✅ PASS - SBOM生成により依存関係の脆弱性が可視化される。セキュリティベストプラクティスに従い: GitHubトークン権限を最小限（contents: write）に制限 SBOM生成失敗時はパイプライン全体を失敗させる（不完全な成果物の防止） 秘密情報はGitHub Secretsで管理 Dependency Submission APIによりDependabotアラートを自動有効化 IV. Documentation Clarity (ドキュメントの明瞭性) ✅ PASS - 日本語の仕様書、ADR、実装計画を作成。ワークフロー変更は明確にコメントされ、SBOMの目的と使用方法が文書化される。 V. Minimal Dependencies (最小限の依存関係) ✅ PASS - 新規依存関係: Microsoft SBOM Tool: Microsoft公式ツール、SPDX生成に必須 GitHub Dependency Submission API: GitHubネイティブ機能、追加パッケージ不要 両方とも要件を満たすために不可欠で、代替手段なし。 VI. Comprehensive Testing (テストの充実と自動化) ✅ PASS - パイプライン変更のテスト戦略: ワークフロー検証: 実際のリリースプロセスでのE2Eテスト SBOM検証: 生成されたSBOMをSPDXスキーマバリデーターで検証 統合テスト: GitHub依存関係グラフとDependency Submission APIの統合を確認 タイムアウトテスト: 大規模ソリューションでの15分制限を検証 Constitution Check結果: ✅ 全項目PASS - 追加の正当化不要 Project Structure Documentation (this feature) specs/[###-feature]/ ├── plan.md # This file (/speckit.plan command output) ├── research.md # Phase 0 output (/speckit.plan command) ├── data-model.md # Phase 1 output (/speckit.plan command) ├── quickstart.md # Phase 1 output (/speckit.plan command) ├── contracts/ # Phase 1 output (/speckit.plan command) └── tasks.md # Phase 2 output (/speckit.tasks command - NOT created by /speckit.plan) Source Code (repository root) # 既存プロジェクト構造（変更なし） wt.cli/ ├── Commands/ # コマンド実装（変更不要） ├── Models/ # データモデル（変更不要） ├── Services/ # サービス層（変更不要） └── Utils/ # ユーティリティ（変更不要） wt.tests/ # テスト（変更不要） # 変更対象 .github/workflows/ ├── release.yml # \uD83D\uDCDD SBOM生成ステップを追加 └── sbom-test.yml # \uD83D\uDCDD 新規: PR時のSBOM生成テストワークフロー # Phase 1で追加予定 docs/ ├── adr/ │ └── 004-sbom-generation.md # Architecture Decision Record └── guides/ └── sbom-usage.md # SBOM使用ガイド Structure Decision: ソースコード変更は不要（wt.cli、wt.testsともに既存のまま） 変更はCI/CDパイプライン（.github/workflows/release.yml）のみ Microsoft SBOM Toolはワークフロー内で実行（インストール不要） GitHub Dependency Submission APIはGitHub Actions標準機能で利用 Complexity Tracking Fill ONLY if Constitution Check has violations that must be justified 該当なし - Constitution Checkは全項目PASSのため、正当化が必要な違反は存在しません。 Phase 0: Research (完了) ✅ research.md作成完了 調査結果: Microsoft SBOM Tool: dotnet toolとして簡単に統合可能 SPDX 2.3+: ISO標準準拠、JSONフォーマット GitHub Dependency Submission API: actions/dependency-submission@v3で簡単に統合 パフォーマンス最適化: キャッシュ戦略と並列化で目標達成可能 エラーハンドリング: すべての失敗でパイプライン停止 すべての「NEEDS CLARIFICATION」が解決されました。 Phase 1: Design & Contracts (完了) ✅ data-model.md作成完了: SPDX Document、Dependency Snapshot、Workflow Configの構造を定義 ✅ contracts/作成完了: GitHub Dependency Submission API v1の詳細な契約を文書化 ✅ quickstart.md作成完了: ユーザーと開発者向けのSBOM使用ガイド ✅ agent context更新完了: Copilotエージェントに技術スタック追加 ✅ テスト戦略追加: PR時テストワークフロー（sbom-test.yml）を設計 Constitution Check再評価（Phase 1後） I. Developer Usability (開発者のユーザビリティ) ✅ PASS (変更なし) - quickstart.mdで明確なガイドを提供。開発者はローカルでもSBOM生成可能。 II. Cross-Platform (クロスプラットフォーム) ✅ PASS (変更なし) - すべてのツールがマルチプラットフォームで動作確認済み。 III. Clean & Secure Code (クリーンでセキュアなコード) ✅ PASS (強化) - 契約定義により、APIセキュリティ要件が明確化。トークン権限、エラーハンドリング、レート制限対策を文書化。 IV. Documentation Clarity (ドキュメントの明瞭性) ✅ PASS (強化) - 包括的なドキュメント（research.md、data-model.md、contracts/、quickstart.md）により、実装の透明性が向上。 V. Minimal Dependencies (最小限の依存関係) ✅ PASS (変更なし) - 追加依存関係なし。Microsoft SBOM ToolはCI/CD内でのみ使用。 VI. Comprehensive Testing (テストの充実と自動化) ✅ PASS (強化) - PR時テストワークフローにより早期不具合発見を実現。SPDX検証、必須パッケージ確認、パフォーマンスベンチマークを自動実行。リリース前に品質を保証。 再評価結果: ✅ 全項目PASS（Phase 1により強化） - 設計により憲法原則がさらに強化されました。特にテスト自動化が大幅に改善。 次のステップ Phase 2（タスク分解）は /speckit.tasks コマンドで実行してください。 Phase 2で作成されるもの tasks.md: 実装タスクの詳細な分解 各タスクの優先順位、見積もり、依存関係 テストタスクとドキュメントタスクの定義 実装準備完了 以下のドキュメントがすべて完成しました： ✅ spec.md - 機能仕様（FR-019/FR-020、SC-011/SC-012追加: PR時テスト要件） ✅ research.md - 技術調査（PR時テスト戦略、sbom-test.ymlワークフロー設計追加） ✅ data-model.md - データモデル ✅ contracts/ - API契約 ✅ quickstart.md - 使用ガイド（PR時テストとトラブルシューティング追加） ✅ plan.md（本ファイル） - 実装計画 すべての不明点が解決され、実装に必要な情報がすべて揃っています。 \uD83D\uDCDD 重要な追加機能（ユーザー要望対応） 問題: リリースパイプライン実行まで不具合が発見できない 解決: PR時自動テストワークフローを追加 新規ワークフローファイル: .github/workflows/sbom-test.yml - PR作成時に自動実行されるSBOM生成テスト テスト内容: ✅ 依存関係リストア成功確認 ✅ SBOM生成成功確認 ✅ SPDX 2.3フォーマット検証 ✅ 必須パッケージ存在確認（System.CommandLine等） ✅ パフォーマンスベンチマーク（15分制限） ❌ GitHub API送信なし（Dry-runモード、本番環境を汚染しない） 重要な制約: PR時はGitHub Dependency Graphにアップロードしません PR時はDependency Submission APIを呼び出しません 実際のAPI送信とDependency Graph更新はリリース時のみ実行 これにより、リリース前に不具合を検出し、開発サイクルを高速化しつつ、本番環境の整合性を保ちます。"
  },
  "specs/004-complete-sbom-generation/quickstart.html": {
    "href": "specs/004-complete-sbom-generation/quickstart.html",
    "title": "SBOM生成 クイックスタートガイド | wt",
    "summary": "SBOM生成 クイックスタートガイド このガイドでは、wtプロジェクトのSBOM（Software Bill of Materials）生成機能の使用方法を説明します。 \uD83D\uDCCB 目次 概要 ユーザー向けガイド 開発者向けガイド トラブルシューティング 概要 SBOMとは？ SBOM（Software Bill of Materials）は、ソフトウェアの「部品表」です。アプリケーションが使用しているすべての依存関係（ライブラリ、パッケージ）を一覧化したドキュメントで、以下の目的で使用されます： サプライチェーンの透明性: ソフトウェアに含まれる全コンポーネントを明示 脆弱性管理: 依存関係の脆弱性を追跡・修正 ライセンスコンプライアンス: 使用ライブラリのライセンスを確認 監査証跡: セキュリティ監査やコンプライアンスチェックに利用 wtプロジェクトのSBOM wtプロジェクトは、各リリースに対して以下を提供します： ✅ SPDX 2.3形式のSBOM - ISO/IEC 5962:2021準拠 ✅ GitHub依存関係グラフ統合 - Dependabot/Renovateアラート自動有効化 ✅ リリースアセット添付 - 誰でもダウンロード可能 ユーザー向けガイド SBOMの取得方法 方法1: GitHubリリースからダウンロード（推奨） wtのリリースページにアクセス 使用しているバージョンを選択（例: v1.0.0） Assets セクションから wt-v1.0.0-sbom.spdx.json をダウンロード # コマンドラインでダウンロード（Linux/macOS） curl -L https://github.com/kuju63/wt/releases/download/v1.0.0/wt-v1.0.0-sbom.spdx.json \\ -o wt-sbom.spdx.json 方法2: GitHub依存関係グラフから確認 wtリポジトリにアクセス Insights タブをクリック Dependency graph を選択 すべての依存関係とバージョンを確認 SBOMの検証 SBOMが正しいフォーマットか検証する方法： # jqを使用したオフライン検証（推奨） SBOM_FILE=\"wt-sbom.spdx.json\" # 必須フィールドの検証 jq -e '.spdxVersion, .dataLicense, .name, .documentNamespace, .creationInfo.created, .packages' \"$SBOM_FILE\" > /dev/null && echo \"✅ SBOM validation passed\" || echo \"❌ SBOM validation failed\" # 詳細な検証結果を表示 echo \"SPDX Version: $(jq -r '.spdxVersion' \"$SBOM_FILE\")\" echo \"Data License: $(jq -r '.dataLicense' \"$SBOM_FILE\")\" echo \"Document Name: $(jq -r '.name' \"$SBOM_FILE\")\" echo \"Package Count: $(jq '.packages | length' \"$SBOM_FILE\")\" 成功時の出力： ✅ SBOM validation passed SPDX Version: SPDX-2.2 Data License: CC0-1.0 Document Name: kuju63/wt v1.0.0 Package Count: 7 SBOMの内容を確認 依存関係の一覧表示 # jqを使用してパッケージ名とバージョンを抽出 jq -r '.packages[] | \"\\(.name)@\\(.versionInfo)\"' wt-sbom.spdx.json 出力例： System.CommandLine@2.0.1 System.IO.Abstractions@22.1.0 System.Memory@4.5.5 ... ライセンス情報の確認 # パッケージ名とライセンスを表示 jq -r '.packages[] | \"\\(.name): \\(.licenseDeclared)\"' wt-sbom.spdx.json 出力例： System.CommandLine: MIT System.IO.Abstractions: MIT System.Memory: MIT ... 脆弱性チェック 方法1: GitHub Dependabot（自動） wtプロジェクトは自動的にDependabotが有効化されており、脆弱性が発見されると： リポジトリの Security タブにアラート表示 メンテナに自動通知 可能であれば自動修正PRが作成される 方法2: ローカルでのスキャン # OSV Scannerを使用（推奨） osv-scanner --sbom=wt-sbom.spdx.json # Grypeを使用 grype sbom:wt-sbom.spdx.json エンタープライズ向け: SBOM統合 1. Dependency-Trackへのインポート # Dependency-Track APIを使用 curl -X POST \"https://your-dependency-track.com/api/v1/bom\" \\ -H \"X-Api-Key: YOUR_API_KEY\" \\ -H \"Content-Type: application/json\" \\ -d @wt-sbom.spdx.json 2. コンプライアンスチェック # SPDX Toolsを使用してライセンスコンプライアンスを確認 spdx-tools verify wt-sbom.spdx.json 開発者向けガイド ローカルでのSBOM生成 開発中にローカルでSBOMを生成する方法： 1. Microsoft SBOM Toolのインストール dotnet tool install --global Microsoft.Sbom.DotNetTool 2. 依存関係のリストア cd /path/to/wt dotnet restore --locked-mode 3. SBOM生成 sbom-tool generate \\ -b ./sbom-output \\ -bc . \\ -pn kuju63/wt \\ -pv 1.0.0-dev \\ -nsb https://github.com/kuju63/wt/sbom/dev パラメータ説明 -b: 出力ディレクトリ -bc: ビルドコンポーネントのルートパス -pn: パッケージ名 -pv: バージョン -nsb: 名前空間URI（一意性保証） 生成されたSBOMは ./sbom-output/_manifest/spdx_2.2/manifest.spdx.json に出力されます。 CI/CDでの動作確認 PR時の自動テスト（推奨） Pull Requestを作成すると、SBOM生成テストが自動実行されます： # ブランチを作成してPRを開く git checkout -b feature/add-dependency git push origin feature/add-dependency gh pr create --title \"Add new dependency\" # テスト結果を確認 gh pr checks PR時テストで確認される項目： ✅ 依存関係のリストアが成功するか ✅ SBOM生成が成功するか ✅ SPDX 2.3フォーマットが正しいか ✅ 必須パッケージ（System.CommandLine等）が含まれているか ✅ パフォーマンス目標（15分以内）を満たしているか 重要: PR時の制限事項 ❌ GitHub Dependency Graphへのアップロードは行いません ❌ Dependency Submission APIは呼び出しません ✅ SBOM生成とフォーマット検証のみ実行（Dry-runモード） 理由: PR時の依存関係はまだ確定していない（レビュー中） mainブランチの依存関係グラフを汚染しない テスト目的のみ（リリース前の品質確認） これにより、リリース前に不具合を発見しつつ、本番環境を汚染しません。 PR時 vs リリース時の比較 項目 PR時（sbom-test.yml） リリース時（release.yml） 依存関係リストア ✅ 実行 ✅ 実行 SBOM生成 ✅ 実行 ✅ 実行 SPDX検証 ✅ 実行 ✅ 実行 Dependency Graph送信 ❌ 送信しない ✅ 送信する リリースアセット添付 ❌ なし ✅ 添付する Dependabotアラート ❌ 更新なし ✅ 自動有効化 目的 テスト・品質確認 本番デプロイ 実行タイミング PR作成・更新時 mainへのマージ時 ポイント: PR時は「SBOM生成が成功するか」のみをテストし、実際のGitHub統合（Dependency Graph、Dependabot）はリリース時のみ実行されます。 ワークフローの手動実行 # リリースワークフローを手動トリガー gh workflow run release.yml \\ --ref feature/your-branch # SBOM テストワークフローを手動実行 gh workflow run sbom-test.yml \\ --ref feature/your-branch # 実行状況の確認 gh run list --workflow=release.yml --limit 1 gh run list --workflow=sbom-test.yml --limit 1 ローカルでのワークフロー検証 # act を使用してGitHub Actionsをローカル実行 act release --secret GITHUB_TOKEN=your_token SBOM生成のカスタマイズ プラットフォーム固有の依存関係を含める # 特定のランタイムIDで生成 dotnet restore --locked-mode -r win-x64 sbom-tool generate -b ./sbom-output -bc . -pn kuju63/wt -pv 1.0.0 -nsb https://github.com/kuju63/wt/sbom/1.0.0 追加メタデータの付与 # 環境変数で追加情報を設定 export SBOM_BUILD_ID=\"12345\" export SBOM_BUILD_URL=\"https://github.com/kuju63/wt/actions/runs/12345\" sbom-tool generate \\ -b ./sbom-output \\ -bc . \\ -pn kuju63/wt \\ -pv 1.0.0 \\ -nsb https://github.com/kuju63/wt/sbom/1.0.0 \\ -m build_id=$SBOM_BUILD_ID \\ -m build_url=$SBOM_BUILD_URL 新しい依存関係の追加時 新しいNuGetパッケージを追加する際の手順： 依存関係を追加 dotnet add wt.cli/wt.cli.csproj package NewPackage ロックファイルを更新 dotnet restore --locked-mode SBOM生成をテスト sbom-tool generate -b ./test-sbom -bc . -pn kuju63/wt -pv test -nsb https://github.com/kuju63/wt/sbom/test jq '.packages[] | select(.name==\"NewPackage\")' ./test-sbom/_manifest/spdx_2.2/manifest.spdx.json リリース時に自動反映: リリースワークフローが自動的に新しい依存関係を含むSBOMを生成 GitHub Dependency Submission APIのテスト 1. スナップショットファイルの準備 # SBOMからDependency Snapshot形式に変換（スクリプトが必要） python scripts/spdx-to-snapshot.py \\ --spdx sbom-output/_manifest/spdx_2.2/manifest.spdx.json \\ --output snapshot.json \\ --sha $(git rev-parse HEAD) \\ --ref refs/heads/$(git branch --show-current) 2. API呼び出し # GitHub CLIを使用（推奨） gh api \\ --method POST \\ -H \"Accept: application/vnd.github+json\" \\ -H \"X-GitHub-Api-Version: 2022-11-28\" \\ /repos/kuju63/wt/dependency-graph/snapshots \\ --input snapshot.json # curlを使用 curl -X POST \\ -H \"Authorization: Bearer $GITHUB_TOKEN\" \\ -H \"Accept: application/vnd.github+json\" \\ -H \"X-GitHub-Api-Version: 2022-11-28\" \\ https://api.github.com/repos/kuju63/wt/dependency-graph/snapshots \\ -d @snapshot.json 3. 依存関係グラフの確認 # GitHub CLIで依存関係グラフを取得 gh api /repos/kuju63/wt/dependency-graph/sbom # ブラウザで確認 open \"https://github.com/kuju63/wt/network/dependencies\" トラブルシューティング よくある問題と解決方法 問題1: SBOM生成が失敗する 症状: Error: No packages found in the build directory 原因: 依存関係が復元されていない 解決方法: # 依存関係をリストア dotnet restore --locked-mode # SBOM生成を再実行 sbom-tool generate -b ./sbom-output -bc . -pn kuju63/wt -pv 1.0.0 -nsb https://github.com/kuju63/wt/sbom/1.0.0 問題2: GitHub API呼び出しが403 Forbiddenで失敗 症状: Error: Resource not accessible by integration 原因: GITHUB_TOKENの権限不足 解決方法: # .github/workflows/release.ymlで権限を設定 permissions: contents: write id-token: write 問題3: SBOMに一部の依存関係が含まれていない 症状: NuGetパッケージの一部がSBOMに表示されない 原因: プラットフォーム固有の依存関係が復元されていない 解決方法: # すべてのターゲットプラットフォームで復元 dotnet restore --locked-mode -r win-x64 dotnet restore --locked-mode -r linux-x64 dotnet restore --locked-mode -r linux-arm dotnet restore --locked-mode -r osx-arm64 # SBOM生成 sbom-tool generate -b ./sbom-output -bc . -pn kuju63/wt -pv 1.0.0 -nsb https://github.com/kuju63/wt/sbom/1.0.0 問題4: ワークフローがタイムアウトする 症状: GitHub Actionsが15分でタイムアウト 原因: 大規模な依存関係ツリー 解決方法: # キャッシュを有効化 - uses: actions/cache@v4 with: path: ~/.nuget/packages key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }} # タイムアウトを延長（最大60分） timeout-minutes: 30 問題5: PR時のテストが失敗する 症状: SBOM生成テストワークフロー（sbom-test.yml）がPRで失敗 原因: 新しい依存関係が追加されたが、packages.lock.jsonが更新されていない 必須パッケージが誤って削除された SBOMフォーマットが無効 解決方法: # ロックファイルを更新 dotnet restore --locked-mode # ローカルでSBOM生成をテスト sbom-tool generate -b ./test-sbom -bc . -pn test -pv test -nsb https://test # SPDXバリデーション（jqベース） SBOM_FILE=\"./test-sbom/_manifest/spdx_2.2/manifest.spdx.json\" jq -e '.spdxVersion, .dataLicense, .name, .documentNamespace, .creationInfo.created, .packages' \"$SBOM_FILE\" > /dev/null && echo \"✅ Validation passed\" || echo \"❌ Validation failed\" # 変更をコミット git add wt.cli/packages.lock.json git commit -m \"fix: update packages.lock.json\" git push 確認項目: packages.lock.jsonが最新か？ 必須パッケージ（System.CommandLine、System.IO.Abstractions）が残っているか？ ローカルでSBOM生成が成功するか？ デバッグ方法 詳細ログの有効化 # SBOM Tool詳細ログ sbom-tool generate \\ -b ./sbom-output \\ -bc . \\ -pn kuju63/wt \\ -pv 1.0.0 \\ -nsb https://github.com/kuju63/wt/sbom/1.0.0 \\ -v Diagnostic # ログレベル: Diagnostic, Information, Warning, Error # GitHub Actions詳細ログ - name: Generate SBOM run: sbom-tool generate ... env: ACTIONS_STEP_DEBUG: true SBOM内容の詳細確認 # すべてのパッケージ情報を表示 jq '.packages[]' wt-sbom.spdx.json # 特定パッケージの依存関係を表示 jq '.relationships[] | select(.spdxElementId | contains(\"System.CommandLine\"))' wt-sbom.spdx.json # ドキュメントメタデータを表示 jq '{version: .spdxVersion, name: .name, created: .creationInfo.created}' wt-sbom.spdx.json 追加リソース ドキュメント SPDX仕様 Microsoft SBOM Tool GitHub Dependency Submission API Package URL仕様 ツール jq - JSON処理ツール（SBOM検証に使用、推奨） OSV Scanner - 脆弱性スキャン Grype - 脆弱性検出 Dependency-Track - SBOMプラットフォーム コミュニティ Issue報告 Discussion サポート 質問や問題がある場合は、以下の方法でお問い合わせください： GitHub Issues: https://github.com/kuju63/wt/issues GitHub Discussions: https://github.com/kuju63/wt/discussions 最終更新: 2026-01-06"
  },
  "specs/004-complete-sbom-generation/research.html": {
    "href": "specs/004-complete-sbom-generation/research.html",
    "title": "Phase 0: Research & Technical Investigation | wt",
    "summary": "Phase 0: Research & Technical Investigation 完全なSBOM生成機能の実装に必要な技術調査結果をまとめます。 1. Microsoft SBOM Tool 決定事項 選定ツール: Microsoft SBOM Tool (sbom-tool) バージョン: 最新安定版（GitHub Actions内でインストール） 実行方式: GitHub Actions ワークフロー内でdotnet toolとして実行 選定理由 Microsoft公式: .NETエコシステムの標準ツール SPDX 2.3+対応: ISO/IEC 5962:2021準拠のフォーマット生成 CI/CD統合: GitHub Actionsとの統合が容易 依存関係解決: .NETプロジェクトの依存関係を完全に解析 マルチプラットフォーム: Windows/Linux/macOSで動作 検討した代替案 CycloneDX Generator: より汎用的だが.NET専門性が低い → 却下 OWASP Dependency-Check: 脆弱性スキャンに特化、SBOM生成は副次的 → 却下 Syft/Grype: コンテナイメージ向け、.NETプロジェクトには過剰 → 却下 実装詳細 インストール方法 - name: Install Microsoft SBOM Tool run: dotnet tool install --global Microsoft.Sbom.DotNetTool SBOM生成コマンド - name: Generate SBOM run: | sbom-tool generate \\ -b ${{ github.workspace }}/_manifest \\ -bc ${{ github.workspace }} \\ -pn ${{ github.repository }} \\ -pv ${{ steps.version.outputs.version }} \\ -nsb https://github.com/${{ github.repository }} パラメータ説明 -b: SBOM出力ディレクトリ -bc: ビルドコンポーネントのルートパス -pn: パッケージ名 -pv: パッケージバージョン -nsb: 名前空間URI（一意性を保証） 2. SPDX 2.3+ Format 決定事項 フォーマット: SPDX 2.3 (JSON形式) 標準準拠: ISO/IEC 5962:2021 ファイル名: sbom.spdx.json 選定理由 ISO標準: 国際標準として認定されている 政府要求: 米国政府や多くの規制でSPDXを要求 Microsoft推奨: Microsoft SBOM Toolのデフォルト形式 ツールサポート: 多くのツールがSPDXをサポート 長期保守性: 標準化団体（Linux Foundation）による継続的メンテナンス 検討した代替案 CycloneDX: より軽量で開発者フレンドリーだが、ISO標準ではない → 却下 SWID Tags: レガシー形式、現代のCI/CDには不向き → 却下 SPDX 2.3の主要要素 必須フィールド { \"spdxVersion\": \"SPDX-2.3\", \"dataLicense\": \"CC0-1.0\", \"SPDXID\": \"SPDXRef-DOCUMENT\", \"name\": \"wt CLI Tool\", \"documentNamespace\": \"https://github.com/kuju63/wt/...\", \"creationInfo\": { \"created\": \"2026-01-06T...\", \"creators\": [\"Tool: Microsoft.Sbom.Tool-...\"] }, \"packages\": [...] } パッケージ情報 { \"SPDXID\": \"SPDXRef-Package-...\", \"name\": \"System.CommandLine\", \"versionInfo\": \"2.0.1\", \"downloadLocation\": \"https://www.nuget.org/packages/...\", \"licenseConcluded\": \"MIT\", \"licenseDeclared\": \"MIT\", \"copyrightText\": \"...\", \"externalRefs\": [...] } ライセンス情報の扱い 利用可能: SPDX License Identifier（例: MIT, Apache-2.0） 不明の場合: NOASSERTION を使用（FR-017に準拠） 複数ライセンス: SPDX License Expressionで表現（例: MIT OR Apache-2.0） 3. GitHub Dependency Submission API 決定事項 API: GitHub Dependency Submission API v1 認証: GITHUB_TOKEN（自動提供） 権限: contents: write および id-token: write 選定理由 ネイティブ統合: GitHub依存関係グラフへの直接統合 Dependabot有効化: 自動的にセキュリティアラートを有効化 Renovate対応: 同じAPIを利用して依存関係を管理 トークン不要: GITHUB_TOKENで自動認証 リアルタイム更新: リリース時に依存関係グラフを即座に更新 検討した代替案 手動アップロード: スケーラビリティが低い → 却下 Dependency Graph Export: 読み取り専用、更新不可 → 却下 サードパーティツール: 追加依存関係が発生 → 却下 API仕様 エンドポイント POST /repos/{owner}/{repo}/dependency-graph/snapshots リクエストボディ（簡略版） { \"version\": 0, \"sha\": \"${{ github.sha }}\", \"ref\": \"${{ github.ref }}\", \"job\": { \"correlator\": \"${{ github.workflow }}-${{ github.job }}\", \"id\": \"${{ github.run_id }}\" }, \"detector\": { \"name\": \"Microsoft SBOM Tool\", \"version\": \"...\" }, \"scanned\": \"2026-01-06T...\", \"manifests\": { \"wt.cli.csproj\": { \"name\": \"wt.cli\", \"resolved\": { \"System.CommandLine@2.0.1\": { \"package_url\": \"pkg:nuget/System.CommandLine@2.0.1\", \"relationship\": \"direct\", \"scope\": \"runtime\", \"dependencies\": [...] } } } } } 実装方法（GitHub Actions） - name: Submit dependencies to GitHub uses: actions/dependency-submission@v3 with: sbom-file: _manifest/sbom.spdx.json snapshot-format: spdx エラーハンドリング APIレート制限: GitHub Actions内では通常問題なし（時間あたり5000リクエスト） 認証失敗: パイプライン全体を失敗（FR-013） ネットワークエラー: 3回リトライ後に失敗 レスポンス検証: 201 Created以外は失敗扱い 4. 依存関係の復元（dotnet restore） 決定事項 コマンド: dotnet restore --locked-mode 実行タイミング: SBOM生成直前 キャッシュ戦略: GitHub Actionsのキャッシュアクションを使用 選定理由 完全性保証: すべての依存関係を確実にダウンロード ロックファイル整合性: --locked-modeで packages.lock.json との一致を検証 再現性: ロックファイルにより同一の依存関係ツリーを保証 パフォーマンス: キャッシュにより高速化 検討した代替案 restore省略: 不完全なSBOMが生成される → 却下（問題の原因） build実行: ビルド成果物が不要、時間がかかる → 却下 キャッシュなし: 毎回ダウンロードで遅い → 却下 実装詳細 基本コマンド - name: Restore dependencies run: dotnet restore --locked-mode キャッシュ設定 - name: Cache NuGet packages uses: actions/cache@v4 with: path: ~/.nuget/packages key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }} restore-keys: | ${{ runner.os }}-nuget- タイムアウト設定 - name: Restore dependencies run: dotnet restore --locked-mode timeout-minutes: 15 # FR-014: 15分タイムアウト 条件付き依存関係の処理（FR-016） # すべてのターゲットフレームワークとプラットフォームの依存関係を復元 - name: Restore for all platforms run: | dotnet restore --locked-mode -r win-x64 dotnet restore --locked-mode -r linux-x64 dotnet restore --locked-mode -r linux-arm dotnet restore --locked-mode -r osx-arm64 5. パフォーマンスとタイムアウト 決定事項 50依存関係: 5分以内（目標: 3分） 200依存関係: 15分以内（目標: 10分） タイムアウト: 15分（FR-014） 並列化: 可能な箇所で並列実行 最適化戦略 1. NuGetキャッシュ - uses: actions/cache@v4 with: path: ~/.nuget/packages key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }} 効果: 2回目以降のリストアを80%高速化 2. SBOM生成の並列化 # 複数プラットフォームのSBOM生成を並列実行 strategy: matrix: platform: [win-x64, linux-x64, linux-arm, osx-arm64] 効果: 総所要時間を25%短縮（4プラットフォーム同時実行） 3. 段階的タイムアウト - name: Restore dependencies timeout-minutes: 5 # 通常は5分で完了 - name: Generate SBOM timeout-minutes: 10 # SBOM生成に最大10分 4. プログレス表示 - name: Restore with progress run: dotnet restore --verbosity normal 6. リリースアセットとしてのSBOM添付 決定事項 ファイル名: wt-{version}-sbom.spdx.json アップロード先: GitHub Releases 公開設定: パブリック（誰でもダウンロード可能） 選定理由 アクセス性: ユーザーが簡単にダウンロード可能 バージョン管理: 各リリースに対応するSBOMを保持 監査証跡: 過去のリリースのSBOMも参照可能 標準プラクティス: 多くのOSSプロジェクトが採用 実装方法 - name: Upload SBOM to Release uses: softprops/action-gh-release@v1 with: files: _manifest/sbom.spdx.json name: wt-${{ steps.version.outputs.version }}-sbom.spdx.json env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} 7. テスト戦略 決定事項 PR時のテスト: Pull Request作成時にSBOM生成をテスト（リリース前検証） 専用テストワークフロー: SBOM生成とバリデーションのみを行う独立したワークフロー E2Eテスト: 実際のリリースワークフローで最終検証 SBOM検証: SPDXスキーマバリデーターでフォーマット検証 統合テスト: GitHub APIとの統合を確認（Dry-runモード使用） 選定理由 早期不具合発見: PRの段階でSBOM生成をテストし、リリース前に問題を検出 開発サイクル高速化: リリースを待たずにSBOM機能をテスト可能 継続的検証: mainブランチへのマージ前に品質を保証 リスク低減: リリースパイプラインの失敗を防止 テスト項目 1. SBOM生成テスト（PR時に実行） # .github/workflows/sbom-test.yml name: SBOM Generation Test on: pull_request: branches: [main] paths: - 'wt.cli/**' - '**/packages.lock.json' - '.github/workflows/release.yml' - '.github/workflows/sbom-test.yml' workflow_dispatch: jobs: test-sbom-generation: runs-on: ubuntu-latest timeout-minutes: 15 steps: - uses: actions/checkout@v4 - name: Setup .NET uses: actions/setup-dotnet@v4 with: dotnet-version: '10.0.x' - name: Cache NuGet packages uses: actions/cache@v4 with: path: ~/.nuget/packages key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }} - name: Restore dependencies run: dotnet restore --locked-mode timeout-minutes: 5 - name: Install Microsoft SBOM Tool run: dotnet tool install --global Microsoft.Sbom.DotNetTool - name: Generate SBOM run: | sbom-tool generate \\ -b ${{ github.workspace }}/_manifest \\ -bc ${{ github.workspace }} \\ -pn ${{ github.repository }} \\ -pv test-${{ github.sha }} \\ -nsb https://github.com/${{ github.repository }}/sbom/test timeout-minutes: 10 - name: Validate SBOM format run: | SBOM_FILE=\"_manifest/_manifest/spdx_2.2/manifest.spdx.json\" # jqベースのオフラインバリデーション jq -e '.spdxVersion, .dataLicense, .name, .documentNamespace, .creationInfo.created, .packages' \"$SBOM_FILE\" > /dev/null || exit 1 echo \"✅ SBOM validation passed\" - name: Verify SBOM content run: | # パッケージ数をチェック（最低限の依存関係を確認） package_count=$(jq '.packages | length' _manifest/_manifest/spdx_2.2/manifest.spdx.json) echo \"Package count: $package_count\" if [ \"$package_count\" -lt 2 ]; then echo \"::error::SBOM contains too few packages ($package_count)\" exit 1 fi # 必須パッケージの存在確認 required_packages=(\"System.CommandLine\" \"System.IO.Abstractions\") for pkg in \"${required_packages[@]}\"; do if ! jq -e \".packages[] | select(.name==\\\"$pkg\\\")\" _manifest/_manifest/spdx_2.2/manifest.spdx.json > /dev/null; then echo \"::error::Required package '$pkg' not found in SBOM\" exit 1 fi echo \"✓ Found required package: $pkg\" done - name: Test Dependency Submission (Dry-run) run: | echo \"================================================\" echo \" IMPORTANT: PR時はGitHub APIに送信しません\" echo \" - Dependency Graphへのアップロード: なし\" echo \" - 実際のAPI送信: リリース時のみ\" echo \" - このステップ: フォーマット検証のみ\" echo \"================================================\" # NOTE: PR時は実際にAPIに送信しない（Dry-runモード） # 理由: # 1. PR時の依存関係はまだ確定していない # 2. mainブランチの依存関係グラフを汚染しない # 3. テスト目的のみ（SBOM生成が成功するか確認） - name: Upload SBOM artifact uses: actions/upload-artifact@v4 with: name: test-sbom path: _manifest/_manifest/spdx_2.2/manifest.spdx.json retention-days: 7 2. パフォーマンステスト - name: Performance benchmark run: | start_time=$(date +%s) dotnet restore --locked-mode sbom-tool generate \\ -b ${{ github.workspace }}/_manifest \\ -bc ${{ github.workspace }} \\ -pn ${{ github.repository }} \\ -pv test \\ -nsb https://github.com/${{ github.repository }}/sbom/test end_time=$(date +%s) duration=$((end_time - start_time)) echo \"Duration: ${duration}s (Target: <900s)\" # パフォーマンスレポート if [ $duration -gt 900 ]; then echo \"::error::Exceeded 15-minute timeout: ${duration}s\" exit 1 elif [ $duration -gt 300 ]; then echo \"::warning::Slower than 5-minute target: ${duration}s\" else echo \"✓ Performance target met: ${duration}s\" fi 3. マルチプラットフォームテスト strategy: matrix: os: [ubuntu-latest, windows-latest, macos-latest] steps: - name: Test SBOM generation on ${{ matrix.os }} run: | dotnet restore --locked-mode sbom-tool generate -b ./sbom -bc . -pn test -pv 1.0.0 -nsb https://test 8. エラーハンドリング 決定事項 API失敗: パイプライン全体を失敗（FR-013） リトライ: ネットワークエラーは3回まで ロギング: 詳細なエラーメッセージを出力 エラーシナリオ 1. dotnet restore失敗 - name: Restore dependencies run: dotnet restore --locked-mode continue-on-error: false # 失敗時はパイプライン停止 2. SBOM生成失敗 - name: Generate SBOM run: sbom-tool generate ... continue-on-error: false 3. GitHub API失敗 - name: Submit to GitHub uses: actions/dependency-submission@v3 with: sbom-file: _manifest/sbom.spdx.json continue-on-error: false # FR-013: API失敗は全体失敗 研究成果のまとめ 解決された不明点 Microsoft SBOM Tool統合: dotnet tool installで簡単に導入可能 SPDX 2.3+要件: JSONフォーマットでISO標準準拠 GitHub Dependency Submission API: actions/dependency-submission@v3で簡単に統合 パフォーマンス最適化: キャッシュ戦略と並列化で目標達成可能 エラーハンドリング: すべての失敗でパイプライン停止により品質保証 技術的リスク リスク 影響 軽減策 GitHub APIレート制限 低 GitHub Actions内では通常問題なし 大規模ソリューションのタイムアウト 中 キャッシュと並列化で対応 SPDX検証ツールの互換性 低 Microsoft SBOM Toolは標準準拠 条件付き依存関係の漏れ 中 全プラットフォームでリストアを実行 リリース時の不具合発見 高 PR時テストワークフローで事前検証 テスト環境とリリース環境の差異 中 同じワークフロー定義を共有 次のステップ（Phase 1） data-model.md作成: SBOM生成に必要なデータモデル定義（必要最小限） contracts/作成: GitHub Dependency Submission APIコントラクト quickstart.md作成: 開発者とユーザー向けガイド agent context更新: Copilotエージェントに技術スタック追加"
  },
  "specs/004-complete-sbom-generation/spec.html": {
    "href": "specs/004-complete-sbom-generation/spec.html",
    "title": "機能仕様書: リリースパイプラインにおける完全なSBOM生成 | wt",
    "summary": "機能仕様書: リリースパイプラインにおける完全なSBOM生成 機能ブランチ: 004-complete-sbom-generation 作成日: 2026-01-06 ステータス: ドラフト 入力: ユーザー記述: \"SBOMの生成時にプロジェクトのリストアを行っていないため、完全なSBOMが生成されない。現在のリリースパイプラインを変更して、完全な依存関係を含むSBOMを生成できるようにする。これにより、生成物のサプライチェーンの透明性を担保し、ユーザーが生成物の信頼性をチェックできるようにする。\" Clarifications Session 2026-01-06 Q: GitHub Dependency Submission APIへの送信が失敗した場合、パイプライン全体を失敗させるべきか？ → A: パイプラインを失敗させる - API送信は必須、失敗時は全体を停止 Q: SBOM形式はSPDXとCycloneDXのどちらを優先すべきか？ → A: SPDX 2.3+ - Microsoftツールとの互換性、ISO標準 Q: 大規模ソリューションでのSBOM生成のタイムアウト値はどうすべきか？ → A: 15分タイムアウト - 大規模対応、キャッシング推奨 Q: 条件付き依存関係（プラットフォーム固有または構成固有）の処理方法は？ → A: すべて含む - 全プラットフォーム/構成の依存関係を含む Q: ライセンス情報が利用できない依存関係の処理方法は？ → A: NOASSERTIONマーク - SPDX標準に従い警告記録 ユーザーシナリオとテスト (必須) ユーザーストーリー1 - 完全な依存関係の開示 (優先度: P1) セキュリティ監査者またはエンドユーザーとして、使用または評価しているソフトウェアのサプライチェーンの整合性を検証し、潜在的なセキュリティ脆弱性を特定できるように、すべてのプロジェクト依存関係を含む完全なソフトウェア部品表（SBOM: Software Bill of Materials）を確認する必要がある。 この優先度の理由: これは中心的な要件です。SBOMに完全な依存関係情報がなければ、ユーザーは正確なセキュリティ評価やコンプライアンスチェックを実行できず、SBOM生成の主要な目的が損なわれます。 独立テスト: リリースパイプラインからSBOMを生成し、プロジェクトファイルに記載されている実際のプロジェクト依存関係と比較し、すべての依存関係（直接的および推移的）が生成されたSBOMに含まれていることを検証することで完全にテストできます。 受入シナリオ: 前提条件 ビルドのためにリリースパイプラインがトリガーされる、操作 SBOM生成ステップが実行される、期待結果 生成されたSBOMにプロジェクトファイルで宣言されたすべての直接依存関係が含まれている 前提条件 推移的依存関係を持つプロジェクト、操作 SBOMが生成される、期待結果 SBOMに完全な依存関係チェーンを持つすべての推移的依存関係が含まれている 前提条件 マルチプロジェクトソリューション、操作 SBOMが生成される、期待結果 SBOMにソリューション内のすべてのプロジェクトからの依存関係が含まれている 前提条件 プラットフォーム固有の依存関係を持つプロジェクト、操作 SBOMが生成される、期待結果 SBOMにすべてのターゲットプラットフォームの依存関係が含まれている ユーザーストーリー2 - SBOMの検証 (優先度: P2) DevOpsエンジニアとして、リリース成果物を公開する前に生成されたSBOMが完全かつ正確であることを検証し、ユーザーに信頼できるサプライチェーン情報を提供できるようにする必要がある。 この優先度の理由: 検証は重要ですが、生成の次に来るものです。ユーザーはまず完全なSBOMを必要とし、検証は段階的に追加できます。 独立テスト: SBOMの内容を復元されたプロジェクト依存関係と比較し、不一致を報告する検証ステップを実装することでテストできます。 受入シナリオ: 前提条件 SBOMが生成されている、操作 検証ステップが実行される、期待結果 すべての依存関係が含まれている場合は成功、依存関係が不足している場合は失敗を報告する 前提条件 検証が失敗した場合、操作 パイプラインログを確認する、期待結果 不足または不完全な依存関係が明確にリストされている 前提条件 検証が成功した場合、操作 リリース成果物が公開される、期待結果 SBOMがリリースパッケージに含まれている ユーザーストーリー3 - SBOM形式の準拠 (優先度: P3) コンプライアンス担当者として、生成されたSBOMが業界標準形式（SPDXやCycloneDXなど）に従っていることで、標準的なツールを使用してSBOMを分析し、セキュリティインフラストラクチャに統合できるようにする必要がある。 この優先度の理由: 形式の準拠はツールの相互運用性にとって重要ですが、完全性を確保することよりも重要度は低いです。ほとんどのSBOM生成ツールはすでに標準形式をサポートしています。 独立テスト: 生成されたSBOMを公式のSPDXまたはCycloneDXスキーマバリデーターで検証することでテストできます。 受入シナリオ: 前提条件 SBOMが生成される、操作 SPDX 2.3+スキーマに対して検証される、期待結果 エラーなしで検証に合格する 前提条件 SPDX形式のSBOM、操作 一般的なSBOM分析ツールに読み込む、期待結果 ツールがエラーなしで解析および分析できる ユーザーストーリー4 - GitHubへのSBOM統合 (優先度: P2) 開発者またはセキュリティ担当者として、生成されたSBOMがGitHubの依存関係グラフに自動的に統合され、DependabotアラートやGitHubのセキュリティ機能を活用できるようにする必要がある。 この優先度の理由: GitHubエコシステムとの統合により、セキュリティ脆弱性の自動検出とアラートが可能になり、長期的な保守性が向上します。P2とするのは、基本的なSBOM生成（P1）の後に実装すべき重要な機能だからです。 独立テスト: パイプラインがGitHubのDependency Submission APIにSBOMを送信し、GitHubの依存関係グラフでSBOM情報が表示されることを確認することでテストできます。 受入シナリオ: 前提条件 SBOMが生成された後、操作 Dependency Submission APIにSBOMを送信する、期待結果 GitHubの依存関係グラフにすべての依存関係が表示される 前提条件 脆弱性のある依存関係が含まれている、操作 SBOMをGitHubに送信する、期待結果 Dependabotアラートが自動的に生成される 前提条件 リリースが公開される、操作 SBOMファイルがリリース成果物として添付される、期待結果 ユーザーがリリースページからSBOMファイルをダウンロードできる 前提条件 RenovateがリポジトリにインストールされSBOMが送信されている、操作 依存関係の新しいバージョンがリリースされる、期待結果 Renovateが依存関係グラフの情報を読み取り、バージョンアップのPRを自動作成する エッジケース SBOM生成ステップ中にプロジェクトの復元が失敗した場合はどうなるか？ 回答: パイプラインは失敗し、リリースは中止される（FR-004） システムは条件付き依存関係（プラットフォーム固有または構成固有）をどのように処理するか？ 回答: すべてのターゲットプラットフォームおよびビルド構成に対する依存関係を含む（FR-016） 復元中に依存関係が解決またはダウンロードできない場合はどうなるか？ 回答: パイプラインは失敗し、エラーログに詳細を記録（FR-007） パイプラインは、タイムアウトせずに多数のプロジェクトと依存関係を持つ大規模なソリューションをどのように処理するか？ 回答: 15分のタイムアウトを設定し、超過した場合は失敗。依存関係キャッシングの使用を推奨（FR-014、FR-015） プロジェクトに循環依存関係の参照が存在する場合はどうなるか？ 回答: パッケージマネージャーのエラー処理に従い、パイプラインは失敗 GitHub Dependency Submission APIへの送信が失敗した場合、パイプライン全体を失敗させるべきか？ 回答: パイプラインを失敗させる - API送信は必須機能であり、失敗時は全体を停止（FR-011、FR-013） リリース成果物へのSBOMファイルの添付が失敗した場合はどうなるか？ 回答: パイプラインは失敗し、リリースは中止される（FR-005、FR-012） プライベートリポジトリとパブリックリポジトリで、依存関係グラフの動作に違いはあるか？ 回答: はい、プライベートリポジトリでは依存関係グラフを手動で有効化する必要がある場合がある（仮定に記載） 要件 (必須) 機能要件 FR-001: リリースパイプラインは、SBOMを生成する前にプロジェクトの依存関係を復元しなければならない FR-002: SBOM生成は、プロジェクトファイルで宣言されたすべての直接依存関係を含まなければならない FR-003: SBOM生成は、復元中に解決されたすべての推移的依存関係を含まなければならない FR-004: リリースパイプラインは、SBOM生成が失敗した場合、完全なサプライチェーン情報のない成果物のリリースを防ぐために失敗しなければならない FR-005: 生成されたSBOMは、個別のファイルとしてリリース成果物に含まれなければならない FR-006: SBOMは、SPDX 2.3+形式に従わなければならない（ISO/IEC 5962:2021準拠） FR-007: パイプラインは、トラブルシューティングのために復元とSBOM生成プロセスの詳細をログに記録しなければならない FR-008: SBOM生成は、マルチプロジェクトソリューションを正しく処理しなければならない FR-009: SBOMは、各依存関係のバージョン情報を含まなければならない FR-010: SBOMは、各依存関係のライセンス情報を含まなければならない（利用できない場合は\"NOASSERTION\"） FR-011: 生成されたSBOMは、GitHubのDependency Submission APIを使用してGitHubの依存関係グラフに送信しなければならない FR-012: SBOMファイルは、GitHubリリースの成果物として添付しなければならない（ユーザーがダウンロード可能） FR-013: GitHub Dependency Submission APIへの送信が失敗した場合、リリースパイプラインは失敗しなければならない FR-014: SBOM生成プロセス（依存関係の復元と生成）は、15分以内に完了しなければならず、超過した場合はタイムアウトエラーとしてパイプラインを失敗させる FR-015: パイプラインは、依存関係キャッシングを使用して、繰り返しビルドでの復元時間を短縮することが推奨される FR-016: SBOM生成は、すべてのターゲットプラットフォームおよびビルド構成に対する条件付き依存関係を含まなければならない（完全な透明性のため） FR-017: ライセンス情報が利用できない依存関係については、SPDX標準に従い\"NOASSERTION\"値を使用し、警告をログに記録しなければならない FR-018: GitHubの依存関係グラフに送信されたSBOM情報は、RenovateなどのOSS依存関係管理ツールから読み取り可能でなければならない FR-019: Pull Request作成時にSBOM生成を自動テストする専用ワークフローを提供しなければならない（リリース前の不具合検出のため） FR-020: PR時のSBOMテストは、SPDXフォーマット検証、必須パッケージの存在確認、パフォーマンスベンチマークを含まなければならない FR-021: PR時のSBOMテストワークフローは、GitHub Dependency Submission APIを呼び出してはならない（Dry-runモードのみ、本番依存関係グラフを汚染しないため） 主要なエンティティ リリースパイプライン: ソフトウェアリリースをビルド、テスト、公開する自動化されたワークフロー。依存関係の復元とSBOM生成のステップを含む SBOM（ソフトウェア部品表）: すべてのソフトウェアコンポーネント、依存関係、および関連するメタデータ（バージョン、ライセンスなど）をリストする構造化されたドキュメント プロジェクト依存関係: プロジェクトファイル（例: .csproj、package.json）で明示的に宣言された直接依存関係 推移的依存関係: 直接依存関係によって必要とされる間接的な依存関係 リリース成果物: リリースパイプラインの最終出力。コンパイルされたバイナリ、ドキュメント、およびSBOMを含む GitHubの依存関係グラフ: GitHubが提供する依存関係の可視化機能。SBOM情報を統合し、セキュリティアラートと連携する Dependency Submission API: GitHubにSBOMや依存関係情報を送信するためのREST API。依存関係グラフに統合され、Dependabotアラートとセキュリティ更新を有効にする Renovate: OSSで広く利用される依存関係管理ツール。GitHubの依存関係グラフを読み取り、ライブラリのバージョンアップに対して一貫した自動PR作成を提供する 仮定 プロジェクトは、依存関係の復元をサポートする標準的なパッケージ管理システムを使用している Microsoft SBOM Toolまたは同等のSPDX 2.3+互換ツールがプロジェクトタイプと互換性があり、利用可能であるか、統合可能である リリースパイプラインは、復元中に依存関係をダウンロードするためのネットワークアクセスを持っている SPDX 2.3+形式は、ユースケースおよびコンプライアンス要件に対して受け入れ可能である ライセンス情報はパッケージメタデータで利用可能であるか、合理的に推測できる パイプラインインフラストラクチャは、すべての依存関係を復元するための十分なリソース（ディスク容量、メモリ、時間）を持っている リポジトリはGitHub上でホストされており、GitHub ActionsまたはGitHub APIへのアクセスが可能である 適切なGitHubトークン権限（contents: write）がDependency Submission APIの使用に利用可能である GitHubの依存関係グラフ機能が、リポジトリで有効化されている（プライベートリポジトリの場合、手動で有効化が必要な場合がある） 送信されたSBOM情報は、Dependency Submission API経由でGitHubの依存関係グラフに統合され、DependabotおよびRenovateの両方から利用可能である 依存関係 既存のリリースパイプラインインフラストラクチャは、新しいビルドステップの追加をサポートしなければならない パッケージソース（NuGet、npmなど）は、パイプライン実行中にアクセス可能でなければならない SBOM生成ツールは、プロジェクトの技術スタックと互換性がなければならない GitHub Dependency Submission APIは、パイプラインから利用可能でなければならない GitHubリリース機能は、成果物のアップロードをサポートしていなければならない 成功基準 (必須) 測定可能な成果 SC-001: 生成されたSBOMには、プロジェクト依存関係の100%が含まれている（プロジェクトファイルとロックファイルの内容との比較により検証） SC-002: SBOM生成ステップは、一般的なプロジェクトサイズ（最大50の依存関係を持つソリューション）に対して5分以内に完了する SC-003: 大規模ソリューション（最大200の依存関係）でも15分以内にSBOM生成が完了する SC-004: リリースパイプラインは、手動介入なしで95%のビルドでSBOMを正常に生成および公開する SC-005: ユーザーは、標準的なSBOM検証ツールを使用して、エラーなしで生成されたSBOMを正常に検証できる SC-006: 実装後、完全なSBOMなしで公開されるリリースはゼロである SC-007: GitHubの依存関係グラフには、SBOMから送信されたすべての依存関係が表示される SC-008: 脆弱性のある依存関係に対して、GitHubが自動的にDependabotアラートを生成する SC-009: ユーザーは、GitHubリリースページからSBOMファイルをダウンロードできる SC-010: Renovateがインストールされている場合、SBOM情報を読み取り、依存関係の更新PRを自動作成できる SC-011: Pull Request作成時にSBOM生成テストが自動実行され、リリース前に不具合を検出できる SC-012: PR時のSBOMテストは10分以内に完了し、開発サイクルを妨げない"
  },
  "specs/004-complete-sbom-generation/tasks.html": {
    "href": "specs/004-complete-sbom-generation/tasks.html",
    "title": "Tasks: Complete SBOM Generation in Release Pipeline | wt",
    "summary": "Tasks: Complete SBOM Generation in Release Pipeline Branch: 004-complete-sbom-generation Input: Design documents from /specs/004-complete-sbom-generation/ Prerequisites: plan.md ✅, spec.md ✅, research.md ✅, data-model.md ✅, contracts/ ✅ Format: [ID] [P?] [Story] Description [P]: Can run in parallel (different files, no dependencies) [Story]: Which user story this task belongs to (e.g., US1, US2, US3, US4) Include exact file paths in descriptions Phase 1: Setup (Project Initialization) Purpose: Initialize project structure and prerequisite scripts [X] T001 Create ADR document for SBOM generation approach in docs/adr/004-sbom-generation.md [X] T002 [P] Create SBOM usage guide in docs/guides/sbom-usage.md (copy from specs/004-complete-sbom-generation/quickstart.md) [X] T003 [P] Add SBOM section to README.md explaining supply chain transparency Phase 2: Foundational (Blocking Prerequisites) Purpose: Workflow infrastructure that MUST be complete before user story implementation ⚠️ CRITICAL: No user story work can begin until this phase is complete [X] T004 Setup NuGet package caching in .github/workflows/release.yml (FR-015) [X] T005 Configure workflow permissions (contents: write, id-token: write) in .github/workflows/release.yml (FR-011) [X] T006 Add workflow timeout settings (15 minutes) in .github/workflows/release.yml (FR-014) Checkpoint: Foundation ready - user story implementation can now begin Phase 3: User Story 1 - 完全な依存関係の開示 (Priority: P1) \uD83C\uDFAF MVP Goal: Generate complete SBOM with all direct and transitive dependencies Independent Test: Compare generated SBOM with project files to verify 100% dependency coverage Implementation for User Story 1 [X] T007 [US1] Add dependency restore step before SBOM generation in .github/workflows/release.yml (FR-001) [X] T008 [US1] Configure dotnet restore with --locked-mode flag in .github/workflows/release.yml (FR-001, FR-002) [X] T009 [US1] Add multi-platform restore for all target platforms (win-x64, linux-x64, linux-arm, osx-arm64) in .github/workflows/release.yml (FR-016) [X] T010 [US1] Install Microsoft SBOM Tool in workflow in .github/workflows/release.yml (FR-006) [X] T011 [US1] Configure SBOM generation with correct parameters (package name, version, namespace) in .github/workflows/release.yml (FR-002, FR-003, FR-008, FR-009) [X] T012 [US1] Add error handling for restore failures in .github/workflows/release.yml (FR-004) [X] T013 [US1] Add error handling for SBOM generation failures in .github/workflows/release.yml (FR-004) [X] T014 [US1] Add detailed logging for restore and SBOM generation steps in .github/workflows/release.yml (FR-007) Checkpoint: User Story 1 complete - SBOM with all dependencies is generated Phase 4: User Story 2 - SBOMの検証 (Priority: P2) Goal: Validate generated SBOM is complete and accurate before release Independent Test: Run SPDX validator and verify all required packages are present Implementation for User Story 2 [X] T015 [US2] Add SPDX format validation step using jq-based offline validation in .github/workflows/release.yml (FR-006) [X] T016 [US2] Add required package verification step in .github/workflows/release.yml (FR-002) [X] T017 [US2] Verify System.CommandLine and System.IO.Abstractions are present in SBOM in .github/workflows/release.yml (FR-002) [X] T018 [US2] Add package count validation (minimum threshold check) in .github/workflows/release.yml (FR-003) [X] T019 [US2] Add validation failure reporting with detailed error messages in .github/workflows/release.yml (FR-007) [X] T020 [US2] Configure pipeline to fail on validation errors in .github/workflows/release.yml (FR-004) Checkpoint: User Story 2 complete - SBOM validation ensures quality before release Phase 5: User Story 4 - GitHubへのSBOM統合 (Priority: P2) Goal: Integrate SBOM with GitHub Dependency Graph and enable Dependabot/Renovate Independent Test: Verify dependencies appear in GitHub Dependency Graph and Dependabot alerts are generated Implementation for User Story 4 [X] T021 [US4] Add GitHub Dependency Submission API integration using actions/dependency-submission@v3 in .github/workflows/release.yml (FR-011, FR-018) [X] T022 [US4] Configure SBOM file path and snapshot format (spdx) in .github/workflows/release.yml (FR-011) [X] T023 [US4] Add error handling for API submission failures (must fail pipeline) in .github/workflows/release.yml (FR-013) [X] T024 [US4] Add SBOM file upload to GitHub Release assets in .github/workflows/release.yml (FR-005, FR-012) [X] T025 [US4] Configure SBOM filename format (wt-{version}-sbom.spdx.json) in .github/workflows/release.yml (FR-012) [X] T026 [US4] Add error handling for release asset upload failures in .github/workflows/release.yml (FR-004) [X] T027 [US4] Add logging for GitHub API interactions in .github/workflows/release.yml (FR-007) Checkpoint: User Story 4 complete - SBOM is integrated with GitHub ecosystem Phase 6: User Story 3 - SBOM形式の準拠 (Priority: P3) Goal: Ensure SBOM complies with SPDX 2.3+ (ISO/IEC 5962:2021) standards Independent Test: Validate SBOM against official SPDX 2.3 schema Implementation for User Story 3 [X] T028 [US3] Verify Microsoft SBOM Tool generates SPDX 2.3+ format in .github/workflows/release.yml (FR-006) [X] T029 [US3] Add SPDX version verification (must be SPDX-2.3) in .github/workflows/release.yml (FR-006) [X] T030 [US3] Add dataLicense verification (must be CC0-1.0) in .github/workflows/release.yml (FR-006) [X] T031 [US3] Add documentNamespace uniqueness verification in .github/workflows/release.yml (FR-006) [X] T032 [US3] Add NOASSERTION handling for missing license information in .github/workflows/release.yml (FR-010, FR-017) Checkpoint: User Story 3 complete - SBOM format is standards-compliant Phase 7: PR Testing Workflow (Quality Assurance) Goal: Enable early detection of SBOM generation issues before release Independent Test: Create PR and verify SBOM test workflow runs successfully Implementation for PR Testing [X] T033 Create PR test workflow file .github/workflows/sbom-test.yml (FR-019) [X] T034 Configure PR trigger for workflow (on pull_request to main branch) in .github/workflows/sbom-test.yml (FR-019) [X] T035 Add path filters (wt.cli/**, packages.lock.json, workflow files) in .github/workflows/sbom-test.yml (FR-019) [X] T036 [P] Add dependency restore step with caching in .github/workflows/sbom-test.yml (FR-001, FR-015, FR-019) [X] T037 [P] Add SBOM generation step in .github/workflows/sbom-test.yml (FR-019) [X] T038 Add SPDX format validation in .github/workflows/sbom-test.yml (FR-020) [X] T039 Add required package verification (System.CommandLine, System.IO.Abstractions) in .github/workflows/sbom-test.yml (FR-020) [X] T040 Add package count validation in .github/workflows/sbom-test.yml (FR-020) [X] T041 Add performance benchmark (15-minute timeout) in .github/workflows/sbom-test.yml (FR-014, FR-020) [X] T042 Add dry-run comment for GitHub API (no actual submission) in .github/workflows/sbom-test.yml (FR-021) [X] T043 Add SBOM artifact upload for PR review in .github/workflows/sbom-test.yml (FR-019) Checkpoint: PR testing complete - Issues caught before release Phase 8: Polish & Cross-Cutting Concerns Purpose: Performance optimization, documentation, and monitoring [X] T044 [P] Add performance metrics logging (duration tracking) in .github/workflows/release.yml [X] T045 [P] Add cache hit/miss reporting for NuGet packages in .github/workflows/release.yml [X] T046 Update documentation with SBOM download instructions in README.md [X] T047 Add workflow badges for SBOM test status in README.md [X] T048 Create example SBOM file for documentation in docs/examples/sbom.spdx.json [X] T049 [P] Add workflow failure notifications (optional) in .github/workflows/release.yml [X] T050 Update CHANGELOG.md with SBOM feature description Dependencies & Execution Order User Story Completion Order graph TD Setup[Phase 1: Setup] --> Foundation[Phase 2: Foundation] Foundation --> US1[Phase 3: US1 - 完全な依存関係の開示] US1 --> US2[Phase 4: US2 - SBOMの検証] US1 --> US4[Phase 5: US4 - GitHubへのSBOM統合] US2 --> US3[Phase 6: US3 - SBOM形式の準拠] US4 --> US3 US1 --> PR[Phase 7: PR Testing] US2 --> PR US3 --> Polish[Phase 8: Polish] US4 --> Polish PR --> Polish Critical Path Setup (T001-T003) → 2. Foundation (T004-T006) → 3. US1 Core (T007-T014) → 4. US2 Validation (T015-T020) → 5. US4 Integration (T021-T027) → 6. US3 Compliance (T028-T032) → 7. PR Testing (T033-T043) → 8. Polish (T044-T050) Parallel Execution Opportunities After Foundation (T004-T006): T007-T009 (Restore steps) can run independently from documentation tasks T010-T011 (SBOM tool setup) can be prepared in parallel During US2 (Phase 4): T015 (SPDX validation) and T017 (Package verification) can run in parallel During Polish (Phase 8): T044-T045 (Performance metrics), T048 (Example SBOM), T049 (Notifications) are all independent Implementation Strategy MVP Scope (Minimum Viable Product) Target: User Story 1 only Phase 1: Setup (T001-T003) Phase 2: Foundation (T004-T006) Phase 3: US1 (T007-T014) Why: This delivers the core value - complete SBOM generation. Validation, GitHub integration, and testing can be added incrementally. Incremental Delivery Plan Sprint 1 (MVP): T001-T014 - Basic SBOM generation with all dependencies Sprint 2: T015-T020 - Add SBOM validation Sprint 3: T021-T027 - GitHub Dependency Graph integration Sprint 4: T028-T032 - SPDX compliance verification Sprint 5: T033-T043 - PR testing workflow Sprint 6: T044-T050 - Polish and documentation Task Complexity Simple (1-2 hours): T001-T003, T010, T025, T029-T032, T044-T050 Medium (3-5 hours): T004-T009, T011-T014, T015-T020, T028, T033-T043 Complex (6+ hours): T021-T024, T026-T027 Total Estimated Effort: ~35-45 hours Validation Checklist Before marking this feature complete, verify: [ ] All direct dependencies appear in generated SBOM [ ] All transitive dependencies appear in generated SBOM [ ] Platform-specific dependencies for all targets (win-x64, linux-x64, linux-arm, osx-arm64) included [ ] SBOM validates against SPDX 2.3 schema [ ] SBOM includes version information for all packages [ ] SBOM includes license information (or NOASSERTION) for all packages [ ] GitHub Dependency Graph displays all dependencies [ ] Dependabot alerts are generated for vulnerable dependencies [ ] SBOM file is downloadable from GitHub Release assets [ ] PR workflow catches SBOM generation failures [ ] Pipeline fails if SBOM generation fails [ ] Pipeline fails if GitHub API submission fails [ ] Pipeline fails if SBOM validation fails [ ] Performance: 50 dependencies → <5 minutes [ ] Performance: 200 dependencies → <15 minutes [ ] NuGet cache reduces restore time by 80% on repeat builds [ ] Documentation explains how to download and use SBOM [ ] Renovate can read dependency information from GitHub Dependency Graph Notes Key Design Decisions No source code changes: All changes are workflow-only Microsoft SBOM Tool: Official tool for .NET projects, SPDX 2.3+ compliant Fail-fast: Any SBOM-related failure stops the release (quality gate) PR testing: Dry-run mode prevents polluting production Dependency Graph Multi-platform restore: Ensures platform-specific dependencies are captured Technical Risks Risk Mitigation Large solution timeout (>200 deps) 15-min timeout + caching + parallel GitHub API rate limits Unlikely in GitHub Actions (5000/hr) Platform-specific dependency leakage Restore for all platforms explicitly Release failure discovery PR testing catches issues early Dependency Graph pollution from PRs Dry-run mode in sbom-test.yml Future Enhancements (Out of Scope) SBOM signing with digital signatures CycloneDX format support (in addition to SPDX) Automated vulnerability scanning in workflow SBOM diff between releases Historical SBOM archive"
  }
}